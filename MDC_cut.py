# MDC cut GUI
__version__ = "6.1.4"
__release_date__ = "2025-06-16"
import os, inspect
import json
import tkinter as tk
from tkinter import filedialog as fd
import io
from base64 import b64decode
import queue
import threading
import warnings
import sys
from ctypes import windll
import copy
from datetime import datetime
import gc
from tkinter import messagebox
from multiprocessing import Pool
import time, subprocess
cdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
app_name = os.path.basename(inspect.stack()[0].filename).removesuffix('.py')
if os.name == 'nt':  # only execute on Windows OS
    cdir = cdir[0].upper() + cdir[1:]
try:
    os.chdir(cdir)
    if os.path.exists('pip_check.txt')==0:
        try:
            subprocess.check_call([sys.executable, "-m", "pip", "--version"])
            with open ('pip_check.txt', 'w', encoding = 'utf-8') as f:
                f.write('pip found')
                f.close()
        except subprocess.CalledProcessError:
            try:
                if os.name == 'nt':
                    print('pip not found\nOS: Windows\nInstalling pip...')
                    os.system('python -m ensurepip')    #install pip
                    os.system('python "'+os.path.abspath(inspect.getfile(inspect.currentframe()))+'"')  #restart the script to ensure pip works without potential errors
                elif os.name == 'posix':
                    print('pip not found\nOS: Linux or MacOS\nInstalling pip...')
                    try:    #python3 if installed
                        os.system('python3 -m ensurepip')   #install pip
                        os.system('python3 "'+os.path.abspath(inspect.getfile(inspect.currentframe()))+'"')   #restart the script to ensure pip works without potential errors
                    except: #python2.7(default in MacOS)
                        os.system('python -m ensurepip')
                        os.system('python "'+os.path.abspath(inspect.getfile(inspect.currentframe()))+'"')
                with open ('pip_check.txt', 'w', encoding = 'utf-8') as f:
                    f.write('pip found')
                    f.close()
            except Exception as e:
                print(f"An error occurred: {e}")
            quit()  #end the current script
except:
    pass
def restart():
    if os.name == 'nt':
        os.system('python "'+os.path.abspath(inspect.getfile(inspect.currentframe()))+'"')
    elif os.name == 'posix':
        try:
            os.system('python3 "'+os.path.abspath(inspect.getfile(inspect.currentframe()))+'"')
        except:
            os.system('python "'+os.path.abspath(inspect.getfile(inspect.currentframe()))+'"')
def install(s: str):
    print('\n\n"'+s+'" Module Not Found')
    a = input('pip install '+s+' ???\nProceed (Y/n)? ')
    if a.lower() == 'y':
        if s == 'matplotlib':
            try:
                subprocess.check_call([sys.executable, "-m", "pip", "install", s+'==3.8.4'])
            except subprocess.CalledProcessError:
                subprocess.check_call([sys.executable, "-m", "pip3", "install", s+'==3.8.4'])
        elif s == 'numpy':
            try:
                subprocess.check_call([sys.executable, "-m", "pip", "install", s+'==1.26.4'])
            except subprocess.CalledProcessError:
                subprocess.check_call([sys.executable, "-m", "pip3", "install", s+'==1.26.4'])
        else:
            try:
                subprocess.check_call([sys.executable, "-m", "pip", "install", s])
            except subprocess.CalledProcessError:
                subprocess.check_call([sys.executable, "-m", "pip3", "install", s])
    else:
        quit()
try:
    import matplotlib   # matplotlib version: 3.8.4
    if matplotlib.__version__ != '3.8.4':
        os.system('pip install matplotlib==3.8.4')
except ModuleNotFoundError:
    install('matplotlib')
    import matplotlib
matplotlib.use('TkAgg')
from matplotlib.colors import LinearSegmentedColormap
from matplotlib.widgets import SpanSelector
from matplotlib.widgets import RectangleSelector
import matplotlib as mpl
from matplotlib.widgets import Cursor
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider
try:
    import numpy as np
    if np.__version__ != '1.26.4':
        os.system('pip install numpy==1.26.4')
except ModuleNotFoundError:
    install('numpy')
    import numpy as np
try:
    import xarray as xr
except ModuleNotFoundError:
    install('xarray')
    import xarray as xr
try:
    import h5py
except ModuleNotFoundError:
    install('h5py')
    import h5py
try:
    from PIL import Image, ImageTk
except ModuleNotFoundError:
    install('Pillow')
    restart()
    quit()
try:
    from scipy.optimize import curve_fit
    from scipy.ndimage import gaussian_filter1d
    from scipy.signal import hilbert
    from scipy.signal import savgol_filter
    from scipy.stats import mode
    from scipy.interpolate import griddata
    from scipy import special
except ModuleNotFoundError:
    install('scipy')
    from scipy.optimize import curve_fit
    from scipy.ndimage import gaussian_filter1d
    from scipy.signal import hilbert
    from scipy.signal import savgol_filter
    from scipy.stats import mode
    from scipy.interpolate import griddata
    from scipy import special
try:
    from lmfit import Parameters, Minimizer, report_fit
except ModuleNotFoundError:
    install('lmfit')
    from lmfit import Parameters, Minimizer, report_fit
from lmfit.printfuncs import *
try:
    import tqdm
except ModuleNotFoundError:
    install('tqdm')
    import tqdm
try:
    import win32clipboard
except ModuleNotFoundError:
    install('pywin32')
    restart()
    quit()
try:
    import originpro as op
except ModuleNotFoundError:
    install('originpro')
    import originpro as op
try:
    import cv2
except ModuleNotFoundError:
    install('opencv-python')
    restart()
    quit()
try:
    import cpuinfo
except ModuleNotFoundError:
    install('py-cpuinfo')
    import cpuinfo
try:
    import psutil
except ModuleNotFoundError:
    install('psutil')
    import psutil

warnings.filterwarnings("ignore", category=UserWarning)
warnings.filterwarnings("ignore", category=RuntimeWarning)
warnings.filterwarnings("ignore", category=matplotlib.MatplotlibDeprecationWarning)
warnings.filterwarnings("ignore", category=SyntaxWarning)
h=6.62607015*10**-34
m=9.10938356*10**-31
mp, ep, mf, ef = 1, 1, 1, 1
fk = []
fev = []
    
def load_txt(path_to_file: str) -> xr.DataArray:    #for BiSe txt files 
#Liu, J. N., Yang, X., Xue, H., Gai, X. S., Sun, R., Li, Y., ... & Cheng, Z. H. (2023). Surface coupling in Bi2Se3 ultrathin films by screened Coulomb interaction. Nature Communications, 14(1), 4424.
    """
    Load data from a text file and convert it into an xarray DataArray.

    Parameters:
        path_to_file (str): The path to the text file.

    Returns:
        xr.DataArray: The data loaded from the text file as an xarray DataArray.
    """
    print(path_to_file)
    with open(path_to_file, 'r') as file:
        i = 0
        a = []
        e = []
        for line in file:
            if i == 1:
                a = line.split('\t')[2::]
            if i >= 2:
                e.append(line.split('\t')[1])
            i += 1
    d = np.arange(float(len(e)*len(a))).reshape(len(e), len(a))
    with open(path_to_file, 'r') as file:
        i = 0
        for line in file:
            if i >= 2:
                d[i-2][:] = line.split('\t')[2::]
                if i == 2:
                    t = line.split('\t')[2::]
            i += 1
    e_low = np.min(np.float64(e))
    e_high = np.max(np.float64(e))
    e_num = len(e)
    e_photon = 21.2
    a_low = np.min(np.float64(a))
    a_high = np.max(np.float64(a))
    a_num = len(a)
    #   attrs
    e_mode = 'Kinetic'
    LensMode = 'Unknown'
    PassEnergy = 5
    Dwell = 'Unknown'
    CenterEnergy = np.average(np.float64(e))
    Iterations = 'Unknown'
    Step = (e_high - e_low)/(e_num - 1)
    Slit = 'Unknown'
    aq = 'Unknown'
    name = os.path.basename(path_to_file).removesuffix('.txt')
    if e_mode == 'Kinetic':
        e = np.linspace(e_low, e_high, e_num)
        CenterEnergy = str(CenterEnergy)+' eV'
        e_low = str(e_low)+' eV (K.E.)'
        e_high = str(e_high)+' eV (K.E.)'
    else:
        e = np.linspace(e_photon-e_high, e_photon-e_low, e_num)
        CenterEnergy = str(CenterEnergy)+' eV'
        e_low = str(e_low)+' eV (B.E.)'
        e_high = str(e_high)+' eV (B.E.)'

    a = np.linspace(a_low, a_high, a_num)
    # data=np.arange(float(len(e)*len(a))).reshape(len(e),len(a),1)
    # data[0:,0:,0]=d
    data = np.arange(float(len(e)*len(a))).reshape(len(e), len(a))
    data[0:, 0:] = d
    data = xr.DataArray(data,
                        coords={'eV': e, 'phi': a},
                        attrs={'Name': name,
                            'Acquisition': aq,
                            'EnergyMode': e_mode,
                            'ExcitationEnergy': str(e_photon)+' eV',
                            'CenterEnergy': CenterEnergy,
                            'HighEnergy': e_high,
                            'LowEnergy': e_low,
                            'Step': str(Step)+' eV',
                            'LensMode': LensMode,
                            'PassEnergy': str(PassEnergy)+' meV',
                            'Slit': Slit,
                            'Dwell': str(Dwell)+' s',
                            'Iterations': Iterations,
                            'Description': 'BiSe',
                            'Path': path_to_file
                            })
    return data

def load_txt_sk(path_to_file: str) -> xr.DataArray:    #for sklearn txt files
    """
    Args:
        path_to_file (str): File Path

    Returns:
        xr.DataArray: shape=(len(eV), len(phi))
    """
    name = os.path.basename(path_to_file).removesuffix('.txt')
    e = np.linspace(21.2-1,21.2+0.2,659)    #fix BE 1~-0.2
    # e = np.linspace(21.2-2,21.2+1,284)     #scan BE 2~-1
    a = np.linspace(-10,10,494)     #A20
    description='SKNET'
    e_low = str(np.min(np.float64(e)))+ ' eV (K.E.)'
    e_high = str(np.max(np.float64(e)))+ ' eV (K.E.)'
    e_photon = 21.2
    #   attrs
    e_mode = 'Kinetic'
    LensMode = 'Unknown'
    PassEnergy = 'Unknown'
    Dwell = 'Unknown'
    CenterEnergy = str(np.average(np.float64(e)))+ ' eV (K.E.)'
    Iterations = 'Unknown'
    Step = abs(e[1]-e[0])
    Slit = 'Unknown'
    aq = 'SRNET'
    data = np.loadtxt(path_to_file).transpose()*100
    data = xr.DataArray(data,
                        coords={'eV': e, 'phi': a},
                        attrs={'Name': name,
                            'Acquisition': aq,
                            'EnergyMode': e_mode,
                            'ExcitationEnergy': str(e_photon)+' eV',
                            'CenterEnergy': CenterEnergy,
                            'HighEnergy': e_high,
                            'LowEnergy': e_low,
                            'Step': str(Step)+' eV',
                            'LensMode': LensMode,
                            'PassEnergy': str(PassEnergy)+' eV',
                            'Slit': Slit,
                            'Dwell': Dwell,
                            'Iterations': Iterations,
                            'Description': description,
                            'Path': path_to_file
                            })
    return data

def load_json(path_to_file: str) -> xr.DataArray:
    """
    Load data from a JSON file and convert it into an xarray DataArray.

    Parameters:
        path_to_file (str): The path to the JSON file.

    Returns:
        xr.DataArray: The data loaded from the JSON file as an xarray DataArray.
    """
    f = json.load(open(path_to_file, 'r'))
    e_low = np.array(f['Region']['LowEnergy']['Value'])
    e_high = np.array(f['Region']['HighEnergy']['Value'])
    e_num = np.array(f['Data']['XSize']['Value'])
    e_photon = np.array(f['Region']['ExcitationEnergy']['Value'])
    a_low = np.array(f['Region']['YScaleMin']['Value'])
    a_high = np.array(f['Region']['YScaleMax']['Value'])
    a_num = np.array(f['Data']['YSize']['Value'])
    #   attrs
    e_mode = f['Region']['EnergyMode']
    LensMode = f['Region']['LensMode']
    PassEnergy = f['Region']['PassEnergy']['Value']
    Dwell = f['Region']['Dwell']['Value']
    CenterEnergy = f['Region']['CenterEnergy']['Value']
    Iterations = f['Region']['Iterations']['Value']
    Step = f['Region']['Step']['Value']
    Slit = f['Region']['Slit']
    aq = f['Region']['Acquisition']
    name = f['Region']['Name']
    description = f['Region']['Description']
    if e_mode == 'Kinetic':
        e = np.linspace(e_low, e_high, e_num)
        CenterEnergy = str(CenterEnergy)+' eV'
        e_low = str(e_low)+' eV (K.E.)'
        e_high = str(e_high)+' eV (K.E.)'
    else:
        e = np.linspace(e_photon-e_high, e_photon-e_low, e_num)
        CenterEnergy = str(CenterEnergy)+' eV'
        e_low = str(e_low)+' eV (B.E.)'
        e_high = str(e_high)+' eV (B.E.)'

    a = np.linspace(a_low, a_high, a_num)
    d = np.array(f['Spectrum']).transpose()
    # data=np.arange(float(len(e)*len(a))).reshape(len(e),len(a),1)
    # data[0:,0:,0]=d
    data = np.arange(float(len(e)*len(a))).reshape(len(e), len(a))
    data[0:, 0:] = d
    data = xr.DataArray(data,
                        coords={'eV': e, 'phi': a},
                        attrs={'Name': name,
                            'Acquisition': aq,
                            'EnergyMode': e_mode,
                            'ExcitationEnergy': str(e_photon)+' eV',
                            'CenterEnergy': CenterEnergy,
                            'HighEnergy': e_high,
                            'LowEnergy': e_low,
                            'Step': str(Step)+' eV',
                            'LensMode': LensMode,
                            'PassEnergy': str(PassEnergy)+' eV',
                            'Slit': Slit,
                            'Dwell': str(Dwell)+' s',
                            'Iterations': Iterations,
                            'Description': description,
                            'Path': path_to_file
                            })
    return data

cec = None
f_npz = 0
def load_h5(path_to_file: str) -> xr.DataArray:
    """
    Load data from an HDF5 file and return it as a DataArray.

    Parameters:
        path_to_file (str): The path to the HDF5 file.

    Returns:
        xr.DataArray: The loaded data as a DataArray.

    """
    f = h5py.File(path_to_file, 'r')
    e_low = np.array(f.get('Region').get('LowEnergy').get('Value'))[0]
    e_high = np.array(f.get('Region').get('HighEnergy').get('Value'))[0]
    e_num = np.array(f.get('Data').get('XSize').get('Value'))[0]
    e_photon = np.array(f.get('Region').get(
        'ExcitationEnergy').get('Value'))[0]
    a_low = np.array(f.get('Region').get('YScaleMin').get('Value'))[0]
    a_high = np.array(f.get('Region').get('YScaleMax').get('Value'))[0]
    a_num = np.array(f.get('Data').get('YSize').get('Value'))[0]
    #   attrs
    t_e_mode = np.array(f.get('Region').get('EnergyMode'), dtype=str)
    t_LensMode = np.array(f.get('Region').get('LensMode'), dtype=str)
    PassEnergy = np.array(f.get('Region').get(
        'PassEnergy').get('Value'), dtype=str)[0]
    Dwell = np.array(f.get('Region').get('Dwell').get('Value'), dtype=str)[0]
    CenterEnergy = np.array(f.get('Region').get(
        'CenterEnergy').get('Value'), dtype=str)[0]
    Iterations = np.array(f.get('Region').get(
        'Iterations').get('Value'), dtype=str)[0]
    Step = np.array(f.get('Region').get('Step').get('Value'), dtype=str)[0]
    t_Slit = np.array(f.get('Region').get('Slit'), dtype=str)
    t_aq = np.array(f.get('Region').get('Acquisition'), dtype=str)
    try:
        flag = np.array(f.get('Region').get('Name'), dtype=str)[1]
        t_name = np.array(f.get('Region').get('Name'), dtype=str)
    except:        
        t_name = np.array(f.get('Region').get('Name'), dtype='S')  # Read as bytes
        t_name = t_name.tobytes().decode('utf-8')   # Convert to string
    try:
        flag = np.array(f.get('Region').get('Description'), dtype=str)[1]
        t_description = np.array(f.get('Region').get('Description'), dtype=str)
    except:
        t_description = np.array(f.get('Region').get('Description'), dtype='S')  # Read as bytes
        t_description = t_description.tobytes().decode('utf-8')   # Convert to string
    try:
        flag = np.array(f.get('Region').get('EnergyMode'), dtype=str)[1]
        t_e_mode = np.array(f.get('Region').get('EnergyMode'), dtype=str)
        t_LensMode = np.array(f.get('Region').get('LensMode'), dtype=str)
        t_Slit = np.array(f.get('Region').get('Slit'), dtype=str)
        t_aq = np.array(f.get('Region').get('Acquisition'), dtype=str)
    except:
        flag = 'pass_byte'
        t_e_mode = np.array(f.get('Region').get('EnergyMode'), dtype='S')  # Read as bytes
        t_e_mode = t_e_mode.tobytes().decode('utf-8')   # Convert to string
        t_LensMode = np.array(f.get('Region').get('LensMode'), dtype='S')  # Read as bytes
        t_LensMode = t_LensMode.tobytes().decode('utf-8')   # Convert to string
        t_Slit = np.array(f.get('Region').get('Slit'), dtype='S')  # Read as bytes
        t_Slit = t_Slit.tobytes().decode('utf-8')   # Convert to string
        t_aq = np.array(f.get('Region').get('Acquisition'), dtype='S')  # Read as bytes
        t_aq = t_aq.tobytes().decode('utf-8')   # Convert to string        
        
    e_mode = ''
    LensMode = ''
    Slit = ''
    aq = ''
    name = ''
    description = ''
    if flag != 'pass_byte':
        for i in range(60):  # proper length long enough
            e_mode += t_e_mode[i]
            LensMode += t_LensMode[i]
            Slit += t_Slit[i]
            aq += t_aq[i]
    else:
        e_mode = t_e_mode
        LensMode = t_LensMode
        Slit = t_Slit
        aq = t_aq
    for i in range(600):
        try:
            name += t_name[i]
        except:
            pass
        try:
            description += t_description[i]
        except:
            pass
    if e_mode == 'Kinetic':
        e = np.linspace(e_low, e_high, e_num)
        CenterEnergy = str(CenterEnergy)+' eV'
        e_low = str(e_low)+' eV (K.E.)'
        e_high = str(e_high)+' eV (K.E.)'
    else:
        e = np.linspace(e_photon-e_high, e_photon-e_low, e_num)
        CenterEnergy = str(CenterEnergy)+' eV'
        e_low = str(e_low)+' eV (B.E.)'
        e_high = str(e_high)+' eV (B.E.)'
    if aq == 'VolumeSlicer':
        global f_npz
        tlf_path = np.array(f.get('VolumeSlicer').get('path'), dtype='S')
        lf_path = [i.tobytes().decode('utf-8') for i in tlf_path]
        try:
            try:    #load path that saved in npz
                tbasename = os.path.basename(lf_path[0])
                if '.h5' in tbasename:
                    td=load_h5(lf_path[0])
                elif '.json' in tbasename:
                    td=load_json(lf_path[0])
                elif '.txt' in tbasename:
                    td=load_txt(lf_path[0])
            except: #try load file in the same folder as npz
                td = None
                tlfpath = []
                for i in lf_path:
                    tbasename = os.path.basename(i)
                    tpath = os.path.normpath(os.path.join(os.path.dirname(path_to_file), tbasename))
                    tlfpath.append(tpath)
                    try:
                        if '.h5' in tbasename:
                            td=load_h5(tpath)
                        elif '.json' in tbasename:
                            td=load_json(tpath)
                        elif '.txt' in tbasename:
                            td=load_txt(tpath)
                    except:
                        pass
            PassEnergy = td.attrs['PassEnergy']
            Dwell = td.attrs['Dwell']
            Iterations = td.attrs['Iterations']
            Slit = td.attrs['Slit']
            if __name__ == '__main__':
                if f_npz==0:
                    f_npz+=1
                    angle = np.array(f.get('VolumeSlicer').get('angle'))[0]
                    cx = np.array(f.get('VolumeSlicer').get('cx'))[0]
                    cy = np.array(f.get('VolumeSlicer').get('cy'))[0]
                    cdx = np.array(f.get('VolumeSlicer').get('cdx'))[0]
                    cdy = np.array(f.get('VolumeSlicer').get('cdy'))[0]
                    phi_offset = np.array(f.get('VolumeSlicer').get('phi_offset'))[0]
                    r1_offset = np.array(f.get('VolumeSlicer').get('r1_offset'))[0]
                    slim = np.array(f.get('VolumeSlicer').get('slim'))[0]
                    try:
                        '''
                        After 6.0 version, the symmetry information is added to attributes
                        '''
                        sym = np.array(f.get('VolumeSlicer').get('sym'))[0]
                    except:
                        sym = 1
                        pass
                    global cec
                    try:
                        cec=CEC(g, lf_path, mode='load')
                        cec.load(angle, cx, cy, cdx, cdy, phi_offset, r1_offset, slim, sym, name, path_to_file)
                    except:
                        cec=CEC(g, tlfpath, mode='load')
                        cec.load(angle, cx, cy, cdx, cdy, phi_offset, r1_offset, slim, sym, name, path_to_file)
        except Exception as ecp:
            if __name__ == '__main__':
                if f_npz==0:
                    f_npz+=1
                    hwnd = windll.user32.FindWindowW(None, "C:\\Windows\\system32\\cmd.exe")
                    if hwnd:
                        windll.user32.SetForegroundWindow(hwnd)
                    print(f"An error occurred: {ecp}")
                    print('\033[31mPath not found:\033[34m')
                    print(lf_path)
                    print('\033[31mPlace all the raw data files listed above in the same folder as the NPZ file\nif you want to view the slicing geometry or just ignore this message if you do not need the slicing geometry.\033[0m')
                    message = f"Path not found:\n{lf_path}\nPlace all the raw data files listed above in the same folder as the NPZ file if you want to view the slicing geometry\nor just ignore this message if you do not need the slicing geometry."
                    messagebox.showwarning("Warning", message)
    
    a = np.linspace(a_low, a_high, a_num)
    d = np.array(f.get('Spectrum')).transpose()
    # data=np.arange(float(len(e)*len(a))).reshape(len(e),len(a),1)
    # data[0:,0:,0]=d
    data = np.arange(float(len(e)*len(a))).reshape(len(e), len(a))
    if flag != 'pass_byte':
        data[0:, 0:] = d
    else:
        Dwell = Dwell.removesuffix(' s')
        PassEnergy = PassEnergy.removesuffix(' eV')
        data[0:, 0:] = d.T
    data = xr.DataArray(data,
                        coords={'eV': e, 'phi': a},
                        attrs={'Name': name,
                            'Acquisition': aq,
                            'EnergyMode': e_mode,
                            'ExcitationEnergy': str(e_photon)+' eV',
                            'CenterEnergy': CenterEnergy,
                            'HighEnergy': e_high,
                            'LowEnergy': e_low,
                            'Step': str(Step)+' eV',
                            'LensMode': LensMode,
                            'PassEnergy': str(PassEnergy)+' eV',
                            'Slit': Slit,
                            'Dwell': str(Dwell)+' s',
                            'Iterations': Iterations,
                            'Description': description,
                            'Path': path_to_file
                            })
    return data

def load_npz(path_to_file: str) -> xr.DataArray:
    """
    Load data from a NumPy NPZ file and convert it into an xarray DataArray.
    
    Parameters:
        path_to_file (str): The path to the NPZ file.
        
    Returns:
        xr.DataArray: The data loaded from the NPZ file as an xarray DataArray.
    """
    global f_npz
    f = np.load(path_to_file)
    lf_path = f['path']
    try:
        try:    #load path that saved in npz
            tbasename = os.path.basename(lf_path[0])
            if '.h5' in tbasename:
                td=load_h5(lf_path[0])
            elif '.json' in tbasename:
                td=load_json(lf_path[0])
            elif '.txt' in tbasename:
                td=load_txt(lf_path[0])
        except: #try load file in the same folder as npz
            td = None
            tlfpath = []
            for i in lf_path:
                tbasename = os.path.basename(i)
                tpath = os.path.normpath(os.path.join(os.path.dirname(path_to_file), tbasename))
                tlfpath.append(tpath)
                try:
                    if '.h5' in tbasename:
                        td=load_h5(tpath)
                    elif '.json' in tbasename:
                        td=load_json(tpath)
                    elif '.txt' in tbasename:
                        td=load_txt(tpath)
                except:
                    pass
        Name = os.path.basename(path_to_file).split('.npz')[0]
        PassEnergy = td.attrs['PassEnergy']
        Dwell = td.attrs['Dwell']
        Iterations = td.attrs['Iterations']
        Slit = td.attrs['Slit']
        if __name__ == '__main__':
            if f_npz==0:
                f_npz+=1
                angle = f['angle']
                cx = f['cx']
                cy = f['cy']
                cdx = f['cdx']
                cdy = f['cdy']
                phi_offset = f['phi_offset']
                r1_offset = f['r1_offset']
                slim = f['slim']
                try:
                    '''
                    After 6.0 version, the symmetry information is added to attributes
                    '''
                    sym = f['sym']
                except:
                    sym = 1
                    pass
                global cec
                try:
                    cec=CEC(g, lf_path, mode='load')
                    cec.load(angle, cx, cy, cdx, cdy, phi_offset, r1_offset, slim, sym, Name, path_to_file)
                except:
                    cec=CEC(g, tlfpath, mode='load')
                    cec.load(angle, cx, cy, cdx, cdy, phi_offset, r1_offset, slim, sym, Name, path_to_file)
    except Exception as e:
        if __name__ == '__main__':
            if f_npz==0:
                f_npz+=1
                hwnd = windll.user32.FindWindowW(None, "C:\\Windows\\system32\\cmd.exe")
                if hwnd:
                    windll.user32.SetForegroundWindow(hwnd)
                print(f"An error occurred: {e}")
                print('\033[31mPath not found:\033[34m')
                print(lf_path)
                print('\033[31mPlace all the raw data files listed above in the same folder as the NPZ file\nif you want to view the slicing geometry or just ignore this message if you do not need the slicing geometry.\033[0m')
                message = f"Path not found:\n{lf_path}\nPlace all the raw data files listed above in the same folder as the NPZ file if you want to view the slicing geometry\nor just ignore this message if you do not need the slicing geometry."
                messagebox.showwarning("Warning", message)
        PassEnergy = 'Unknown'
        Dwell = 'Unknown'
        Iterations = 'Unknown'
        Slit = 'Unknown'
    data = f['data']
    phi = f['x']
    ev = f['y']
    ExcitationEnergy = f['e_photon']
    desc = f['desc'][0]
    data = xr.DataArray(data,
                        coords={'eV': ev, 'phi': phi},
                        attrs={'Name': Name,
                            'Acquisition': 'VolumeSlicer',
                            'EnergyMode': 'Kinetic',
                            'ExcitationEnergy': str(ExcitationEnergy)+' eV',
                            'CenterEnergy': '%.3f'%((ev[0]+ev[-1])/2)+' eV',
                            'HighEnergy': str(ev[-1])+' eV (K.E.)',
                            'LowEnergy': str(ev[0])+' eV (K.E.)',
                            'Step': str(ev[1]-ev[0])+' eV',
                            'LensMode': 'Angular',
                            'PassEnergy': PassEnergy,
                            'Slit': Slit,
                            'Dwell': Dwell,
                            'Iterations': Iterations,
                            'Description': desc,
                            'Path': path_to_file
                            })
    return data

def g_emode():
    global gfe,fe_in,b_emode,emf,v_fe
    gfe=tk.Toplevel(g,bg='white')
    gfe.title('Fermi Level')
    fr=tk.Frame(gfe,bg='white')
    fr.grid(row=0,column=0)
    l_in = tk.Label(fr, text='Fermi Level (eV) : ', font=('Arial', 16, "bold"), bg='white')
    l_in.grid(row=0,column=0)
    fe_in = tk.Entry(fr, font=("Arial", 16, "bold"), width=10, textvariable=v_fe, bd=5)
    fe_in.grid(row=0,column=1)
    fr1 = tk.Frame(gfe,bg='white')
    fr1.grid(row=1,column=0)
    b1=tk.Button(fr1,text='Confirm',command=save_fe, width=15, height=1, font=('Arial', 14, "bold"), bg='white', bd=5)
    b1.grid(row=1,column=0)
    gfe.bind('<Return>', on_enter)
    gfe.focus_set()
    fe_in.focus_set()
    fe_in.icursor(tk.END)
    gfe.update()

def emode():
    global gfe,fe_in,b_emode,emf,v_fe,mfpr
    try:
        gfe.destroy()
    except:
        pass
    mfpr=0
    if emf=='KE':
        emf='BE'
        b_emode.config(text='B.E.')
        g_emode()
    else:
        emf='KE'
        b_emode.config(text='K.E.')
        g_emode()

def save_fe():
    global gfe,fe_in,vfe
    try:
        vfe=float(fe_in.get())
        gfe.destroy()
    except:
        tk.messagebox.showwarning("Warning","Invalid Input\n"+str(sys.exc_info()[1]))
        gfe.destroy()
        g_emode()

def on_enter(event):
    save_fe()

def patch_origin():
    threading.Thread(target=f_patch_origin,daemon=True).start()

def f_patch_origin():
    limg.config(image=img[np.random.randint(len(img))])
########################### patching ############################
    print('Patching OriginPro...')
    st.put('Patching OriginPro...')
    exe=rf"\Origin.exe" # OriginPro Patching file
    cmd=f'start cmd /C "dir "{exe}" /s"'
    result = os.popen(cmd) # 返回的結果是一個<class 'os._wrap_close'>對象，需要讀取後才能處理
    context = result.read()
    for line in context.splitlines():
        if '的目錄' in line or 'Directory of' in line:
            path = line.removeprefix('Directory of ')
            path = line.removesuffix(' 的目錄')
            # print(line)
            # print(path)
            path = path.removeprefix(" ")
            path = rf"{path}"
            path = rf"{path}{exe}"
            if path.split(os.sep)[-2] != 'Crack':
                ori_temp_path = path.removesuffix(os.sep+path.split(os.sep)[-1])
                print('Origin Path: '+ori_temp_path)
                os.system(f"\"{path}\"")
    result.close()
    print('Patching OriginPro...Done')
    st.put('Patching OriginPro...Done')
########################### patching ############################

def pre_process(input):
        return str(input).replace(' ',', ').replace(', , , , ,',',').replace(', , , ,',',').replace(', , ,',',').replace(', ,',',').replace('[, ','[').replace(', ]',']')

def gui_exp_origin():
    global gori,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11
    limg.config(image=img[np.random.randint(len(img))])
    gori=tk.Toplevel(g,bg='white')
    gori.title('Export to Origin')
    l1=tk.Label(gori,text=f"{dpath.removesuffix('.h5').removesuffix('.json').removesuffix('.txt')}.opj",font=('Arial', 10, "bold"),bg='white',wraplength=600)
    l1.grid(row=0,column=0)
    b1=tk.Button(gori,text='Patch Origin',command=patch_origin, width=15, height=1, font=('Arial', 18, "bold"), bg='white', bd=5)
    b1.grid(row=1,column=0)
    fr=tk.Frame(gori,bg='white')
    fr.grid(row=2,column=0)
    pr_exp_origin()
    v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11=tk.IntVar(),tk.IntVar(),tk.IntVar(),tk.IntVar(),tk.IntVar(),tk.IntVar(),tk.IntVar(),tk.IntVar(),tk.IntVar(),tk.IntVar(),tk.IntVar()
    c1=tk.Checkbutton(fr,text='E-Phi (Raw Data)',variable=v1,font=('Arial', 18, "bold"),bg='white')
    if npzf:c1.config(text='E-K (Sliced Data)')
    c1.grid(row=0,column=0,sticky='w')
    c2=tk.Checkbutton(fr,text='E-K (Processed Data)',variable=v2,font=('Arial', 18, "bold"),bg='white')
    c2.grid(row=1,column=0,sticky='w')
    c3=tk.Checkbutton(fr,text='MDC Fit Position',variable=v3,font=('Arial', 18, "bold"),bg='white')
    c3.grid(row=2,column=0,sticky='w')
    c4=tk.Checkbutton(fr,text='MDC Fit FWHM',variable=v4,font=('Arial', 18, "bold"),bg='white')
    c4.grid(row=3,column=0,sticky='w')
    c5=tk.Checkbutton(fr,text='EDC Fit Position',variable=v5,font=('Arial', 18, "bold"),bg='white')
    c5.grid(row=4,column=0,sticky='w')
    c6=tk.Checkbutton(fr,text='EDC Fit FWHM',variable=v6,font=('Arial', 18, "bold"),bg='white')
    c6.grid(row=5,column=0,sticky='w')
    c7=tk.Checkbutton(fr,text='Self Energy Real Part',variable=v7,font=('Arial', 18, "bold"),bg='white')
    c7.grid(row=6,column=0,sticky='w')
    c8=tk.Checkbutton(fr,text='Self Energy Imaginary Part',variable=v8,font=('Arial', 18, "bold"),bg='white')
    c8.grid(row=7,column=0,sticky='w')
    c9=tk.Checkbutton(fr,text='Data plot with pos',variable=v9,font=('Arial', 18, "bold"),bg='white')
    c9.grid(row=8,column=0,sticky='w')
    c10=tk.Checkbutton(fr,text='Data plot with pos & bare band',variable=v10,font=('Arial', 18, "bold"),bg='white')
    c10.grid(row=9,column=0,sticky='w')
    c11=tk.Checkbutton(fr,text='Second Derivative',variable=v11,font=('Arial', 18, "bold"),bg='white')
    c11.grid(row=10,column=0,sticky='w')
    b2=tk.Button(fr,text='Export',command=exp_origin, width=15, height=1, font=('Arial', 18, "bold"), bg='white', bd=5)
    b2.grid(row=11,column=0)
    cl=[c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11]
    for i in range(len(cl)):
        if i in no:
            cl[i].deselect()
            cl[i].config(state='disabled')
        else:
            cl[i].config(state='normal')
            cl[i].select()
    if npzf:
        c2.deselect()
        c2.config(state='disabled')
    gori.bind('<Return>', exp_origin)
    gori.focus_set()
    gori.update()
    
def pr_exp_origin():
    global cmdlist, no
    ex_raw,ex_ek,ex_mp,ex_mf,ex_ep,ex_ef,ex_ser,ex_sei,ex_dpp,ex_dppbb,ex_sd='','','','','','','','','','',''
    cmdlist=dict({0:f'{ex_raw}',1:f'{ex_ek}',2:f'{ex_mp}',3:f'{ex_mf}',4:f'{ex_ep}',5:f'{ex_ef}',6:f'{ex_ser}',7:f'{ex_sei}',8:f'{ex_dpp}',9:f'{ex_dppbb}',10:f'{ex_sd}'})
    no=[]
    try:
        cmdlist[0]=f'''plot2d()\n'''
    except:
        no.append(0)
    try:
        cmdlist[1]=f'''plot2d(title='E-K (Processed Data)')\n'''
    except:
        no.append(1)
    try:
        ophi = np.arcsin(rpos/(2*m*fev*1.602176634*10**-19)**0.5 /
                        10**-10*(h/2/np.pi))*180/np.pi
        pos = (2*m*fev*1.602176634*10**-19)**0.5 * \
            np.sin((np.float64(k_offset.get())+ophi)/180*np.pi)*10**-10/(h/2/np.pi)
        cmdlist[2]=f'''plot1d(x={pre_process((vfe-fev)*1000)}, y1={pre_process(pos)}, title='MDC Fit Position', xlabel='Binding Energy', ylabel='k', xunit='meV', yunit=r"2\g(p)Å\+(-1)")\n'''
    except:
        no.append(2)
    try:
        cmdlist[3]=f'''plot1d(x={pre_process((vfe-fev)*1000)}, y1={pre_process(fwhm)}, title='MDC Fit FWHM', xlabel='Binding Energy', ylabel='k', xunit='meV', yunit=r"2\g(p)Å\+(-1)")\n'''
    except:
        no.append(3)
    try:
        cmdlist[4]=f'''plot1d(x={pre_process(fk)}, y1={pre_process((vfe-epos)*1000)}, title='EDC Fit Position', xlabel='k', ylabel='Binding Energy', xunit=r"2\g(p)Å\+(-1)", yunit='meV')\n'''
    except:
        no.append(4)
    try:
        cmdlist[5]=f'''plot1d(x={pre_process(fk)}, y1={pre_process(efwhm)}, title='EDC Fit FWHM', xlabel='k', ylabel='Binding Energy', xunit=r"2\g(p)Å\+(-1)", yunit='meV')\n'''
    except:
        no.append(5)
    try:
        ophi = np.arcsin(rpos/(2*m*fev*1.602176634*10**-19)**0.5 /
                        10**-10*(h/2/np.pi))*180/np.pi
        pos = (2*m*fev*1.602176634*10**-19)**0.5 * \
            np.sin((np.float64(k_offset.get())+ophi)/180*np.pi)*10**-10/(h/2/np.pi)
        x = (vfe-fev)*1000
        y = pos
        yy = interp(pos, k*np.float64(bbk_offset.get()), be -
                    # interp x into be,k set
                    np.float64(bb_offset.get()))
        x = (vfe-fev)*1000
        rx = x
        ry = -(x+yy)
        tbe = (vfe-fev)*1000
        x = interp(tbe, -be+np.float64(bb_offset.get()),
                    k*np.float64(bbk_offset.get()))
        y = interp(x, k*np.float64(bbk_offset.get()),
                    -be+np.float64(bb_offset.get()))
        xx = np.diff(x)
        yy = np.diff(y)

        # eliminate vf in gap
        for i in range(len(yy)):
            if yy[i]/xx[i] > 20000:
                yy[i] = 0
        v = yy/xx
        # v = np.append(v, v[-1])  # fermi velocity
        v=interp(pos,x[0:-1]+xx/2,v)
        yy = np.abs(v*fwhm/2)
        xx = tbe

        ix = xx
        iy = yy
        ix=(tbe-tbe[-1])*-1
        cix=np.append(ix+ix[0],ix)
        tix=cix[0:len(cix)-1]*-1
        # kx=ix
        kx = np.append(cix,tix[::-1])
        ky = np.linspace(0, 1, len(kx))
        ciy=np.append(iy*0+np.mean(iy),iy)
        tiy=ciy[0:len(ciy)-1]
        ciy = np.append(ciy,tiy[::-1])

        #for imaginary part
        ix=(tbe-tbe[-1])*-1
        cix=np.append(ix+ix[0],ix)
        tix=cix[0:len(cix)-1]*-1
        kx = np.append(cix,tix[::-1])
        ky = np.linspace(0, 1, len(kx))
        cry=np.append(ry*0,ry)
        tcry=cry[0:len(cry)-1]*-1
        cry = np.append(cry,tcry[::-1])

        # Hilbert transform
        analytic_signal_r = hilbert(cry)
        analytic_signal_i = hilbert(ciy)
        # Reconstructed real and imaginary parts
        reconstructed_real = np.imag(analytic_signal_i)
        reconstructed_imag = -np.imag(analytic_signal_r)
        cmdlist[6]=f'''plot1d(x={pre_process((vfe-fev)*1000)}, y1={pre_process(-1*((vfe-fev)*1000+interp(pos, k*np.float64(bbk_offset.get()), be - np.float64(bb_offset.get()))))}, y2={pre_process(reconstructed_real[len(ix):2*len(ix)]+(ry-np.mean(reconstructed_real[len(ix):2*len(ix)])))}, title='Self Energy Real Part', xlabel='Binding Energy', ylabel=r"Re \g(S)", ylabel1=r"Re \g(S)", ylabel2=r"Re \g(S)\-(KK)=KK(Im \g(S))", xunit='meV', yunit='meV')\n'''
    except:
        no.append(6)
    try:
        ophi = np.arcsin(rpos/(2*m*fev*1.602176634*10**-19)**0.5 /
                        10**-10*(h/2/np.pi))*180/np.pi
        pos = (2*m*fev*1.602176634*10**-19)**0.5 * \
            np.sin((np.float64(k_offset.get())+ophi)/180*np.pi)*10**-10/(h/2/np.pi)
        x = (vfe-fev)*1000
        y = pos
        yy = interp(pos, k*np.float64(bbk_offset.get()), be -
                    # interp x into be,k set
                    np.float64(bb_offset.get()))
        x = (vfe-fev)*1000
        rx = x
        ry = -(x+yy)
        tbe = (vfe-fev)*1000
        x = interp(tbe, -be+np.float64(bb_offset.get()),
                    k*np.float64(bbk_offset.get()))
        y = interp(x, k*np.float64(bbk_offset.get()),
                    -be+np.float64(bb_offset.get()))
        xx = np.diff(x)
        yy = np.diff(y)

        # eliminate vf in gap
        for i in range(len(yy)):
            if yy[i]/xx[i] > 20000:
                yy[i] = 0
        v = yy/xx
        # v = np.append(v, v[-1])  # fermi velocity
        v=interp(pos,x[0:-1]+xx/2,v)
        yy = np.abs(v*fwhm/2)
        xx = tbe

        ix = xx
        iy = yy
        ix=(tbe-tbe[-1])*-1
        cix=np.append(ix+ix[0],ix)
        tix=cix[0:len(cix)-1]*-1
        # kx=ix
        kx = np.append(cix,tix[::-1])
        ky = np.linspace(0, 1, len(kx))
        ciy=np.append(iy*0+np.mean(iy),iy)
        tiy=ciy[0:len(ciy)-1]
        ciy = np.append(ciy,tiy[::-1])

        #for imaginary part
        ix=(tbe-tbe[-1])*-1
        cix=np.append(ix+ix[0],ix)
        tix=cix[0:len(cix)-1]*-1
        kx = np.append(cix,tix[::-1])
        ky = np.linspace(0, 1, len(kx))
        cry=np.append(ry*0,ry)
        tcry=cry[0:len(cry)-1]*-1
        cry = np.append(cry,tcry[::-1])

        # Hilbert transform
        analytic_signal_r = hilbert(cry)
        analytic_signal_i = hilbert(ciy)
        # Reconstructed real and imaginary parts
        reconstructed_real = np.imag(analytic_signal_i)
        reconstructed_imag = -np.imag(analytic_signal_r)
        cmdlist[7]=f'''plot1d(x={pre_process((vfe-fev)*1000)}, y1={pre_process(iy)}, y2={pre_process(reconstructed_imag[len(ix):2*len(ix)]+(iy-np.mean(reconstructed_imag[len(ix):2*len(ix)])))}, title='Self Energy Imaginary Part', xlabel='Binding Energy', ylabel=r"Im \g(S)", ylabel1=r"Im \g(S)", ylabel2=r"Im \g(S)\-(KK)=KK(Re \g(S))", xunit='meV', yunit='meV')\n'''
    except:
        no.append(7)
    try:
        x1 = pos
        if emf=='KE':
            y1=np.float64(fev)
        else:
            y1= vfe-np.float64(fev)
        cmdlist[8]=f'''plot2d(title='Data plot with pos')\n'''
    except:
        no.append(8)
    try:
        x2 = k*float(bbk_offset.get())
        if emf=='KE':
            y2 = (be - float(bb_offset.get()))/1000+vfe
        else:
            y2 = (-be + float(bb_offset.get()))/1000
        cmdlist[9]=f'''plot2d(title='Data plot with pos & bare band')\n'''
    except:
        no.append(9)
    try:
        cmdlist[10]=f'''plot2d(title='Second Derivative (Processed Data)')\n'''
    except:
        no.append(10)
        
def exp_origin(*e):
    origin_temp_var = f'''from {app_name} import *

npzf = {npzf}
dpath = r"{dpath}"      # Data Path
emf = r"{emf}"             # Energy Mode: KE or BE
ko = {k_offset.get()}
bbo = {bb_offset.get()}
bbk = {bbk_offset.get()}
vfe = {vfe}
im_kernel = {im_kernel}     # Gaussian Filter Kernel Size
nan = np.nan
'''
    try:
        origin_temp_var += f'''
bpath = r"{bpath}"         # Bare Band Path
be = np.float64({pre_process(be)})
k = np.float64({pre_process(k)})
'''
    except: pass
    try:
        ophi = np.arcsin(rpos/(2*m*fev*1.602176634*10**-19)**0.5 /
                        10**-10*(h/2/np.pi))*180/np.pi
        pos = (2*m*fev*1.602176634*10**-19)**0.5 * \
            np.sin((np.float64(k_offset.get())+ophi)/180*np.pi)*10**-10/(h/2/np.pi)
        origin_temp_var += f'''
fev = np.float64({pre_process(np.array(fev, dtype=np.float64))})
pos = np.float64({pre_process(np.array(pos), dtype=np.float64)})
fwhm = np.float64({pre_process(np.array(fwhm, dtype=np.float64))})
'''
    except: pass
    try:
        ffphi = np.float64(k_offset.get())+fphi
        fk = (2*m*epos*1.602176634*10**-19)**0.5 * \
            np.sin(ffphi/180*np.pi)*10**-10/(h/2/np.pi)
        origin_temp_var += f'''
fk = np.float64({pre_process(np.array(fk, dtype=np.float64))})
epos = np.float64({pre_process(np.array(epos, dtype=np.float64))})
efwhm = np.float64({pre_process(np.array(efwhm, dtype=np.float64))})
'''
    except: pass
    if '.h5' in os.path.basename(dpath):
        tload = f'''
data = load_h5(dpath)        
'''
    elif '.json' in os.path.basename(dpath):
        tload = f'''
data = load_json(dpath)
'''
    elif '.txt' in os.path.basename(dpath):
        tload = f'''
data = load_txt(dpath)
'''
    elif '.npz' in os.path.basename(dpath):
        tload = f'''
data = load_npz(dpath)
'''
    origin_temp_var += tload
    origin_temp_var += f'''
dvalue = [data.attrs[i] for i in data.attrs.keys()]
dkey = [i for i in data.attrs.keys()]
ev, phi = data.indexes.values()
ev, phi = np.float64(ev), np.float64(phi)

if emf=='KE':
    le_mode='Kinetic Energy'
    tx, ty = np.meshgrid(phi, ev)
    tev = ty.copy()
else:
    le_mode='Binding Energy'
    tx, ty = np.meshgrid(phi, vfe-ev)
    tev = vfe-ty.copy()
tz = data.to_numpy()
sdz = laplacian_filter(data.to_numpy(), im_kernel)
'''
    origin_temp_exec = r'''
op.new()
op.set_show(True)

'''
    origin_temp_save = r'''
note()
save()
'''
    cl=[v1.get(),v2.get(),v3.get(),v4.get(),v5.get(),v6.get(),v7.get(),v8.get(),v9.get(),v10.get(),v11.get()]
    gori.destroy()
    for i in cmdlist.keys():
        if cl[i]==1:
            origin_temp_exec+=cmdlist[i]
        
    with open(cdir+r'\origin_temp.py', 'w', encoding='utf-8') as f:
        f.write(origin_temp_var+origin_temp_func+origin_temp_exec+origin_temp_save)
    f.close()
    def j():
        # os.system(f'code {cdir+r"\origin_temp.py"}')
        limg.config(image=img[np.random.randint(len(img))])
        print('Exporting to Origin...')
        st.put('Exporting to Origin...')
        temp=r"\origin_temp.py"
        os.system(f'python "{cdir+temp}"')
        os.system(f'del "{cdir+temp}"')
        limg.config(image=img[np.random.randint(len(img))])
        print('Exported to Origin')
        st.put('Exported to Origin')
    threading.Thread(target=j,daemon=True).start()

def new():
    global le_mode
    op.new()
    op.set_show(True)
    dvalue = [data.attrs[i] for i in data.attrs.keys()]
    dkey = [i for i in data.attrs.keys()]

    if emf=='KE':
        le_mode='Kinetic Energy'
    else:
        le_mode='Binding Energy'
    ko = k_offset.get()
    bbo = bb_offset.get()
    bbk = bbk_offset.get()
    nt=op.new_notes('Data Info')
    nt.syntax = 0   # Markdown; 0(Normal Text), 1(HTML), 2(Markdown), 3(Origin Rich Text)
    nt.view = 0    # Render Mode; 0(Text Mode), 1(Render Mode)
    nt.append(f'Region')
    nt.append(f'        File Path: {dpath}')
    for i in range(len(dkey)):
        if dkey[i] != 'Description':
            if dkey[i] == 'Path':
                pass
            else:
                nt.append(f'        {dkey[i]}: {dvalue[i]}')
        else:
            for j,k in enumerate(dvalue[i].split('\n')):
                if j == 0:
                    nt.append(f'        {dkey[i]}:')
                    nt.append(f'                {k}')
                else:
                    nt.append(f'                {k}')
    nt.append(f'\nParameters\n'+\
        f'        Energy Mode: {le_mode}\n'+\
        f'        Fermi Energy: {vfe} eV\n'+\
        f'        k offset: {ko} deg\n')
    if bpath != '':
        nt.append(f'        Bare Band Path: {bpath}\n'+\
            f'        Bare Band Offset: {bbo} meV\n'+\
            f'        Bare Band k Ratio: {bbk}\n')
    else:
        nt.append(f'        Bare Band Path: None\n')

def plot2d(x=[1,2,3], y=[1,2,3], z=[1,2,3], title='E-Phi (Raw Data)', xlabel=r"\g(f)", ylabel='Kinetic Energy', zlabel='Intensity', xunit="deg", yunit='eV', zunit='Counts'):
    if xlabel=='k':
        xunit=r"2\g(p)Å\+(-1)"
    # create a new book
    wb = op.new_book('w',title)
    # access the first sheet
    sheet = wb[0]
    # add data to the sheet
    sheet.from_list(0, x, lname=xlabel, units=xunit, axis='X')     #col, data, lname='', units='', comments='', axis='', start=0(row offset)
    sheet.from_list(1, y, lname=ylabel, units=yunit, axis='Y')
    sheet.from_list(2, z, lname=zlabel, units=zunit, axis='Z')
    gr=op.new_graph(title, 'TriContgray')
    gr[0].add_plot(sheet, 1, 0, 2)
    gr[0].rescale()
    wb.show = False

def plot1d(x=[1,2,3], y=[1,2,3], title='title', xlabel='x', ylabel='y', xunit='arb', yunit='arb'):
    # create a new book
    wb = op.new_book('w',title)
    # access the first sheet
    sheet = wb[0]
    # add data to the sheet
    sheet.from_list(0, x, lname=xlabel, units=xunit, axis='X')     #col, data, lname='', units='', comments='', axis='', start=0(row offset)
    sheet.from_list(1, y, lname=ylabel, units=yunit, axis='Y')
    gr=op.new_graph(title, 'scatter')
    gr[0].add_plot(sheet, 1, 0)
    gr[0].rescale()
    wb.show = False

def save():
    """
    Save the Origin data in .opj format.
    Can be saved in .opju format as well.
    """
    tbasename = os.path.basename(dpath)
    if '.h5' in tbasename:
        op.save(dpath.removesuffix('.h5').replace("/","\\")+'.opj')
    elif '.json' in tbasename:
        op.save(dpath.removesuffix('.json').replace("/","\\")+'.opj')
    elif '.txt' in tbasename:
        op.save(dpath.removesuffix('.txt').replace("/","\\")+'.opj')
    elif '.npz' in tbasename:
        op.save(dpath.removesuffix('.npz').replace("/","\\")+'.opj')

origin_temp_func = r'''
def note():
    nt=op.new_notes('Data Info')
    nt.syntax = 0   # Markdown; 0(Normal Text), 1(HTML), 2(Markdown), 3(Origin Rich Text)
    nt.view = 0    # Render Mode; 0(Text Mode), 1(Render Mode)
    nt.append(f'Region')
    nt.append(f'        File Path: {dpath}')
    for i in range(len(dkey)):
        if dkey[i] != 'Description':
            if dkey[i] == 'Path':
                pass
            else:
                nt.append(f'        {dkey[i]}: {dvalue[i]}')
        else:
            for j,k in enumerate(dvalue[i].split('\n')):
                if j == 0:
                    nt.append(f'        {dkey[i]}:')
                    nt.append(f'                {k}')
                else:
                    nt.append(f'                {k}')
    nt.append(f'\nParameters\n'+\
        f'        Energy Mode: {le_mode}\n'+\
        f'        Fermi Energy: {vfe} eV\n'+\
        f'        k offset: {ko} deg\n'+\
        f'        Gaussian Filter Kernel Size: {im_kernel}\n')
    if bpath != '':
        nt.append(f'        Bare Band Path: {bpath}\n'+\
            f'        Bare Band Offset: {bbo} meV\n'+\
            f'        Bare Band k Ratio: {bbk}\n')
    else:
        nt.append(f'        Bare Band Path: None\n')

def plot2d(x=tx, y=ty, z=tz, x1=[], x2=[], y1=[], y2=[], title='E-Phi (Raw Data)', xlabel=r"\g(f)", ylabel=f'{le_mode}', zlabel='Intensity', xunit="deg", yunit='eV', zunit='Counts'):
    if title!='E-Phi (Raw Data)':
        if not npzf:
            x = (2*m*tev*1.602176634*10**-19)**0.5*np.sin((np.float64(ko)+x)/180*np.pi)*10**-10/(h/2/np.pi)
        xlabel='k'
    else:   # title == E-Phi (Raw Data)
        if npzf:
            title = 'E-K (Sliced Data)'
            xlabel='k'
    if 'Second Derivative' in title:
        z=sdz
    if 'Data plot with pos' in title:
        x1 = pos
        if emf=='KE':
            y1=fev
        else:
            y1= vfe-fev
    if title=='Data plot with pos & bare band':
        x2 = k*bbk
        if emf=='KE':
            y2 = (be - np.float64(bbo))/1000+vfe
        else:
            y2 = (-be + np.float64(bbo))/1000
    if xlabel=='k':
        xunit=r"2\g(p)Å\+(-1)"
    x,y,z = x.flatten(), y.flatten(), z.flatten()
    # create a new book
    wb = op.new_book('w',title)
    # access the first sheet
    sheet = wb[0]
    # add data to the sheet
    sheet.from_list(0, x, lname=xlabel, units=xunit, axis='X')     #col, data, lname='', units='', comments='', axis='', start=0(row offset)
    sheet.from_list(1, y, lname=ylabel, units=yunit, axis='Y')
    sheet.from_list(2, z, lname=zlabel, units=zunit, axis='Z')
    gr=op.new_graph(title, 'TriContgray')
    gr[0].add_plot(sheet, 1, 0, 2)
    if ylabel=='Binding Energy':
        ylm=gr[0].ylim
        gr[0].set_ylim(ylm[1],ylm[0])
        gr[0].set_ylim(step=-1*float(ylm[2]))
    if len(x1) != 0:
        sheet.from_list(3, x1, lname='x1', units=xunit, axis='X')
        sheet.from_list(4, y1, lname='y1', units=yunit, axis='Y')
        g1=gr[0].add_plot(sheet, 4, 3,type='s')
        g1.symbol_size = 5
        g1.symbol_kind = 2
    if len(x2) != 0:
        sheet.from_list(5, x2, lname='x2', units=xunit, axis='X')
        sheet.from_list(6, y2, lname='y2', units=yunit, axis='Y')
        g2=gr[0].add_plot(sheet, 6, 5,type='l')
        g2.symbol_size = 5
        g2.symbol_kind = 2
        g2.color = 'red'
    gr[0].rescale()
    wb.show = False

def plot1d(x=[1,2,3], y1=[1,2,3], y2=[], title='title', xlabel='x', ylabel='y', ylabel1='y1', ylabel2='y2', xunit='arb', yunit='arb'):
    # create a new book
    wb = op.new_book('w',title)
    # access the first sheet
    sheet = wb[0]
    # add data to the sheet
    if ylabel1 == 'y1':
        ylabel1 = ylabel
    sheet.from_list(0, x, lname=xlabel, units=xunit, axis='X')     #col, data, lname='', units='', comments='', axis='', start=0(row offset)
    sheet.from_list(1, y1, lname=ylabel1, units=yunit, axis='Y')
    gr=op.new_graph(title, 'scatter')
    g1=gr[0].add_plot(sheet, 1, 0)
    g1.symbol_size = 5
    g1.symbol_kind = 2
    if len(y2) != 0:
        sheet.from_list(2, y2, lname=ylabel2, units=yunit, axis='Y')
        g2=gr[0].add_plot(sheet, 2, 0)
        g2.symbol_size = 5
        g2.symbol_kind = 2
        g2.color = 'red'
        gr[0].label('yl').text = f'{ylabel} ({yunit})'
    if xlabel=='Binding Energy':
        xlm=gr[0].xlim
        gr[0].set_xlim(xlm[1],xlm[0])
        gr[0].set_xlim(step=-1*float(xlm[2]))
    gr[0].rescale()
    wb.show = False

def save(format='opj'):
    """
    Save the Origin data in .opj format.
    Can be saved in .opju format as well.
    """
    tbasename = os.path.basename(dpath)
    if '.h5' in tbasename:
        op.save(dpath.removesuffix('.h5').replace("/","\\")+'.'+format)
    elif '.json' in tbasename:
        op.save(dpath.removesuffix('.json').replace("/","\\")+'.'+format)
    elif '.txt' in tbasename:
        op.save(dpath.removesuffix('.txt').replace("/","\\")+'.'+format)
    elif '.npz' in tbasename:
        op.save(dpath.removesuffix('.npz').replace("/","\\")+'.'+format)
'''

def rplot(f, canvas):
    """
    Plot the raw data on a given canvas.

    Parameters:
    - f: Figure object
        The figure object on which the plot will be created.
    - canvas: Canvas object
        The canvas object on which the plot will be drawn.

    Returns:
    None
    """
    global data, ev, phi, value3, h0, ao, xl, yl, rcx, rcy, acb
    ao = f.add_axes([0.13, 0.1, 0.6, 0.65])
    rcx = f.add_axes([0.13, 0.78, 0.6, 0.15])
    rcy = f.add_axes([0.75, 0.1, 0.12, 0.65])
    acb = f.add_axes([0.9, 0.1, 0.02, 0.65])
    rcx.set_xticks([])
    rcx.set_yticks([])
    rcy.set_xticks([])
    rcy.set_yticks([])
    if emf=='KE':
        tx, ty = np.meshgrid(phi, ev)
    else:
        tx, ty = np.meshgrid(phi, vfe-ev)
    tz = data.to_numpy()
    # h1 = a.scatter(tx,ty,c=tz,marker='o',s=0.9,cmap=value3.get());
    h0 = ao.pcolormesh(tx, ty, tz, cmap=value3.get())
    f.colorbar(h0, cax=acb, orientation='vertical')
    # a.set_title('Raw Data',font='Arial',fontsize=16)
    rcx.set_title('            Raw Data', font='Arial', fontsize=16)
    if npzf:ao.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=12)
    else:ao.set_xlabel('Angle (deg)', font='Arial', fontsize=12)
    if emf=='KE':
        ao.set_ylabel('Kinetic Energy (eV)', font='Arial', fontsize=12)
    else:
        ao.set_ylabel('Binding Energy (eV)', font='Arial', fontsize=12)
        ao.invert_yaxis()
    xl = ao.get_xlim()
    yl = ao.get_ylim()
    np.save('raw_data.npy',tz.T/np.max(tz))
    # a.set_xticklabels(labels=a.get_xticklabels(),font='Arial',fontsize=10);
    # a.set_yticklabels(labels=a.get_yticklabels(),font='Arial',fontsize=10);
    canvas.draw()

def cexcitation_h5(s:str):
    with h5py.File(dpath, 'r+') as hf:
        # Read the dataset
        data = hf['Region']['ExcitationEnergy']['Value'][:]
        print("Original:", data)
        
        # Prepare the new data
        new_data = np.array([float(s)], dtype=float)  # Use vlen=str for variable-length strings
        
        # Delete the old dataset
        del hf['Region']['ExcitationEnergy']['Value']
        
        # Create a new dataset with the same name but with the new data
        hf.create_dataset('Region/ExcitationEnergy/Value', data=new_data, dtype=float)
        
        # Verify changes
        modified_data = hf['Region']['ExcitationEnergy']['Value'][:]
        print("Modified:", modified_data)

def cexcitation_json(s:str):
    with open(dpath, 'r') as f:
        data = json.load(f)
        print("Original:", data['Region']['ExcitationEnergy']['Value'])
    data['Region']['ExcitationEnergy']['Value'] = float(s)
    with open(dpath, 'w') as f:
        json.dump(data, f, indent=2)
        print("Modified:", data['Region']['ExcitationEnergy']['Value'])

def cexcitation_npz(s:str):
    with np.load(dpath, allow_pickle=True) as data:
        data_dict = {key: data[key] for key in data}
    data_dict['e_photon'] = float(s)
    np.savez(dpath, **data_dict)
    print(f"Modified .npz file saved to {dpath}")

def cexcitation_save_str():
    global data
    s=t_cein.get('1.0',tk.END)
    if s:
        s = s.replace('\n\n\n\n\n', '')
        s = s.replace('\n\n\n\n', '')
        s = s.replace('\n\n\n', '')
        s = s.replace('\n\n', '')
        s = s.replace('\n', '')
        tbasename = os.path.basename(dpath)
        if '.h5' in tbasename:
            cexcitation_h5(s)
            data = load_h5(dpath)  # data save as xarray.DataArray format
            pr_load(data)
        elif '.json' in tbasename:
            cexcitation_json(s)
            data = load_json(dpath)
            pr_load(data)
        elif '.npz' in tbasename:
            cexcitation_npz(s)
            data = load_npz(dpath)
            pr_load(data)
    gcestr.destroy()

def cexcitation():
    global gcestr,t_cein
    tk.messagebox.showwarning("Warning","Floats Input Only")
    gcestr=tk.Toplevel(g,bg='white')
    gcestr.title('Excitation Energy')
    fr=tk.Frame(gcestr,bg='white')
    fr.grid(row=0,column=0)
    t_cein = tk.Text(fr, height=1, width=60)
    t_cein.grid(row=0,column=0)
    try:
        t_cein.insert(tk.END, str(e_photon))
    except:
        t_cein.insert(tk.END, '1000.0')
    t_cein.config(font=('Arial', 16))
    fr1 = tk.Frame(gcestr,bg='white')
    fr1.grid(row=1,column=0)
    b1=tk.Button(fr1,text='Confirm',command=cexcitation_save_str, width=15, height=1, font=('Arial', 14, "bold"), bg='white', bd=5)
    b1.grid(row=1,column=0)
    b2=tk.Button(fr1,text='Cancel',command=gcestr.destroy, width=15, height=1, font=('Arial', 14, "bold"), bg='white', bd=5)
    b2.grid(row=1,column=1)
    gcestr.update()

def cname_h5(s:str):
    with h5py.File(dpath, 'r+') as hf:
        # Read the dataset
        data = hf['Region']['Name'][:]
        print("Original:", data)
        
        # Prepare the new data
        new_data = np.array([bytes(s, 'utf-8')], dtype=h5py.special_dtype(vlen=str))  # Use vlen=str for variable-length strings
        
        # Delete the old dataset
        del hf['Region']['Name']
        
        # Create a new dataset with the same name but with the new data
        hf.create_dataset('Region/Name', data=new_data, dtype=h5py.special_dtype(vlen=str))
        
        # Verify changes
        modified_data = hf['Region']['Name'][:]
        print("Modified:", modified_data)

def cname_json(s:str):
    with open(dpath, 'r') as f:
        data = json.load(f)
        print("Original:", data['Region']['Name'])
    data['Region']['Name'] = s
    with open(dpath, 'w') as f:
        json.dump(data, f, indent=2)
        print("Modified:", data['Region']['Name'])

def cname_npz(s:str):
    global dpath
    os.chdir(os.path.dirname(dpath))
    old_name = os.path.basename(dpath)
    new_name = s+'.npz'
    try:
        os.rename(old_name, new_name)
        print(f"File renamed from {old_name} to {new_name}")
        dpath = os.path.normpath(os.path.dirname(dpath)+'/'+s+'.npz')
    except FileNotFoundError:
        print(f"File {old_name} not found.")
    except PermissionError:
        print(f"Permission denied to rename {old_name}.")
    except Exception as e:
        print(f"An error occurred: {e}")

def cname_save_str():
    global data
    s=t_cin.get('1.0',tk.END)
    if s:
        s = s.replace('\n\n\n\n\n', '')
        s = s.replace('\n\n\n\n', '')
        s = s.replace('\n\n\n', '')
        s = s.replace('\n\n', '')
        s = s.replace('\n', '')
        tbasename = os.path.basename(dpath)
        if '.h5' in tbasename:
            cname_h5(s)
            data = load_h5(dpath)  # data save as xarray.DataArray format
            pr_load(data)
        elif '.json' in tbasename:
            cname_json(s)
            data = load_json(dpath)
            pr_load(data)
        elif '.npz' in tbasename:
            cname_npz(s)
            data = load_npz(dpath)
            pr_load(data)
    gcstr.destroy()
    
def cname():
    global gcstr,t_cin
    tk.messagebox.showwarning("Warning","允許中文、符號")
    gcstr=tk.Toplevel(g,bg='white')
    gcstr.title('Name')
    fr=tk.Frame(gcstr,bg='white')
    fr.grid(row=0,column=0)
    t_cin = tk.Text(fr, height=1, width=60, bd=5, padx=10, pady=10)
    t_cin.grid(row=0,column=0)
    t_cin.insert(tk.END, name)
    t_cin.config(font=('Arial', 20))
    t_cin.focus_set()
    fr1 = tk.Frame(gcstr,bg='white')
    fr1.grid(row=1,column=0)
    b1=tk.Button(fr1,text='Confirm',command=cname_save_str, width=15, height=1, font=('Arial', 14, "bold"), bg='white', bd=5)
    b1.grid(row=1,column=0)
    b2=tk.Button(fr1,text='Cancel',command=gcstr.destroy, width=15, height=1, font=('Arial', 14, "bold"), bg='white', bd=5)
    b2.grid(row=1,column=1)
    gcstr.update()

def desc_h5(s:str):
    with h5py.File(dpath, 'r+') as hf:
        # Read the dataset
        data = hf['Region']['Description'][:]
        print("Original:", data)
        
        # Prepare the new data
        # s1 = b'BUF : 1.68E-6 mbar'
        # s2 = b'0.50kV 100mA'
        # new_data = np.array([s1, b'\n', s2], dtype=h5py.special_dtype(vlen=str))  # Use vlen=str for variable-length strings
        
        # s='BUF : 1.68E-6 mbar\n0.50kV 100mA'
        new_data = np.array([bytes(s, 'utf-8')], dtype=h5py.special_dtype(vlen=str))  # Use vlen=str for variable-length strings
        
        # Delete the old dataset
        del hf['Region']['Description']
        
        # Create a new dataset with the same name but with the new data
        hf.create_dataset('Region/Description', data=new_data, dtype=h5py.special_dtype(vlen=str))
        
        # Verify changes
        modified_data = hf['Region']['Description'][:]
        print("Modified:", modified_data)

def desc_json(s:str):
    with open(dpath, 'r') as f:
        data = json.load(f)
        print("Original:", data['Region']['Description'])
    data['Region']['Description'] = s
    with open(dpath, 'w') as f:
        json.dump(data, f, indent=2)
        print("Modified:", data['Region']['Description'])

def desc_npz(s:str):
    with np.load(dpath, allow_pickle=True) as data:
        data_dict = {key: data[key] for key in data}
    data_dict['desc'] = [s]
    np.savez(dpath, **data_dict)
    print(f"Modified .npz file saved to {dpath}")
    
def save_str():
    global data
    s=t_in.get('1.0',tk.END)
    if s:
        s = s.replace('\n\n\n\n\n', '\n')
        s = s.replace('\n\n\n\n', '\n')
        s = s.replace('\n\n\n', '\n')
        s = s.replace('\n\n', '\n')
        tbasename = os.path.basename(dpath)
        if '.h5' in tbasename:
            desc_h5(s)
            data = load_h5(dpath)  # data save as xarray.DataArray format
            pr_load(data)
        elif '.json' in tbasename:
            desc_json(s)
            data = load_json(dpath)
            pr_load(data)
        elif '.npz' in tbasename:
            desc_npz(s)
            data = load_npz(dpath)
            pr_load(data)
    gstr.destroy()
    
def desc():
    global gstr,t_in
    tk.messagebox.showwarning("Warning","允許中文、符號")
    gstr=tk.Toplevel(g,bg='white')
    gstr.title('Description')
    fr=tk.Frame(gstr,bg='white')
    fr.grid(row=0,column=0)
    t_in = tk.Text(fr, height=10, width=50, bd=5, padx=10, pady=10)
    t_in.grid(row=0,column=0)
    t_in.insert(tk.END, description)
    t_in.config(font=('Arial', 16))
    t_in.focus_set()
    fr1 = tk.Frame(gstr,bg='white')
    fr1.grid(row=1,column=0)
    b1=tk.Button(fr1,text='Confirm',command=save_str, width=15, height=1, font=('Arial', 14, "bold"), bg='white', bd=5)
    b1.grid(row=1,column=0)
    b2=tk.Button(fr1,text='Cancel',command=gstr.destroy, width=15, height=1, font=('Arial', 14, "bold"), bg='white', bd=5)
    b2.grid(row=1,column=1)
    gstr.update()

def poly_smooth(x, y, order=6,xx=None):
    """
    x : 1D array

    y : 1D array
    
    order : int, default: 6
    
    xx : 1D array, interpolation points, default: None
    """
    coeffs = np.polyfit(x, y, order)
    if xx is None:
        y = np.polyval(coeffs, x)
    else:
        y = np.polyval(coeffs, xx)
    return y

def smooth(x,l=20,p=3):
    """
    Using Savitzky-Golay filter to smooth the data.
    
    Parameters
    ------
    x : 1D array
        data to be smoothed
    l : int, default: 20
        window length
    p : int, default: 3
        polynomial order
    """
    x=savgol_filter(x, l, p)
    # for i in range(len(x)):
    #     if i>=l//2 and i+1<len(x)-l//2:
    #         x[i]=np.mean(x[i-l//2:i+l//2])
    return x

def show_info():
    # 創建自定義窗口
    info_window = tk.Toplevel()
    info_window.title("Information")
    info_window.geometry(f"600x150+{screen_width//2-300}+{screen_height//2-75}")
    
    # 添加信息標籤
    l = tk.Label(info_window, text="Graph copied to clipboard", font=("Arial", 30, "bold"),fg='red')
    l.pack(pady=5)
    label = tk.Label(info_window, text="window closed in 3 second", font=("Arial", 20))
    label.pack(pady=5)
    
    # 設置計時器，3 秒後自動關閉窗口
    info_window.update()
    info_window.after(1000, label.config(text="window closed in 2 second"))
    info_window.update()
    info_window.after(1000, label.config(text="window closed in 1 second"))
    info_window.update()
    info_window.after(1000, label.config(text="window closed in 0 second"))
    info_window.update()
    info_window.destroy()
    
def f_copy_to_clipboard():
    copy_to_clipboard(ff=fig)
    if value.get() != '---Plot1---' or value1.get() != '---Plot2---' or value2.get() != '---Plot3---':
        st.put('Copied to clipboard')
        
def copy_to_clipboard(ff) -> None:
    """
    Copies the given figure to the clipboard as a bitmap image.
    
    Parameters:
    -----------
    ff (matplotlib.figure.Figure): The figure to be copied to the clipboard.
    
    Returns:
    -----------
    None
    """
    try:
        limg.config(image=img[np.random.randint(len(img))])
    except:
        pass
    buf = io.BytesIO()
    ff.savefig(buf, format='png')
    buf.seek(0)
    image = Image.open(buf)
    output = io.BytesIO()
    
    image.convert("RGB").save(output, "BMP")
    data = output.getvalue()[14:]
    output.close()
    send_to_clipboard(win32clipboard.CF_DIB, data)
    
def send_to_clipboard(clip_type, data):
    win32clipboard.OpenClipboard()
    win32clipboard.EmptyClipboard()
    win32clipboard.SetClipboardData(clip_type, data)
    win32clipboard.CloseClipboard()

class spectrogram:
    """A class to plot the spectrogram data in a new Tkinter Toplevel window.
    This class creates a new Tkinter Toplevel window and populates it with
    various widgets to display the spectrogram data and related information.
    It includes two matplotlib figures for plotting, text widgets for displaying
    file paths and additional information, labels for displaying energy, cursor,
    and data values, and buttons for exporting data and copying images to the clipboard.
    
    Attributes:
    ------------
        g (Tk): The Tkinter root window.
        data (xarray.DataArray): The spectrogram data.
        cmap (str): The colormap for plotting.
        tp_cf (bool): The flag to check if the top window is closed.
        dvalue (list): The list of data attributes.
        tst (str): The string of data attributes.
        lst (list): The list of lengths of the data attributes.
        x (array-like): The x-axis data.
        y (array-like): The y-axis data.
        s_exp (str): The name of the exported data file.
        s_exp_casa (str): The name of the exported data file for CASA.
        s_yl (str): The y-axis label for the exported data file.
        type (str): The type of data.
    """
    def __init__(self, data=[], path=[]) -> None:   # should input path in main function
        self.lfs = None
        self.npzf = False
        if len(path) > 0:
            self.lfs = loadfiles(path)
            self.data = self.lfs.data[0]
            if self.lfs.f_npz[0]:self.npzf = True
        else:
            self.data = data
        self.__preload(self.data)
        self.rr1 = self.phi[0]
        self.rr2 = self.phi[-1]
            
    def __preload(self, data=[]) -> None:
        """Initialize the spectrogram class.
        
        Args
        -----------
        g : object
            A graphical user interface object.
        data : xr.DataArray
            The spectrogram data.
        cmap : str
            The colormap used for plotting.
        
        Returns
        -----------
        None
        """
        self.data = data
        self.tp_cf = True
        dvalue = [self.data.attrs[i] for i in self.data.attrs.keys()]
        self.dvalue = dvalue
        st=''
        lst=[]
        for _ in self.data.attrs.keys():
            if _ == 'Description':
                ts=str(self.data.attrs[_])
                ts=ts.replace('\n\n\n','\n')
                ts=ts.replace('\n\n','\n')
                t=ts.split('\n')
                st+=str(_)+' : '+str(self.data.attrs[_]).replace('\n','\n                     ')
                # st+=str(_)+' : '+str(self.data.attrs[_]).replace('\n','\n                         ')
                lst.append(len(' : '+t[0]))
                for i in range(1,len(t)):
                    lst.append(len('              '+t[i]))
            elif _ == 'Path':
                pass
            else:
                st+=str(_)+' : '+str(self.data.attrs[_])+'\n'
                lst.append(len(str(_)+' : '+str(self.data.attrs[_])))
        tst=st
        ev, phi = self.data.indexes.values()
        self.ev = np.float64(ev)
        self.phi = np.float64(phi)
        self.name = dvalue[0]
        self.e_photon = np.float64(dvalue[3].split(' ')[0])
        self.lensmode = dvalue[8]
        self.e_mode = dvalue[2]
        self.rdd = dvalue[14]
        self.desc = dvalue[13]
        self.desc=self.desc.replace('\n\n\n\n\n','\n')
        self.desc=self.desc.replace('\n\n\n\n','\n')
        self.desc=self.desc.replace('\n\n\n','\n')
        self.desc=self.desc.replace('\n\n','\n')
        self.desc=self.desc.replace('\n','; ')
        self.tst = tst
        self.lst = lst
        self.x = ev
        self.y = np.sum(self.data.to_numpy().transpose(),axis=0)
        if os.path.basename(self.rdd).split('.')[-1] != 'txt':
            self.s_exp=self.name+'.txt'
        else:
            self.s_exp=self.name+'_txt.txt'
        self.s_exp_casa=self.name+'_Casa.vms'
        self.s_yl='Intensity (Counts)'
        self.type='raw'
        self.fr1 = False
        self.fr2 = False
        self.fr3 = False
        self.fx1 = False
        self.fx2 = False
        self.fx3 = False
    
    def __change_file(self, *args):
        name = self.namevar.get()
        for i, j, k in zip(self.lfs.name, self.lfs.data, self.lfs.f_npz):
            if name == i:
                self.data = j
                if k:self.npzf = True
                else:self.npzf = False
        self.__preload(self.data)
        self.l_path.config(width=max(self.lst)+2, state='normal')
        self.l_path.delete(1.0, tk.END)
        self.l_path.insert(tk.END,self.rdd)
        self.l_path.see(1.0)
        self.l_path.config(state='disabled')
        self.info.config(height=len(self.tst.split('\n')), width=max(self.lst)+2, state='normal')
        self.info.delete(1.0, tk.END)
        self.info.insert(tk.END, self.tst)
        self.info.see(1.0)
        self.info.config(state='disabled')
        try:self.s3.remove()
        except: pass
        self.__tp_a1_plot()
        self.__tp_a2_plot(self.oxl[0],self.oxl[1])
        self.__tp_rga_plot()
        self.rpo.draw()
        self.tpo.draw()
        self.rgo.draw()
    
    def __sel_y(self):
        phi_max = max([self.rr1, self.rr2])
        phi_min = min([self.rr1, self.rr2])
        i = (self.phi<=phi_max) & (self.phi>=phi_min)
        x = self.x
        if self.type=='raw':
            y = np.sum(self.data.to_numpy()[:,i], 1)
        elif self.type=='smooth':
            y=smooth(np.sum(self.data.to_numpy()[:,i].transpose(),axis=0),l=13)
        elif self.type=='fd':
            y=smooth(np.sum(self.data.to_numpy()[:,i].transpose(),axis=0),l=13)
            y=np.diff(y)/np.diff(self.ev)
        else:
            y = self.y
        return x, y
    
    def near(self, data, value):
        if len(data) == 1:
            return data[0]
        else:
            if max(data) >= value >= min(data):
                return data[np.argwhere(abs(data-value)<=abs(data[1]-data[0])/2)[0][0]]
            elif value < min(data):
                return min(data)
            elif value > max(data):
                return max(data)
                
    def update_plot(self, *args):
        self.plot_spectrum(self.selected_fit.get())
        self.update_input_fields(self.selected_fit.get())
    
    def create_input_row(self, label_text, variable, row, frame, col_start=0):
        label = tk.Label(frame, text=label_text, font=('Arial', 18, 'bold'))
        label.grid(row=row, column=col_start, sticky='e')
        entry = tk.Entry(frame, textvariable=variable, font=('Arial', 18, 'bold'))
        entry.grid(row=row, column=col_start + 1, sticky='w')
        return label, entry
    
    def update_input_fields(self, fit_type):
        # 隱藏所有輸入框
        try:
            for widget in self.inputs_frame.winfo_children():
                widget.grid_remove()
        except:
            pass
        
        # 根據選擇的擬合方式顯示相應的輸入框
        if fit_type == "Fermi-Dirac Fitting":
            self.emin_label.grid()
            self.emax_label.grid()
            self.emin_entry.grid()
            self.emax_entry.grid()
        elif fit_type == "Linear Fits":
            self.fL_min_label.grid()
            self.fL_max_label.grid()
            self.fF_min_label.grid()
            self.fF_max_label.grid()
            self.fR_min_label.grid()
            self.fR_max_label.grid()
            self.fL_min_entry.grid()
            self.fL_max_entry.grid()
            self.fF_min_entry.grid()
            self.fF_max_entry.grid()
            self.fR_min_entry.grid()
            self.fR_max_entry.grid()
        elif fit_type == "ERFC Fit":
            self.eminc_label.grid()
            self.emaxc_label.grid()
            self.eminc_entry.grid()
            self.emaxc_entry.grid()
    
    def fit_press(self, event):
        if event.button == 1 and event.inaxes:
            self.fx1 = False
            self.fx2 = False
            self.fx3 = False
            self.fox = event.xdata
            if self.selected_fit.get() == "ERFC Fit":
                self.omin = self.eminc_val.get()
                self.omax = self.emaxc_val.get()
                if abs(self.eminc_val.get()-event.xdata) < abs(self.tr_a1.get_xlim()[1]-self.tr_a1.get_xlim()[0])*1/100:
                    self.fx1 = True
                    self.eminc_val.set(event.xdata)
                elif abs(self.emaxc_val.get()-event.xdata) < abs(self.tr_a1.get_xlim()[1]-self.tr_a1.get_xlim()[0])*1/100:
                    self.fx2 = True
                    self.emaxc_val.set(event.xdata)
                elif self.eminc_val.get() < event.xdata < self.emaxc_val.get():
                    self.fx3 = True
            elif self.selected_fit.get() == "Fermi-Dirac Fitting":
                self.omin = self.emin_val.get()
                self.omax = self.emax_val.get()
                if abs(self.emin_val.get()-event.xdata) < abs(self.tr_a1.get_xlim()[1]-self.tr_a1.get_xlim()[0])*1/100:
                    self.fx1 = True
                    self.emin_val.set(event.xdata)
                elif abs(self.emax_val.get()-event.xdata) < abs(self.tr_a1.get_xlim()[1]-self.tr_a1.get_xlim()[0])*1/100:
                    self.fx2 = True
                    self.emax_val.set(event.xdata)
                elif self.emin_val.get() < event.xdata < self.emax_val.get():
                    self.fx3 = True
            self.update_fit()
                
    def fit_move(self, event):
        if self.fx1 or self.fx2 or self.fx3:
            if self.selected_fit.get() == "ERFC Fit":
                if self.fx1:
                    self.eminc_val.set(event.xdata)
                elif self.fx2:
                    self.emaxc_val.set(event.xdata)
                elif self.fx3:
                    self.eminc_val.set(self.omin+(event.xdata-self.fox))
                    self.emaxc_val.set(self.omax+(event.xdata-self.fox))
            elif self.selected_fit.get() == "Fermi-Dirac Fitting":
                if self.fx1:
                    self.emin_val.set(event.xdata)
                elif self.fx2:
                    self.emax_val.set(event.xdata)
                elif self.fx3:
                    self.emin_val.set(self.omin+(event.xdata-self.fox))
                    self.emax_val.set(self.omax+(event.xdata-self.fox))
            self.update_fit()
        
            
    def fit_release(self, event):
        self.fx1, self.fx2, self.fx3 = False, False, False
        self.update_fit()
    
    def update_fit(self, *args):
        e = self.ev
        x, ss = self.__sel_y()
        fit_type = self.selected_fit.get()
        if fit_type == "Fermi-Dirac Fitting":
            try:
                self.fl1.remove()
                self.fl2.remove()
                self.fl3.remove()
                self.flg.remove()
            except:
                pass
            emin = self.emin_val.get()
            emax = self.emax_val.get()
            self.fl1 = self.a1.axvline(emin, color='r', linestyle='--')
            self.fl2 = self.a1.axvline(emax, color='r', linestyle='--')
            mask = (e > emin) & (e < emax)
            
            x = e[mask]
            y = ss[mask]
            
            def fermi_dirac(E, EF, T, A, B):
                k_B = 8.617333262145e-5  # Boltzmann constant in eV/K
                return A / (np.exp((E - EF) / (k_B * T)) + 1) + B
            
            try:
                initial_guess = [self.e_photon, 300.0, np.max(y), np.min(y)]
                popt, pcov = curve_fit(fermi_dirac, x, y, p0=initial_guess)
                k_B = 8.617333262145e-5
                EF = popt[0]
                T = popt[1]
                self.fl3, = self.a1.plot(x, fermi_dirac(x, *popt), 'r-', label=f'Fermi-Dirac Fit: EF = {EF:.2f} eV, T = {T:.2f} K, $k_bT={k_B*T:.2f}$')
                self.flg = self.a1.legend()
            except:
                EF = None
                T = None
                pass
        
        elif fit_type == "ERFC Fit":
            try:
                self.fl1.remove()
                self.fl2.remove()
                self.fl3.remove()
                self.flg.remove()
            except:
                pass
            eminc = self.eminc_val.get()
            emaxc = self.emaxc_val.get()
            self.fl1 = self.a2.axvline(eminc, color='r', linestyle='--')
            self.fl2 = self.a2.axvline(emaxc, color='r', linestyle='--')
            mask = (e > eminc) & (e < emaxc)
            
            x = e[mask]
            y = ss[mask]
            
            def erfc_fit(E, E0, sigma, A, B):
                return A * special.erfc((E - E0) / sigma) + B
            try:
                initial_guess = [self.e_photon, 0.1, np.max(y), np.min(y)]
                popt, pcov = curve_fit(erfc_fit, x, y, p0=initial_guess)
                
                EF = popt[0]
                E0 = popt[0]
                sigma = popt[1]
                
                self.fl3, = self.a2.plot(x, erfc_fit(x, *popt), 'r-', label=f'ERFC Fit: E0 = {E0:.2f} eV, sigma = {sigma:.2f}')
                self.flg = self.a2.legend()
            except:
                EF = None
                E0 = None
                sigma = None
                pass
        try:
            if EF is not None:
                self.ef_label.config(text=f"Fermi Level (EF): {EF:.2f} eV")
            else:
                self.ef_label.config(text="Fermi Level (EF): N/A")
        except:
            pass
        self.canvas.draw()
    
    
    def plot_spectrum(self, fit_type):
        e = self.ev
        x, ss = self.__sel_y()
        # Smooth the data using Gaussian smoothing
        smoothed_ss = gaussian_filter1d(ss, sigma=2)

        # 清空先前的畫布
        try:
            for widget in self.frame.winfo_children():
                widget.destroy()
        except:
            pass
        
        def plot_base_spectrum(ax, x, y, title, xlabel, ylabel):
            ax.scatter(x, y, s=1, c='k', alpha=0.8)
            ax.set_title(title, fontsize=20)
            ax.set_xlabel(xlabel, fontsize=18)
            ax.set_ylabel(ylabel, fontsize=18)
            ax.set_xlim(self.tr_a2.get_xlim())

        def add_canvas(fig):
            try:
                self.canvas = FigureCanvasTkAgg(fig, master=self.frame)
                self.canvas.draw()
                self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
                if fit_type in ["Fermi-Dirac Fitting", "ERFC Fit"]:
                    self.canvas.mpl_connect('button_press_event', self.fit_press)
                    self.canvas.mpl_connect('motion_notify_event', self.fit_move)
                    self.canvas.mpl_connect('button_release_event', self.fit_release)
                self.toolbar = NavigationToolbar2Tk(self.canvas, self.frame)
                self.toolbar.update()
                self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
            except:
                pass

        EF = None

        if fit_type == "Raw Data":
            fig = Figure(dpi=100, figsize=(12, 6))
            ax = fig.add_subplot(111)
            plot_base_spectrum(ax, e, ss, 'Raw Data', 'Kinetic Energy (eV)', 'Intensity (counts)')
            add_canvas(fig)
        
        elif fit_type == "Smooth Data":
            fig = Figure(dpi=100, figsize=(12, 6))
            ax = fig.add_subplot(111)
            plot_base_spectrum(ax, e, smoothed_ss, 'Smooth Data', 'Kinetic Energy (eV)', 'Intensity (counts)')
            add_canvas(fig)

        elif fit_type == "Fermi-Dirac Fitting":
            fig1 = Figure(dpi=100, figsize=(12, 6))
            self.a1 = fig1.add_subplot(111)
            plot_base_spectrum(self.a1, e, ss, 'Raw Data with Fermi-Dirac Fitting', 'Kinetic Energy (eV)', 'Intensity (counts)')

            emin = self.emin_val.get()
            emax = self.emax_val.get()
            self.fl1 = self.a1.axvline(emin, color='r', linestyle='--')
            self.fl2 = self.a1.axvline(emax, color='r', linestyle='--')
            mask = (e > emin) & (e < emax)
            
            x = e[mask]
            y = ss[mask]
            
            def fermi_dirac(E, EF, T, A, B):
                k_B = 8.617333262145e-5  # Boltzmann constant in eV/K
                return A / (np.exp((E - EF) / (k_B * T)) + 1) + B
            
            try:
                initial_guess = [self.e_photon, 300.0, np.max(y), np.min(y)]
                popt, pcov = curve_fit(fermi_dirac, x, y, p0=initial_guess)
                k_B = 8.617333262145e-5
                EF = popt[0]
                T = popt[1]
                self.fl3, = self.a1.plot(x, fermi_dirac(x, *popt), 'r-', label=f'Fermi-Dirac Fit: EF = {EF:.2f} eV, T = {T:.2f} K, $k_bT={k_B*T:.2f}$')
                self.flg = self.a1.legend()
            except:
                EF = None
                T = None
                pass
            add_canvas(fig1)
        
        elif fit_type == "ERFC Fit":
            fig2 = Figure(dpi=100, figsize=(12, 6))
            self.a2 = fig2.add_subplot(111)
            plot_base_spectrum(self.a2, e, ss, 'Raw Data with ERFC Fit', 'Kinetic Energy (eV)', 'Intensity (counts)')
            
            eminc = self.eminc_val.get()
            emaxc = self.emaxc_val.get()
            self.fl1 = self.a2.axvline(eminc, color='r', linestyle='--')
            self.fl2 = self.a2.axvline(emaxc, color='r', linestyle='--')
            mask = (e > eminc) & (e < emaxc)
            
            x = e[mask]
            y = ss[mask]
            
            def erfc_fit(E, E0, sigma, A, B):
                return A * special.erfc((E - E0) / sigma) + B
            try:
                initial_guess = [self.e_photon, 0.1, np.max(y), np.min(y)]
                popt, pcov = curve_fit(erfc_fit, x, y, p0=initial_guess)
                
                EF = popt[0]
                E0 = popt[0]
                sigma = popt[1]
                
                self.fl3, = self.a2.plot(x, erfc_fit(x, *popt), 'r-', label=f'ERFC Fit: E0 = {E0:.2f} eV, sigma = {sigma:.2f}')
                self.flg = self.a2.legend()
            except:
                EF = None
                E0 = None
                sigma = None
                pass
            add_canvas(fig2)

        elif fit_type == "Linear Fits":
            fig3 = Figure(dpi=100, figsize=(12, 6))
            a3 = fig3.add_subplot(111)
            plot_base_spectrum(a3, e, ss, 'Raw Data with Linear Fits', 'Kinetic Energy (eV)', 'Intensity (counts)')

            fL_min = self.fL_min_val.get()
            fL_max = self.fL_max_val.get()
            fF_min = self.fF_min_val.get()
            fF_max = self.fF_max_val.get()
            fR_min = self.fR_min_val.get()
            fR_max = self.fR_max_val.get()

            mask_L = (e > fL_min) & (e < fL_max)
            mask_F = (e > fF_min) & (e < fF_max)
            mask_R = (e > fR_min) & (e < fR_max)

            xL, yL = e[mask_L], ss[mask_L]
            xF, yF = e[mask_F], ss[mask_F]
            xR, yR = e[mask_R], ss[mask_R]

            # 进行线性拟合
            def linear_fit(x, a, b):
                return a * x + b
            try:
                popt_L, _ = curve_fit(linear_fit, xL, yL)
                popt_F, _ = curve_fit(linear_fit, xF, yF)
                popt_R, _ = curve_fit(linear_fit, xR, yR)

                a3.plot(xL, linear_fit(xL, *popt_L), 'r-', label='Left Fit')
                a3.plot(xF, linear_fit(xF, *popt_F), 'g-', label='Flat Fit')
                a3.plot(xR, linear_fit(xR, *popt_R), 'b-', label='Right Fit')

                a3.legend()
            except:
                pass
            add_canvas(fig3)

        elif fit_type == "First Derivative":
            fig4 = Figure(dpi=100, figsize=(12, 6))
            a4 = fig4.add_subplot(111)
            plot_base_spectrum(a4, e, np.gradient(ss), 'First Derivative', 'Kinetic Energy (eV)', 'dIntensity / dE')
            add_canvas(fig4)

        elif fit_type == "Second Derivative":
            fig5 = Figure(dpi=100, figsize=(12, 6))
            a5 = fig5.add_subplot(111)
            plot_base_spectrum(a5, e, np.gradient(np.gradient(ss)), 'Second Derivative', 'Kinetic Energy (eV)', 'd²Intensity / dE²')
            add_canvas(fig5)
            
        elif fit_type == "Smooth Data with First Derivative":
            fig6 = Figure(dpi=100, figsize=(12, 6))
            a6 = fig6.add_subplot(111)
            plot_base_spectrum(a6, e, np.gradient(smoothed_ss), 'Smoothed Data with First Derivative', 'Kinetic Energy (eV)', 'd(Smoothed Intensity) / dE')
            add_canvas(fig6)
            
        elif fit_type == "Segmented Tangents":
            fig7 = Figure(dpi=100, figsize=(12, 6))
            a7 = fig7.add_subplot(111)
            plot_base_spectrum(a7, e, smoothed_ss, 'Smooth Data with Segmented Tangents', 'Kinetic Energy (eV)', 'Intensity (counts)')

            diff = np.gradient(smoothed_ss, e)
            for i in range(len(e) - 1):
                x_segment = [e[i], e[i+1]]
                y_segment = [smoothed_ss[i], smoothed_ss[i] + diff[i] * (e[i+1] - e[i])]
                a7.plot(x_segment, y_segment, 'r-')

            add_canvas(fig7)
        try:
            if EF is not None:
                self.ef_label.config(text=f"Fermi Level (EF): {EF:.2f} eV")
            else:
                self.ef_label.config(text="Fermi Level (EF): N/A")
        except:
            pass
        
    def __ups(self):
        self.root = tk.Toplevel(g,bg='white')
        self.root.title('UPS spectrum')
        self.root.geometry('1920x1080')
        
        # OptionMenu 設定
        fit_options = ["Raw Data", "Smooth Data", "Fermi-Dirac Fitting", "Linear Fits", "ERFC Fit", "First Derivative", "Second Derivative", "Smooth Data with First Derivative", "Segmented Tangents"]
        self.selected_fit = tk.StringVar(self.root)
        self.selected_fit.set(fit_options[4])  # 初始選項

        option_menu = tk.OptionMenu(self.root, self.selected_fit, *fit_options, command=self.update_plot)
        option_menu.config(font=('Arial', 18, 'bold'))
        option_menu.grid(row=0, column=0)

        # emax 和 emin 的初始值
        self.emin_val = tk.DoubleVar(value=self.e_photon-0.2)
        self.emax_val = tk.DoubleVar(value=self.e_photon+0.3)

        # emaxc 和 eminc 的初始值
        self.eminc_val = tk.DoubleVar(value=self.e_photon-0.2)
        self.emaxc_val = tk.DoubleVar(value=self.e_photon+0.3)

        # Linear Fits 的上下界初始值
        self.fL_min_val = tk.DoubleVar(value=self.e_photon-0.4)
        self.fL_max_val = tk.DoubleVar(value=self.e_photon-0.35)
        self.fF_min_val = tk.DoubleVar(value=self.e_photon-0.2)
        self.fF_max_val = tk.DoubleVar(value=self.e_photon-0.02)
        self.fR_min_val = tk.DoubleVar(value=self.e_photon)
        self.fR_max_val = tk.DoubleVar(value=self.e_photon+0.8)

        # 創建輸入框
        self.inputs_frame = tk.Frame(self.root)
        self.inputs_frame.grid(row=1, column=0, columnspan=5, sticky='w')

        # 創建輸入框，並預設隱藏
        self.emin_label, self.emin_entry = self.create_input_row("emin:", self.emin_val, 0, self.inputs_frame)
        self.emax_label, self.emax_entry = self.create_input_row("emax:", self.emax_val, 0, self.inputs_frame, col_start=2)

        self.eminc_label, self.eminc_entry = self.create_input_row("eminc:", self.eminc_val, 1, self.inputs_frame)
        self.emaxc_label, self.emaxc_entry = self.create_input_row("emaxc:", self.emaxc_val, 1, self.inputs_frame, col_start=2)

        self.fL_min_label, self.fL_min_entry = self.create_input_row("fL min:", self.fL_min_val, 2, self.inputs_frame)
        self.fL_max_label, self.fL_max_entry = self.create_input_row("fL max:", self.fL_max_val, 2, self.inputs_frame, col_start=2)

        self.fF_min_label, self.fF_min_entry = self.create_input_row("fF min:", self.fF_min_val, 3, self.inputs_frame)
        self.fF_max_label, self.fF_max_entry = self.create_input_row("fF max:", self.fF_max_val, 3, self.inputs_frame, col_start=2)

        self.fR_min_label, self.fR_min_entry = self.create_input_row("fR min:", self.fR_min_val, 4, self.inputs_frame)
        self.fR_max_label, self.fR_max_entry = self.create_input_row("fR max:", self.fR_max_val, 4, self.inputs_frame, col_start=2)

        # 添加顯示EF值的區塊
        self.ef_label = tk.Label(self.root, text="Fermi Level (EF): N/A", font=('Arial', 18, 'bold'))
        self.ef_label.grid(row=2, column=4, rowspan=2, padx=20)

        # 創建可滾動畫布
        self.canvas_frame = tk.Frame(self.root)
        self.canvas_frame.grid(row=8, column=0, columnspan=5, sticky='nsew')

        self.canvas = tk.Canvas(self.canvas_frame)
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        self.frame = tk.Frame(self.canvas)
        self.canvas.create_window((0, 0), window=self.frame, anchor='nw')

        # 讓主窗口和 canvas_frame 自動擴展
        self.root.grid_rowconfigure(8, weight=1)
        self.root.grid_columnconfigure(0, weight=1)
        self.canvas_frame.grid_rowconfigure(0, weight=1)
        self.canvas_frame.grid_columnconfigure(0, weight=1)

        self.update_input_fields(self.selected_fit.get())  # 初始化輸入框顯示
        self.update_plot()
        self.root.bind("<Return>", self.update_plot)
        self.root.update()
    
    def _select_all(self, event):
        event.widget.tag_add(tk.SEL, "1.0", tk.END)
        event.widget.mark_set(tk.INSERT, "1.0")
        event.widget.see(tk.INSERT)
        return 'break'
    
    def __copy_to_clipboard(self):
        buf1 = io.BytesIO()
        buf2 = io.BytesIO()
        self.rpf.savefig(buf1, format='png')
        self.tpf.savefig(buf2, format='png')
        buf1.seek(0)
        buf2.seek(0)
        image1 = Image.open(buf1)
        Image2 = Image.open(buf2)
        image = Image.new('RGB', (image1.width, image1.height + Image2.height))
        image.paste(image1, (0, 0))
        image.paste(Image2, (0, image1.height))
        output = io.BytesIO()
        
        image.convert("RGB").save(output, "BMP")
        data = output.getvalue()[14:]
        output.close()
        send_to_clipboard(win32clipboard.CF_DIB, data)
        
        # image.save(output, format='PNG')
        # data = output.getvalue()[14:]
        # output.close()

        # self.g.clipboard_clear()
        # self.g.clipboard_append(data)
        # self.g.update()  # now it stays on the clipboard after the window is closed
    
    def setdata(self, x, y, dtype='raw', unit='Counts'):
        """Set the data for plotting.
        
        Args:
        -----------
            x (list or array-like): The x-axis data.
            y (list or array-like): The y-axis data.
            dtype (str, optional): The type of data. Defaults to 'raw'.
            unit (str, optional): The unit of the y-axis data. Defaults to 'Counts'.
            
        Raises:
        -----------
            ValueError: If the length of x and y are not the same.
        """
        self.x=x
        self.y=y
        self.type=dtype
        if len(x)!=len(y):
            print('len(x):',len(x),'len(y):',len(y))
            raise ValueError('The length of x and y must be the same.')
        if dtype=='raw':
            self.s_yl='Intensity (Counts)'
            if os.path.basename(self.rdd).split('.')[-1]!='txt':
                self.s_exp=self.name+'.txt'
            else:
                self.s_exp=self.name+'_txt'+'.txt'
            self.s_exp_casa=self.name+'_Casa.vms'
        else:
            self.s_yl='Intensity ('+unit+')'
            if os.path.basename(self.rdd).split('.')[-1]!='txt':
                self.s_exp=self.name+'.txt'
            else:
                self.s_exp=self.name+'_txt'+'.txt'
            self.s_exp_casa=self.name+'_'+dtype+'_Casa.vms'
    
    def __scroll(self, event):
        if event.delta>0:
            self.__cf_up()
        elif event.delta<0:
            self.__cf_down()
    
    def __cf_up(self, *args):
        now = self.namevar.get()
        for i, j in enumerate(self.lfs.name):
            if now == j:
                if i == 0:
                    self.namevar.set(self.lfs.name[-1])
                else:
                    self.namevar.set(self.lfs.name[i-1])
        self.__change_file()

    def __cf_down(self, *args):
        now = self.namevar.get()
        for i, j in enumerate(self.lfs.name):
            if now == j:
                if i == len(self.lfs.name)-1:
                    self.namevar.set(self.lfs.name[0])
                else:
                    self.namevar.set(self.lfs.name[i+1])
        self.__change_file()
    
    
    def plot(self, g, cmap='viridis'):
        """Plot the spectrogram data in a new Tkinter Toplevel window.
        This method creates a new Tkinter Toplevel window and populates it with
        various widgets to display the spectrogram data and related information.
        It includes two matplotlib figures for plotting, text widgets for displaying
        file paths and additional information, labels for displaying energy, cursor,
        and data values, and buttons for exporting data and copying images to the clipboard.
        
        Widgets:
        --------
            - Toplevel window with title 'Spectrogram: <name>'
            - Fitting utility button for Fermi level fitting
            - Two matplotlib figures for plotting spectrogram data
            - Text widget for displaying the file path
            - Text widget for displaying additional information
            - Labels for displaying energy, cursor, and data values
            - Buttons for exporting raw data and copying images to the clipboard
            
        Event Bindings:
        --------
            - Motion notify event for matplotlib figures
            - Button press event for matplotlib figures
            - Button release event for matplotlib figures
            - FocusIn event for the additional information text widget
            
        Methods Called:
        --------
            - __ups
            - __export
            - __export_casa
            - __copy_to_clipboard
            - __trans_plot_job
            
        Note:
        --------
            The method uses the Tkinter library for GUI components and matplotlib for plotting.
        
        """
        # global tpf,tpo,rpf,rpo,l_cx,l_cy,l_dy
        self.g = g
        self.cmap = cmap
        self.tpg = tk.Toplevel(self.g, bg='white')
        self.tpg.title('Spectrogram: '+self.name)
        
        fr_fig=tk.Frame(self.tpg,bg='white',bd=0)
        fr_fig.grid(row=0,column=0)
        
        self.rpf = Figure(figsize=(15, 4.5), layout='constrained')
        self.rpo = FigureCanvasTkAgg(self.rpf, master=fr_fig)
        self.rpo.get_tk_widget().grid(row=0, column=0)
        self.rpo.mpl_connect('motion_notify_event', self.__rp_move)
        self.rpo.mpl_connect('button_press_event', self.__rp_press)
        self.rpo.mpl_connect('button_release_event', self.__rp_release)
        
        self.tpf = Figure(figsize=(15, 4.5), layout='constrained')
        self.tpo = FigureCanvasTkAgg(self.tpf, master=fr_fig)
        self.tpo.get_tk_widget().grid(row=1, column=0)
        self.tpo.mpl_connect('motion_notify_event', self.__tp_move)
        self.tpo.mpl_connect('button_press_event', self.__tp_press)
        self.tpo.mpl_connect('button_release_event', self.__tp_release)
        
        self.rgf = Figure(figsize=(0.25, 4.5), layout='constrained')
        self.rgo = FigureCanvasTkAgg(self.rgf, master=fr_fig)
        self.rgo.get_tk_widget().grid(row=0, column=1)
        self.rgo.mpl_connect('motion_notify_event', self.__rg_move)
        self.rgo.mpl_connect('button_press_event', self.__rg_press)
        self.rgo.mpl_connect('button_release_event', self.__rg_release)
        
        self.fr_info=tk.Frame(self.tpg,bg='white',bd=10)
        self.fr_info.grid(row=0,column=1)
        try:
            if len(self.lfs.name)>1:
                nlist = self.lfs.name
                self.namevar = tk.StringVar(value=nlist[0])
                self.l_name = tk.OptionMenu(self.fr_info, self.namevar, *nlist, command=self.__change_file)
                self.l_name.config(font=('Arial', 13, 'bold'))
                self.l_name.grid(row=0, column=0, sticky='ew')
        except:
            pass
        self.l_path = tk.Text(self.fr_info, wrap='word', font=("Arial", 11, "bold"), bg="white", fg="black", state='disabled',height=3,width=30)
        self.l_path.grid(row=1, column=0)
        self.l_path.config(width=max(self.lst)+2, state='normal')
        self.l_path.delete(1.0, tk.END)
        self.l_path.insert(tk.END,self.rdd)
        self.l_path.see(1.0)
        self.l_path.config(state='disabled')
        
        self.info = tk.Text(self.fr_info, wrap='none', font=("Arial", 11, "bold"), bg="white", fg="black", state='disabled', height=10, width=30)
        self.info.grid(row=2, column=0)
        self.info.bind("<FocusIn>", self._select_all)
        self.info.config(height=len(self.tst.split('\n')), width=max(self.lst)+2, state='normal')
        self.info.insert(tk.END, self.tst)
        self.info.see(1.0)
        self.info.config(state='disabled')
        
        self.l_cx=tk.Label(self.fr_info,text='%9s'%'Energy : ',fg='green',font=('Arial',18),bg='white',width=20,anchor='w')
        self.l_cx.grid(row=3,column=0)
        
        self.l_cy=tk.Label(self.fr_info,text='%10s'%'Cursor : ',font=('Arial',18),bg='white',width=20,anchor='w')
        self.l_cy.grid(row=4,column=0)
        
        self.l_dy=tk.Label(self.fr_info,text='%11s'%'Data : ',fg='red',font=('Arial',18),bg='white',width=20,anchor='w')
        self.l_dy.grid(row=5,column=0)
        
        self.b_ups = tk.Button(self.fr_info, text='Fermi Level Fitting', command=self.__ups, width=30, height=1, font=('Arial', 12, "bold"), bg='white', bd=5)
        self.b_ups.grid(row=6, column=0)
        
        self.b_exp = tk.Button(self.fr_info, text='Export Data ( .txt )', command=self.__export, width=30, height=1, font=('Arial', 12, "bold"), bg='white', bd=5)
        self.b_exp.grid(row=7, column=0)
        
        if self.lfs is not None:
            text_casa = 'Export All Data ( _Casa.vms )'
        else:
            text_casa = 'Export Data ( _Casa.vms )'
        self.b_exp_casa = tk.Button(self.fr_info, text=text_casa, command=self.__export_casa, width=30, height=1, font=('Arial', 12, "bold"), bg='white', bd=5)
        self.b_exp_casa.grid(row=8, column=0)
        
        self.copy_button = tk.Button(self.fr_info, text="Copy Image to Clipboard", width=30, height=1, font=('Arial', 12, "bold"), bg='white', fg='red', bd=5, command=self.__copy_to_clipboard)
        self.copy_button.grid(row=9, column=0)
        
        self.__trans_plot_job()
        # self.tpg.update()
        self.tpg.bind("<Return>", self.__rg_entry)
        if self.lfs is not None:
            self.tpg.bind('<Up>', self.__cf_up)
            self.tpg.bind('<Down>', self.__cf_down)
            self.tpg.bind('<MouseWheel>', self.__scroll)
        self.tpg.update()
    
    def __export(self):
        # os.chdir(self.rdd.removesuffix(self.rdd.split('/')[-1]))
        os.chdir(os.path.dirname(self.rdd))
        x, y = self.__sel_y()
        f = open(self.s_exp, 'w', encoding='utf-8')  # tab 必須使用 '\t' 不可"\t"
        f.write('Kinetic Energy'+'\t'+'Intensity'+'\n')
        for i in range(len(x)):
            f.write('%-6e' % x[i]+'\t'+'%-6e' % y[i]+'\n')
        f.close()
    
    # def __export_casa(self):
    # Casa.txt format simple version
    #     os.chdir(self.rdd.removesuffix(self.rdd.split('/')[-1]))
    #     x,y=self.e_photon-self.x,self.y
    #     f = open(self.s_exp_casa, 'w', encoding='utf-8')  # tab 必須使用 '\t' 不可"\t"
    #     f.write('#Wave Vector'+'\t'+'#Intensity'+'\n')
    #     for i in range(len(x)):
    #         f.write('%-6e' % x[i]+'\t'+'%-6e' % y[i]+'\n')
    #     f.close()
    def gen_casa_body(self):
        x, y = self.__sel_y()
        name = f'''{self.name}
Spectrum
'''
        current_date = datetime.now().strftime("%Y_%m_%d_%H_%M_%S_")
        date = current_date.replace('_','\n')+'1\n'+str(len(self.tst.split('\n'))+5)+'\n'
        info = rf'''Casa Info Follows
0
0
0
0
{self.tst}'''
        if self.e_photon == 21.2:
            source = 'He I'
        elif self.e_photon == 40.8:
            source = 'He II'
        elif self.e_photon == 1253.6:
            source = 'Mg'
        elif self.e_photon == 1486.6:
            source = 'Al'
        elif self.e_photon == 3000.0:
            source = 'ES40'
        else:
            source = 'Sync'
        if '_' in self.name:
            n1, n2 = self.name.split('_')[0], ''
        else:
            n1, n2 = self.name, ''
        params = rf'''
XPS
0
{source}
{self.e_photon}
0
0
0
54
0
FAT
{self.dvalue[9].replace(' eV','')}
1e+037
0
0
1e+037
1e+037
1e+037
1e+037
{n1}
{n2}
-1
Kinetic Energy
eV
{np.max(self.ev)}
{self.dvalue[7].replace(' eV','')}
1
Intensity
d
pulse counting
{self.dvalue[11].replace(' s','')}
{self.dvalue[12]}
0
0.0
0.0
0.0
0
{len(x)}
0
1
'''
        data = ''
        for i in range(len(x)):
            data += f'{int(y[i])}\n'
        return name+date+info+params+data
        
    def __export_casa(self):
    # Casa.vms format complete version
        if self.lfs is not None:
            path = fd.asksaveasfilename(title="Save as", filetypes=(("VMS files", "*.vms"),), initialdir=self.lfs.path[0], initialfile=self.lfs.name[0], defaultextension='.vms')
            if path.split('.')[-1] != 'vms':
                path += '.vms'
            if path != '':
                # os.chdir(path.removesuffix(path.split('/')[-1]))
                os.chdir(os.path.dirname(path))
                f = open(path, 'w', encoding='utf-8')
                head = rf'''VAMAS Surface Chemical Analysis Standard Data Transfer Format 1988 May 4
    Not Specified
    PREVAC EA15
    2D Lab
    Not Specified
    3
    Casa Info Follows CasaXPS Version 2.3.18PR1.0
    0
    Number of Regions={len(self.lfs.name)}
    NORM
    REGULAR
    0
    1
    Data Set
    d
    0
    0
    0
    0
    {len(self.lfs.name)}
    '''     
                body = ''
                for i in self.lfs.data:
                    s=spectrogram(i)
                    s.rr1, s.rr2 = self.rr1, self.rr2
                    body+=s.gen_casa_body()
                f.write(head+body+'end of experiment\n')
        else:
            # os.chdir(self.rdd.removesuffix(self.rdd.split('/')[-1]))
            os.chdir(os.path.dirname(self.rdd))
            f = open(self.s_exp_casa, 'w', encoding='utf-8')  # tab 必須使用 '\t' 不可"\t"
            head = r'''VAMAS Surface Chemical Analysis Standard Data Transfer Format 1988 May 4
Not Specified
PREVAC EA15
2D Lab
Not Specified
3
Casa Info Follows CasaXPS Version 2.3.18PR1.0
0
Number of Regions=1
NORM
REGULAR
0
1
Data Set
d
0
0
0
0
1
'''
# 1: Number of Regions

            f.write(head+self.gen_casa_body()+'end of experiment\n')
        f.close()
    
    # def __export_casa(self):
    # # Casa.txt format more complete version
    #     os.chdir(self.rdd.removesuffix(self.rdd.split('/')[-1]))
    #     x, y = self.__sel_y()
    #     f = open(self.s_exp_casa, 'w', encoding='utf-8')  # tab 必須使用 '\t' 不可"\t"
    #     f.write(f'[Info]\n'+
    #         f'Number of Regions=1\n'+
    #         f'[Region 1]\n'+
    #         f'Region Name={self.name}\n'+
    #         f'Dimension 1 name=Kinetic Energy [eV]\n'+
    #         f'Dimension 1 size={len(x)}\n'+
    #         f'Dimension 1 scale=')
    #     for i,v in enumerate(x):
    #         if i!=len(x)-1:
    #             f.write(f'{v} ')
    #         else:
    #             f.write(f'{v}\n')
    #     f.write(f'[Info 1]\n')
    #     key=['Region Name','Acquisition Mode','Energy Scale','Excitation Energy','Center Energy','High Energy','Low Energy','Energy Step','Lens Mode','Pass Energy','Slit','Step Time','Number of Sweeps','Description']
    #     for i in range(len(key)):
    #         if i<len(key)-1:
    #             if key[i]=='Step Time':
    #                 f.write(f"{key[i]}={int(float(self.dvalue[i].replace(' s',''))*1000)}\n")
    #             elif key[i]=='Pass Energy':
    #                 f.write(f"{key[i]}={int(float(self.dvalue[i].replace(' eV','')))}\n")
    #             elif key[i]=='Energy Scale' and self.e_mode=='Binding':
    #                 f.write(f"{key[i]}=Kinetic\n")
    #             elif key[i]=='Low Energy' and self.e_mode=='Binding':
    #                 f.write(f"{key[i]}={21.2-float(self.dvalue[5].replace(' eV','').replace(' (B.E.)',''))}\n")
    #             elif key[i]=='High Energy' and self.e_mode=='Binding':
    #                 f.write(f"{key[i]}={21.2-float(self.dvalue[6].replace(' eV','').replace(' (B.E.)',''))}\n")
    #             else:
    #                 f.write(f"{key[i]}={self.dvalue[i].replace(' eV','').replace(' (K.E.)','')}\n")
    #         else:
    #             f.write(f"{key[i]}={self.dvalue[i]}\n") 
    #     f.write(f'Detector First X-Channel=0\n'+
    #             f'Detector Last X-Channel=0\n'+
    #             f'Detector First Y-Channel=0\n'+
    #             f'Detector Last Y-Channel=0\n'+
    #             f'Number of Slices={len(self.phi)}\n'+
    #             f'spectrum Name={self.name}\n'+
    #             f'Comments={self.desc}; Slit: {self.dvalue[10]};\n')
    #     f.write(f'[Run Mode Information 1]\n'+
    #             f'Name=Normal\n')
    #     f.write(f'[Data1]\n')
    #     for i in range(len(x)):
    #         f.write('%-6e' % i+' '+'%-6e' % y[i]+'\n')
    #     f.close()
    
    def __rg_entry(self, *args):
        self.grg=tk.Toplevel(self.g, bg='white')
        self.grg.title('Data Range')
        
        fr=tk.Frame(self.grg,bg='white')
        fr.grid(row=0,column=0)
        
        self.v_r1=tk.DoubleVar(value=self.rr1)
        l_rr1in1 = tk.Label(fr, text='From', font=('Arial', 16, "bold"), bg='white')
        self.rr1_in = tk.Entry(fr, font=("Arial", 16, "bold"), width=10, textvariable=self.v_r1, bd=5)
        if self.lensmode == 'Transmission':
            l_rr1in2 = tk.Label(fr, text='mm', font=('Arial', 16, "bold"), bg='white')
        else:
            l_rr1in2 = tk.Label(fr, text='deg', font=('Arial', 16, "bold"), bg='white')
        l_rr1in1.grid(row=0,column=0)
        self.rr1_in.grid(row=0,column=1)
        l_rr1in2.grid(row=0,column=2)
        
        self.v_r2=tk.DoubleVar(value=self.rr2)
        l_rr2in1 = tk.Label(fr, text='To', font=('Arial', 16, "bold"), bg='white')
        self.rr2_in = tk.Entry(fr, font=("Arial", 16, "bold"), width=10, textvariable=self.v_r2, bd=5)
        if self.lensmode == 'Transmission':
            l_rr2in2 = tk.Label(fr, text='mm', font=('Arial', 16, "bold"), bg='white')
        else:
            l_rr2in2 = tk.Label(fr, text='deg', font=('Arial', 16, "bold"), bg='white')
        l_rr2in1.grid(row=1,column=0)
        self.rr2_in.grid(row=1,column=1)
        l_rr2in2.grid(row=1,column=2)
        
        fr1 = tk.Frame(self.grg,bg='white')
        fr1.grid(row=2,column=0)
        b1=tk.Button(fr1,text='Confirm',command=self.__save_rg, width=15, height=1, font=('Arial', 14, "bold"), bg='white', bd=5)
        b1.grid(row=2,column=0)
        
        self.grg.bind('<Return>', self.__save_rg)
        self.grg.focus_set()
        self.rr1_in.focus_set()
        self.rr1_in.select_range(0,tk.END)
        self.rr1_in.icursor(tk.END)
        self.grg.update()

    def __save_rg(self, *args):
        try:
            tmax = max([self.v_r1.get(), self.v_r2.get()])
            tmin = min([self.v_r1.get(), self.v_r2.get()])
            if tmin < min(self.phi) or tmax > max(self.phi):
                tk.messagebox.showwarning("Warning","Invalid Input\nThe range must be within the data range.")
                self.tpg.focus_set()
                self.grg.destroy()
                self.__rg_entry()
            else:
                self.rr1, self.rr2 = tmin, tmax
                self.grg.destroy()
                try:
                    self.r1.remove()
                    self.r2.remove()
                    self.s3.remove()
                except: pass
                self.s3,=self.tr_rga.plot([0, 0],[self.rr1, self.rr2],c='lightgreen',marker='<',markersize=20,markerfacecolor='r',linewidth=20)
                self.r1 = self.tr_a1.axhline(self.rr1, c='r')
                self.r2 = self.tr_a1.axhline(self.rr2, c='r')
                self.__tp_a2_plot(self.tr_a1.get_xlim()[0],self.tr_a1.get_xlim()[1])
                self.tpo.draw()
                self.rgo.draw()
                self.rpo.draw()
        except:
            tk.messagebox.showwarning("Warning","Invalid Input\n"+str(sys.exc_info()[1]))
            self.tpg.focus_set()
            self.grg.destroy()
            self.__rg_entry()
    
    def __rg_move(self, event):
        if event.inaxes:
            y = self.near(self.phi, event.ydata)
            if self.fr1==True:
                try:
                    # self.r1.remove()
                    self.s3.remove()
                except: pass
                self.rr1 = y
                self.s3,=self.tr_rga.plot([0, 0],[self.rr1, self.rr2],c='lightgreen',marker='<',markersize=20,markerfacecolor='r',linewidth=20)
                # self.r1 = self.tr_a1.axhline(self.rr1, c='r')
            elif self.fr2==True:
                try:
                    # self.r2.remove()
                    self.s3.remove()
                except: pass
                self.rr2 = y
                self.s3,=self.tr_rga.plot([0, 0],[self.rr1, self.rr2],c='lightgreen',marker='<',markersize=20,markerfacecolor='r',linewidth=20)
                # self.r2 = self.tr_a1.axhline(self.rr2, c='r')
            elif self.fr3==True:
                try:
                    # self.r1.remove()
                    # self.r2.remove()
                    self.s3.remove()
                except: pass
                if y-self.roy+self.romin < min(self.phi):
                    self.rr1 = min(self.phi)
                    self.rr2 = min(self.phi)+(self.romax-self.romin)
                elif y-self.roy+self.romax > max(self.phi):
                    self.rr2 = max(self.phi)
                    self.rr1 = max(self.phi)-(self.romax-self.romin)
                else:
                    self.rr1 = y-self.roy+self.romin
                    self.rr2 = y-self.roy+self.romax
                
                # self.r1 = self.tr_a1.axhline(self.rr1, c='r')
                # self.r2 = self.tr_a1.axhline(self.rr2, c='r')
                self.s3,=self.tr_rga.plot([0, 0],[self.rr1, self.rr2],c='lightgreen',marker='<',markersize=20,markerfacecolor='r',linewidth=20)
        self.__tp_a2_plot(self.tr_a1.get_xlim()[0],self.tr_a1.get_xlim()[1])
        self.tpo.draw()
        # self.rpo.draw()
        self.rgo.draw()
    
    def __rg_press(self, event):
        if event.button == 1 and event.inaxes:
            y = self.near(self.phi, event.ydata)
            self.fr1 = False
            self.fr2 = False
            self.fr3 = False
            self.roy = self.near(self.phi, event.ydata)
            self.rr1, self.rr2 = sorted([self.near(self.phi, self.rr1), self.near(self.phi, self.rr2)])
            self.romin = self.rr1
            self.romax = self.rr2
            if abs(self.rr1-y) < (self.phi[1]-self.phi[0])*len(self.phi)*1/40:
                try:
                    # self.r1.remove()
                    self.s3.remove()
                except: pass
                self.fr1 = True
                self.rr1 = y
                
            elif abs(self.rr2-y) < (self.phi[1]-self.phi[0])*len(self.phi)*1/40:
                try:
                    # self.r2.remove()
                    self.s3.remove()
                except: pass
                self.fr2 = True
                self.rr2 = y
            elif self.rr1 < y < self.rr2:
                try:
                    # self.r1.remove()
                    # self.r2.remove()
                    self.s3.remove()
                except: pass
                self.fr3 = True
        elif event.button == 3 and event.inaxes:
            self.__rg_entry()
        self.rgo.draw()
        self.rpo.draw()
        
    def __rg_release(self, event):
        self.fr1 = False
        self.fr2 = False
        self.fr3 = False
        self.__re_tr_a1_plot(self.tr_a1.get_xlim()[0],self.tr_a1.get_xlim()[1])
        self.rpo.draw()
        
    
    def __rp_move(self, event):
        # global rpf, rpo, tpf, tpo, tr_a1, tr_a2, xx2, yy2, aa1, aa2, cur, l_cx, l_cy, l_dy
        self.rpf.canvas.get_tk_widget().config(cursor="")
        if event.inaxes:
            self.rpf.canvas.get_tk_widget().config(cursor="tcross")
            self.out = False
            try:
                # self.xx1.remove()
                self.xx2.remove()
                self.yy2.remove()
                self.cur.remove()
                # self.aa1.remove()
                self.aa2.remove()
            except:
                pass
            if self.lensmode == 'Transmission':
                unit=' mm'
            else:
                if self.npzf:unit=' 2pi/A'
                else:unit = ' deg'
            if event.xdata>self.ev[-1]:
                cxdata = self.ev[-1]
            elif event.xdata<self.ev[0]:
                cxdata = self.ev[0]
            else:
                cxdata = event.xdata
            cydata = event.ydata
            self.tx = cxdata
            xf = (cxdata > self.oxl[0] and cxdata < self.oxl[1])
            yf = (cydata > self.tr_a1.get_ylim()[0] and cydata < self.tr_a1.get_ylim()[1])
            if xf and yf:
                tz = self.data.to_numpy().transpose()
                x = self.x
                y = self.y
                yy = self.phi
                xi = 0
                yi = 0
                
                if cxdata < x[0]:
                    xi=0
                elif cxdata > x[-1]:
                    xi=len(x)-1
                else:
                    xi=np.argwhere(abs(x-cxdata) <= (x[1]-x[0])/2)[0][0]
                if cydata < yy[0]:
                    yi=0
                elif cydata > yy[-1]:
                    yi=len(yy)-1
                else:
                    yi=np.argwhere(abs(yy-cydata) <= (yy[1]-yy[0])/2)[0][0]
                    
                try:
                    self.l_cx.config(text='%9s%8.3f%3s'%('Energy : ',cxdata,' eV'))
                    self.l_cy.config(text='%10s%11.4g%4s'%('Cursor : ',cydata,unit))
                    self.l_dy.config(text='%11s%11.4g'%('Data : ',tz[yi][xi]))
                except:
                    pass
                # self.xx1.set_data([cxdata,cxdata], self.oy1)
                # self.xx1=self.tr_a1.axvline(cxdata,color='g')
                self.xx2=self.tr_a2.axvline(cxdata,color='g')
                self.yy2=self.tr_a2.axhline(-max(y),color='grey')
                
                x, y = self.__sel_y()
                    
                x,y=x[xi],y[xi]
                self.cur=self.tr_a2.scatter(x,y,c='r',marker='o',s=30)
                self.tr_a2.set_ylim(self.oy2)
                if not self.tp_cf:
                    # self.aa1=self.tr_a1.fill_between([self.ox,cxdata],self.oy1[0],self.oy1[1],color='g',alpha=0.2)
                    self.aa2=self.tr_a2.fill_between([self.ox,cxdata],self.oy2[0],self.oy2[1],color='g',alpha=0.2)
                    self.tr_a2.set_ylim(self.oy2)
        else:
            try:
                self.l_cx.config(text='%9s'%'Energy : ')
                self.l_cy.config(text='%10s'%'Cursor : ')
                self.l_dy.config(text='%11s'%'Data : ')
                # self.xx1.remove()
                self.xx2.remove()
                self.yy2.remove()
                self.cur.remove()
                # self.xx2.remove()
                # self.yy2.remove()
                # self.cur.remove()
                # self.aa1.remove()
                # self.aa2.remove()
            except:
                pass
        # self.rpo.draw()
        self.tpo.draw()

    def __rp_press(self, event):
        # global tp_cf, rpf, rpo ,tpf, tpo , tr_a1, tr_a2 , x1 , x2 , ox, aa1, aa2
        if event.button == 1 and self.tp_cf:
            self.tp_cf = False
            self.out=True
            # self.x1 = self.tr_a1.axvline(event.xdata, color='g')
            # self.x1.set_data([event.xdata,event.xdata], self.oy1)
            self.x2 = self.tr_a2.axvline(event.xdata, color='g')
            self.tr_a2.set_ylim(self.oy2)
            self.ox=event.xdata

        elif event.button == 3:
            self.rpf.canvas.get_tk_widget().config(cursor="watch")
            self.tp_cf = True
            self.__tp_a1_plot()
            self.__tp_a2_plot(self.oxl[0],self.oxl[1])
            self.rpo.draw()
            self.rpf.canvas.get_tk_widget().config(cursor="tcross")
        
        self.tpo.draw()
        

    def __rp_release(self, event):
        # global tp_cf, rpf, rpo ,tpf, tpo , tr_a1, tr_a2, x1, x2 , ox, aa1, aa2
        if event.button == 1 and not self.tp_cf:
            self.rpf.canvas.get_tk_widget().config(cursor="watch")
            self.tp_cf = True
            try:
                # self.x1.remove()
                # self.x1.set_data([],[])
                self.x2.remove()
                # self.aa1.remove()
                self.aa2.remove()
            except:
                pass
            if self.out == False:
                self.__re_tr_a1_plot(sorted([self.ox, self.tx])[0],sorted([self.ox, self.tx])[1])
                self.__tp_a2_plot(sorted([self.ox, self.tx])[0],sorted([self.ox, self.tx])[1])
            else:
                self.__re_tr_a1_plot(self.oxl[0],self.oxl[1])
                self.__tp_a2_plot(self.oxl[0],self.oxl[1])
            self.rpo.draw()
            self.tpo.draw()
            self.rpf.canvas.get_tk_widget().config(cursor="tcross")
        
    def __tp_move(self, event):
        # global tpf, tpo, tr_a1, tr_a2, tpf, xx2, yy2, aa1, aa2, cur, l_cx, l_cy, l_dy
        self.tpf.canvas.get_tk_widget().config(cursor="")
        if event.inaxes:
            self.out = False
            try:
                self.xx2.remove()
                self.yy2.remove()
                self.cur.remove()
                # self.aa1.remove()
                self.aa2.remove()
            except:
                pass
            self.tpf.canvas.get_tk_widget().config(cursor="tcross")
            if event.xdata>self.ev[-1]:
                cxdata = self.ev[-1]
            elif event.xdata<self.ev[0]:
                cxdata = self.ev[0]
            else:
                cxdata = event.xdata
            cydata = event.ydata
            self.tx = cxdata
            xf = (cxdata >= self.oxl[0] and cxdata <= self.oxl[1])
            yf = (cydata >= self.tr_a2.get_ylim()[0] and cydata <= self.tr_a2.get_ylim()[1])
            if xf and yf:
                y = self.y
                x = self.x
                xi = 0
                
                if cxdata < x[0]:
                    xi=0
                elif cxdata > x[-1]:
                    xi=len(x)-1
                else:
                    xi=np.argwhere(abs(x-cxdata) <= (x[1]-x[0])/2)[0][0]
                
                x, y = self.__sel_y()
                    
                x,y=x[xi],y[xi]
                try:
                    self.l_cx.config(text='%9s%8.3f%3s'%('Energy : ',cxdata,' eV'))
                    self.l_cy.config(text='%10s%11.4g'%('Cursor : ',cydata))
                    self.l_dy.config(text='%11s%11.4g'%('Data : ',y))
                except:
                    pass
                self.xx2=self.tr_a2.axvline(cxdata,color='g')
                self.yy2=self.tr_a2.axhline(cydata,color='grey')
                self.cur=self.tr_a2.scatter(x,y,c='r',marker='o',s=30)
                self.tr_a2.set_ylim(self.oy2)
                if not self.tp_cf:
                    # self.aa1=self.tr_a1.fill_between([self.ox,cxdata],self.oy1[0],self.oy1[1],color='g',alpha=0.2)
                    self.aa2=self.tr_a2.fill_between([self.ox,cxdata],self.oy2[0],self.oy2[1],color='g',alpha=0.2)
                    self.tr_a2.set_ylim(self.oy2)
        else:
            try:
                self.l_cx.config(text='%9s'%'Energy : ')
                self.l_cy.config(text='%10s'%'Cursor : ')
                self.l_dy.config(text='%11s'%'Data : ')
                self.xx2.remove()
                self.yy2.remove()
                self.cur.remove()
                # self.xx2.remove()
                # self.yy2.remove()
                # self.cur.remove()
                # self.aa1.remove()
                # self.aa2.remove()
            except:
                pass
        # self.rpo.draw()
        self.tpo.draw()


    def __tp_press(self, event):
        # global tp_cf, rpf, rpo ,tpf, tpo , tr_a1, tr_a2 , x1 , x2 , ox, aa1, aa2
        if event.button == 1 and self.tp_cf:
            self.tp_cf = False
            self.out=True
            # self.x1 = self.tr_a1.axvline(event.xdata, color='g')
            self.x2 = self.tr_a2.axvline(event.xdata, color='g')
            self.tr_a2.set_ylim(self.oy2)
            self.ox=event.xdata

        elif event.button == 3:
            self.tpf.canvas.get_tk_widget().config(cursor="watch")
            self.tp_cf = True
            self.__tp_a1_plot()
            self.__tp_a2_plot(self.oxl[0],self.oxl[1])
            self.rpo.draw()
            self.tpf.canvas.get_tk_widget().config(cursor="tcross")
        
        self.tpo.draw()
        
        
    def __tp_release(self, event):
        # global tp_cf, rpf, rpo ,tpf, tpo , tr_a1, tr_a2, x1, x2 , ox, aa1, aa2
        if event.button == 1 and not self.tp_cf:
            self.tpf.canvas.get_tk_widget().config(cursor="watch")
            self.tp_cf = True
            try:
                # self.x1.remove()
                self.x2.remove()
                # self.aa1.remove()
                self.aa2.remove()
            except:
                pass
            if self.out == False:
                self.__re_tr_a1_plot(sorted([self.ox, self.tx])[0],sorted([self.ox, self.tx])[1])
                self.__tp_a2_plot(sorted([self.ox, self.tx])[0],sorted([self.ox, self.tx])[1])
            else:
                self.__re_tr_a1_plot(self.oxl[0],self.oxl[1])
                self.__tp_a2_plot(self.oxl[0],self.oxl[1])
            self.rpo.draw()
            self.tpo.draw()
            self.tpf.canvas.get_tk_widget().config(cursor="tcross")
            
    def __re_tr_a1_plot(self,xx1,xx2):
        z = self.data.to_numpy().transpose()
        # self.tr_a1.scatter(self.ev, np.sum(tz,axis=0), c='k', marker='o', s=0.9)
        x = self.ev
        xi=[]
        x1, x2 = sorted([xx1, xx2])
        xx1, xx2 = self.near(x, xx1), self.near(x, xx2)
        for i,v in enumerate(x):
            if v>=xx1 and v<=xx2:
                xi.append(i)
        x = x[xi]
        tx, ty = np.meshgrid(x, self.phi)
        tz = tx*0
        tz[0:, 0:] = z[0:, xi]
        # ttx = np.linspace(min(x),max(x),len(x)*4)
        # tx, ty = np.meshgrid(ttx, self.phi)
        # x, y = np.meshgrid(x, self.phi)
        # tz = griddata((x.flatten(), y.flatten()), tz.flatten(), (tx, ty), method='cubic')
        self.tr_a1.clear()
        self.tr_a1.pcolormesh(tx,ty,tz,cmap=self.cmap)
        self.r1=self.tr_a1.axhline(self.rr1, c='r')
        self.r2=self.tr_a1.axhline(self.rr2, c='r')
        if self.lensmode=='Transmission':
            self.tr_a1.set_ylabel('Position (mm)', font='Arial', fontsize=16)
        else:
            if self.npzf:self.tr_a1.set_ylabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=16)
            else:self.tr_a1.set_ylabel('Angle (deg)', font='Arial', fontsize=16)
                
        self.tr_a1.set_xticks([])
        self.tr_a1.set_yticklabels(labels=self.tr_a1.get_yticklabels(), font='Arial', fontsize=14)
        self.tr_a1.set_xlim([x1, x2])
        self.tr_a1.set_ylim(self.oy1)
        
    def __tp_a1_plot(self):
        # global tr_a2, oy2
        tx, ty = np.meshgrid(self.ev, self.phi)
        tz = self.data.to_numpy().transpose()
        # self.tr_a1.scatter(self.ev, np.sum(tz,axis=0), c='k', marker='o', s=0.9)
        self.tr_a1.clear()
        self.tr_a1.pcolormesh(tx,ty,tz,cmap=self.cmap)
        self.r1=self.tr_a1.axhline(self.rr1, c='r')
        self.r2=self.tr_a1.axhline(self.rr2, c='r')
        if self.lensmode=='Transmission':
            self.tr_a1.set_ylabel('Position (mm)', font='Arial', fontsize=16)
        else:
            if self.npzf:self.tr_a1.set_ylabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=16)
            else:self.tr_a1.set_ylabel('Angle (deg)', font='Arial', fontsize=16)
        self.tr_a1.set_xticks([])
        self.tr_a1.set_yticklabels(labels=self.tr_a1.get_yticklabels(), font='Arial', fontsize=14)
        # self.tr_a1.set_xlim(self.tr_a1.get_xlim())
        # self.x1, = self.tr_a1.plot([],[],'g-')
        # self.xx1, = self.tr_a1.plot([],[],'g-')
        self.tr_a1.set_xlim([sorted([self.ev[0], self.ev[-1]])[0]-abs(self.ev[-1]-self.ev[0])/50, sorted([self.ev[0], self.ev[-1]])[1]+abs(self.ev[-1]-self.ev[0])/50])
        self.tr_a1.set_ylim([sorted([self.phi[0], self.phi[-1]])[0]-abs(self.phi[-1]-self.phi[0])/20, sorted([self.phi[0], self.phi[-1]])[1]+abs(self.phi[-1]-self.phi[0])/20])
        self.oxl=self.tr_a1.get_xlim()
        self.oy1=self.tr_a1.get_ylim()
    
    def __tp_a2_plot(self,xx1,xx2):
        # global tr_a2, oy2
        x, y = self.__sel_y()
        xi=[]
        for i,v in enumerate(x):
            if v>=xx1 and v<=xx2:
                xi.append(i)
        x = x[xi]
        y = y[xi]
        self.tr_a2.clear()
        if self.type=='fd':
            self.tr_a2.plot(x,y, color='k')
        else:
            if abs(xx1-xx2)>abs(self.oxl[1]-self.oxl[0])/2:
                self.tr_a2.scatter(x,y, c='k', marker='o', s=0.9)
            elif abs(xx1-xx2)>abs(self.oxl[1]-self.oxl[0])/4:
                self.tr_a2.scatter(x,y, c='k', marker='o', s=10)
            else:
                self.tr_a2.scatter(x,y, c='k', marker='o', s=30)
        self.tr_a2.ticklabel_format(style='plain', axis='y', scilimits=(0,0))
        self.tr_a2.set_xlim(self.tr_a1.get_xlim())
        self.tr_a2.set_xlabel('Kinetic Energy (eV)', font='Arial', fontsize=16)
        self.tr_a2.set_ylabel(self.s_yl, font='Arial', fontsize=16)
        self.tr_a2.set_xticklabels(labels=self.tr_a2.get_xticklabels(), font='Arial', fontsize=14)
        self.tr_a2.set_yticklabels(labels=self.tr_a2.get_yticklabels(), font='Arial', fontsize=14)
        self.oy2=self.tr_a2.get_ylim()

    def __tp_rga_plot(self):
        self.s3,=self.tr_rga.plot([0, 0],[self.rr1, self.rr2],c='lightgreen',marker='<',markersize=20,markerfacecolor='r',linewidth=20)
        self.tr_rga.set_ylim([sorted([self.phi[0], self.phi[-1]])[0]-abs(self.phi[-1]-self.phi[0])/20, sorted([self.phi[0], self.phi[-1]])[1]+abs(self.phi[-1]-self.phi[0])/20])
        self.tr_rga.set_xticks([])
        self.tr_rga.set_yticks([])
    
    def __trans_plot_job(self):
        # global rpf,rpo,tpf,tpo,tr_a1,tr_a2,oxl,oy1
        self.tr_a1=self.rpf.add_axes([0.1, 0.05, 0.88, 0.9])
        self.tr_a1.set_facecolor('lightblue')
        self.tr_a2=self.tpf.add_axes([0.1, 0.15, 0.88, 0.82])
        self.tr_rga=self.rgf.add_axes([0, 0.05, 1, 0.9])
        self.tr_rga.set_facecolor('lightblue')
        self.__tp_a1_plot()
        self.__tp_a2_plot(self.oxl[0],self.oxl[1])
        self.__tp_rga_plot()
        # self.rpf.tight_layout()
        # self.tpf.tight_layout()
        self.rpo.draw()
        self.tpo.draw()
        self.rgo.draw()
            
def trans_plot():
    global gtp
    gtp=tk.Toplevel(g)
    gtp.title('Spectrogram')
    b_raw = tk.Button(gtp, text='Raw', command=raw_plot, width=15, height=1, font=('Arial', 14, "bold"), bg='white', bd=5)
    b_raw.grid(row=0, column=0)
    b_smooth = tk.Button(gtp, text='Smooth', command=smooth_plot, width=15, height=1, font=('Arial', 14, "bold"), bg='white', bd=5)
    b_smooth.grid(row=0, column=1)
    b_fd = tk.Button(gtp, text='First Derivative', command=fd_plot, width=15, height=1, font=('Arial', 14, "bold"), bg='white', bd=5)
    b_fd.grid(row=0, column=2)
    gtp.focus_set()
    gtp.bind('<Return>', raw_plot)
    gtp.update()

def raw_plot(*args):
    gtp.destroy()
    cmap=value3.get()
    s=spectrogram(data)
    s.plot(g, cmap)

def smooth_plot():
    gtp.destroy()
    cmap=value3.get()
    y=smooth(np.sum(data.to_numpy().transpose(),axis=0),l=13)
    s=spectrogram(data)
    s.setdata(ev, y, dtype='smooth', unit='Counts')
    s.plot(g, cmap)

def fd_plot():
    gtp.destroy()
    cmap=value3.get()
    y=smooth(np.sum(data.to_numpy().transpose(),axis=0),l=13)
    s=spectrogram(data)
    s.setdata(ev[0:-1]+(ev[1]-ev[0])/2, np.diff(y)/np.diff(ev), dtype='fd', unit='dN/dE')
    s.plot(g, cmap)

def o_cal(*e):
    """
    Calculate the angle in degrees based on the given values of calk and cale.

    Parameters:
    *e : tuple
        Variable-length argument list.

    Returns:
    float
        The calculated angle in degrees.

    Raises:
    None

    """
    global calk, cale
    if '' == calk.get():
        calk.set('0')
        calken.select_range(0, 1)
    if '' == cale.get():
        cale.set('0')
        caleen.select_range(0, 1)
    ans = np.arcsin(np.float64(calk.get())/(2*m*np.float64(cale.get())
                    * 1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
    caldeg.config(text='Deg = '+'%.5f' % ans)

def cal(*e):
    t = threading.Thread(target=o_cal)
    t.daemon = True
    t.start()

def scroll(event):
    if event.delta>0:
        cf_up()
    elif event.delta<0:
        cf_down()

def cf_up(*args):
    global namevar
    now = namevar.get()
    for i, j in enumerate(lfs.name):
        if now == j:
            if i == 0:
                namevar.set(lfs.name[-1])
            else:
                namevar.set(lfs.name[i-1])
    change_file()

def cf_down(*args): 
    global namevar
    now = namevar.get()
    for i, j in enumerate(lfs.name):
        if now == j:
            if i == len(lfs.name)-1:
                namevar.set(lfs.name[0])
            else:
                namevar.set(lfs.name[i+1])
    change_file()

npzf = False
def change_file(*args):
    global data, rdd, npzf
    name = namevar.get()
    for i, j, k, l in zip(lfs.name, lfs.data, lfs.path, lfs.f_npz):
        if name == i:
            data = j
            pr_load(j)
            rdd = k
            if l:
                npzf = True
                koffset.config(state='normal')
                k_offset.set('0')
                koffset.config(state='disabled')
            else:
                npzf = False
                koffset.config(state='normal')
                try:
                    k_offset.set(ko)
                except:
                    k_offset.set('0')
    st.put(name)
    if value.get() != '---Plot1---':
        o_plot1()
    
def tools(*args):
    def spec(*args):
        s = spectrogram(path=lfs.path)
        s.plot(g, value3.get())
        toolg.destroy()
        
    def exp_casa():
        lfs.export_casa()
        toolg.destroy()
        
    def kplane():
        g_CEC = CEC(g, lfs.path)
        toolg.destroy()

    toolg = tk.Toplevel(g)
    toolg.title('Batch Master')
    toolg.focus_set()
    b_spec = tk.Button(toolg, text='Spectrogram', command=spec, width=15, height=1, font=('Arial', 14, "bold"), bg='white', bd=5)
    b_spec.grid(row=0, column=0)
    if lfs.sort != 'no':
        b_kplane = tk.Button(toolg, text='k-Plane', command=kplane, width=15, height=1, font=('Arial', 14, "bold"), bg='white', bd=5)
        b_kplane.grid(row=0, column=1)
    b_exp_casa = tk.Button(toolg, text='Export to Casa', command=exp_casa, width=15, height=1, font=('Arial', 14, "bold"), bg='white', bd=5)
    b_exp_casa.grid(row=0, column=2)
    toolg.bind('<Return>', spec)
    toolg.update()
    
class loadfiles():
    def __init__(self, files):
        self.f_npz = [False for i in files]
        self.n = []
        for i, v in enumerate(files):
            tf=False
            try:
                if load_h5(v).attrs['Acquisition']=='VolumeSlicer':
                    tf=True
            except: pass
            if '.npz' in os.path.basename(v) or tf:
                self.f_npz[i] = True
                self.n.append(i)
        self.opath = [f for f in files]
        self.oname = [os.path.basename(f).split('#id#')[0].split('#d#')[0].split('id')[0].replace('.h5', '').replace('.json', '').replace('.txt', '').replace('.npz', '') for f in self.opath]
        self.r1s = ['R1_', 'R1 ', 'R1', 'r1_', 'r1 ', 'r1']
        self.r2s = ['R2_', 'R2 ', 'R2', 'r2_', 'r2 ', 'r2']
        self.sep = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
                    'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
                    ',','!','@','#','$','%','^','&','*','(',')','_','-','+','=','[',']','{','}','|','\\',';',':','\'','"',
                    ' ','.txt','.TXT']
        self.__set_r1_r2()
        self.__set_data()
        
    def __set_data(self):
        self.data = []
        for i in self.path:
            tbasename = os.path.basename(i)
            if '.h5' in tbasename:
                self.data.append(load_h5(i))
            elif '.json' in tbasename:
                self.data.append(load_json(i))
            elif '.txt' in tbasename:
                self.data.append(load_txt(i))
            elif '.npz' in tbasename:
                self.data.append(load_npz(i))
            else:
                self.data.append([])
    
    def __set_r1_r2(self):
        def __sort_r1_r2():
            self.or2 = self.gen_r2(self.oname, self.r1_splitter, self.r2_splitter)
            self.or1 = self.gen_r1(self.oname, self.r1_splitter, self.r2_splitter)
            self.path1 = []
            self.r11 = []
            tpath = []
            tr1 = []
            tr2 = []
            self.r2 = []
            r2 = sorted(set(self.or2))
            for i in r2:
                for j,k,l in zip(self.opath, self.or1, self.or2):
                    if i == l:
                        tpath.append(j)
                        tr1.append(k)
                        tr2.append(l)
                self.path1.append(tpath)
                self.r11.append(tr1)
                self.r2.append(tr2)
                tpath = []
                tr1 = []
                tr2 = []
            self.path = []
            self.r1 = []
            t = 0
            for i in self.path1:
                opath = [f for f in i]
                path = res(self.r11[t], opath)
                r1 = res(self.r11[t], self.r11[t])
                for j,v in enumerate(path):
                    self.path.append(v)
                    self.r1.append(r1[j])
                t+=1
            self.name = [os.path.basename(f).split('#id#')[0].split('#d#')[0].split('id')[0].replace('.h5', '').replace('.json', '').replace('.txt', '') for f in self.path]
            self.name = self.check_repeat(self.name)
            
        def __sort_r1():
            self.or1 = self.gen_r1(self.oname, self.r1_splitter, self.r2_splitter)
            self.path = res(self.or1, self.opath)
            self.r1 = res(self.or1, self.or1)
            self.name = [os.path.basename(f).split('#id#')[0].split('#d#')[0].split('id')[0].replace('.h5', '').replace('.json', '').replace('.txt', '') for f in self.path]
            self.name = self.check_repeat(self.name)
            
        self.r1_splitter , self.r2_splitter= [], []
        r1s = self.r1s
        r2s = self.r2s
        for i in self.oname:
            tj, tk = False, False
            for j,k in zip(r1s, r2s):
                if j in i and tj == False:
                    self.r1_splitter.append(j)
                    tj = True
                if k in i and tk == False:
                    self.r2_splitter.append(k)
                    tk = True
            if not tj:
                self.r1_splitter.append('No_r1')
            if not tk:
                self.r2_splitter.append('No_r2')
        
        try:
            f = True
            t=0
            for i in self.oname:
                if len(i.split(self.r1_splitter[t]))<=1 or len(i.split(self.r2_splitter[t]))<=1:
                    f = False
                t+=1
            if f:   # r1 and r2 exist
                __sort_r1_r2()
                self.sort = 'r1r2'
                print('Sort by r1 and r2\n')
            elif len(self.oname[0].split(self.r1_splitter[0]))>1:   # only r1 exist
                __sort_r1()
                self.sort = 'r1'
                print('Sort by r1\n') 
            else:   # no r1 and r2
                if self.r1s[0] == 'X_':
                    self.r1s, self.r2s = ['R1_', 'R1 ', 'R1', 'r1_', 'r1 ', 'r1'], ['R2_', 'R2 ', 'R2', 'r2_', 'r2 ', 'r2']
                    self.path = self.opath
                    self.name = self.check_repeat(self.oname)
                    self.sort = 'no'
                    print('No Sort\n')
                else:
                    self.r1s, self.r2s = ['X_', 'X ', 'X', 'x_', 'x ', 'x'], ['Z_', 'Z ', 'Z', 'z_', 'z ', 'z']
                    self.__set_r1_r2()
        except:
            self.r1s, self.r2s = ['R1_', 'R1 ', 'R1', 'r1_', 'r1 ', 'r1'], ['R2_', 'R2 ', 'R2', 'r2_', 'r2 ', 'r2']
            self.path = self.opath
            self.name = self.check_repeat(self.oname)
            self.sort = 'no'
            print('No Sort (Exception)\n')
        
    def check_repeat(self, name):
        fl = False
        tname = [f for f in name]
        if len(name) != len(set(name)):
            fl = True
        if fl:
            t = 0
            while t < len(tname):
                fj = False
                tt = False
                tj = t
                for j in range(t+1, len(name)):
                    if name[t] == name[j]:
                        if not tt:
                            tname[t] = tname[t]+'#id#'+str(t)
                            tt = True
                        tname[j] = tname[j]+'#id#'+str(j)
                        fj = True
                        tj = j
                if fj:
                    t = tj
                t+=1
        return tname
        
    def gen_r1(self, name, r1_splitter, r2_splitter):
            try:
                r1 = []
                for i,v in enumerate(name):
                    tf=True
                    t=v.split(r1_splitter[i])[1].split(r2_splitter[i])[0].split(' ')[0].split('_')[0]
                    while tf:
                        try:
                            a=float(t)
                            tf=False
                        except:
                            for j in self.sep:
                                if j in t:
                                    t=t.split(j)[0]
                    r1.append(a)
                return np.float64(r1)
            except:
                print('Error in loadfiles().gen_r1')
                print(sys.exc_info())
                return name
    
    def gen_r2(self, name, r1_splitter, r2_splitter):
            try:
                r2 = []
                for i,v in enumerate(name):
                    tf=True
                    t=v.split(r2_splitter[i])[1].split(r1_splitter[i])[0].split(' ')[0].split('_')[0]
                    while tf:
                        try:
                            a=float(t)
                            tf=False
                        except:
                            for j in self.sep:
                                if j in t:
                                    t=t.split(j)[0]
                    r2.append(a)
                return np.float64(r2)
            except:
                print('Error in loadfiles().gen_r2')
                print(sys.exc_info())
                return name
            
    def export_casa(self):
        path = fd.asksaveasfilename(title="Save as", filetypes=(("VMS files", "*.vms"),), initialdir=self.path[0], initialfile=self.name[0], defaultextension='.vms')
        if path.split('.')[-1] != 'vms':
            path += '.vms'
        if path != '.vms':
            # os.chdir(path.removesuffix(path.split('/')[-1]))
            os.chdir(os.path.dirname(path))
            f = open(path, 'w', encoding='utf-8')
            head = rf'''VAMAS Surface Chemical Analysis Standard Data Transfer Format 1988 May 4
    Not Specified
    PREVAC EA15
    2D Lab
    Not Specified
    3
    Casa Info Follows CasaXPS Version 2.3.18PR1.0
    0
    Number of Regions={len(self.name)}
    NORM
    REGULAR
    0
    1
    Data Set
    d
    0
    0
    0
    0
    {len(self.name)}
    '''     
            body = ''
            for i in self.data:
                s=spectrogram(i)
                body+=s.gen_casa_body()
            f.write(head+body+'end of experiment\n')
            f.close()
            
def cut_job_y(args):
    i, angle, phi_offset, r1_offset, self_x, self_volume, cdensity, xmax, xmin, ymax, ymin, z, x, self_z, self_y, ev, e_photon, sym = args
    # print(i)
    g=VolumeSlicer()
    g.ev = ev
    g.y = self_y
    g.z = self_z
    g.cdensity = cdensity
    g.type = 'reciprocal'
    g.xmin = xmin
    g.xmax = xmax
    g.ymin = ymin
    g.ymax = ymax
    g.ox = self_x
    g.phi_offset = phi_offset
    g.r1_offset = r1_offset
    g.e_photon = e_photon
    g.angle = angle
    g.slice_index = i
    g.sym = sym
    surface = g.slice_data(i, angle, phi_offset, r1_offset, self_x, self_volume, x, z)
    td = surface[int(cdensity/(xmax-xmin)*(min(z)-xmin)):int(cdensity/(xmax-xmin)*(max(z)-xmin)), int(cdensity/(ymax-ymin)*(min(x)-ymin)):int(cdensity/(ymax-ymin)*(max(x)-ymin))]
    del surface
    td = cv2.resize(td, (cdensity, td.shape[1]), interpolation=cv2.INTER_CUBIC)
    result = td.mean(axis=0)
    del td
    gc.collect()
    return i, result

def cut_job_x(args):
    i, angle, phi_offset, r1_offset, self_x, self_volume, cdensity, xmax, xmin, ymax, ymin, z, x, self_z, self_y, ev, e_photon, sym = args
    # print(i)
    g=VolumeSlicer()
    g.ev = ev
    g.y = self_y
    g.z = self_z
    g.cdensity = cdensity
    g.type = 'reciprocal'
    g.xmin = xmin
    g.xmax = xmax
    g.ymin = ymin
    g.ymax = ymax
    g.ox = self_x
    g.phi_offset = phi_offset
    g.r1_offset = r1_offset
    g.e_photon = e_photon
    g.angle = angle
    g.slice_index = i
    g.sym = sym
    surface = g.slice_data(i, angle, phi_offset, r1_offset, self_x, self_volume, x, z)
    td = surface[int(cdensity/(xmax-xmin)*(min(z)-xmin)):int(cdensity/(xmax-xmin)*(max(z)-xmin)), int(cdensity/(ymax-ymin)*(min(x)-ymin)):int(cdensity/(ymax-ymin)*(max(x)-ymin))]
    del surface
    td = cv2.resize(td, (td.shape[0], cdensity), interpolation=cv2.INTER_CUBIC)
    result = td.mean(axis=1)
    del td
    gc.collect()
    return i, result

def set_entry_value(entry, value):
    entry.delete(0, tk.END)
    entry.insert(0, value)

def mesh(x, y):
    """
    Create a meshgrid from x and y arrays.
    
    Args
    ------
    - x : ndarray-like
        2D array for x-coordinates.
    - y : ndarray-like
        2D array for y-coordinates.
        
    Returns
    -------
    (X1, Y1, X2, Y2) : tuple
        Meshgrid arrays for x and y coordinates.
    """
    x1, y1 = x.T.copy(), y.T.copy()
    for i in range(x.shape[0]):
        if i % 2 == 0:
            x[i] = x[i][::-1]
            y[i] = y[i][::-1]
    for i in range(y1.shape[0]):
        if i % 2 == 0:
            x1[i] = x1[i][::-1]
            y1[i] = y1[i][::-1]
    return x, y, x1, y1

def rotate(data, angle, size):
    """
    for square data
    """
    mat = cv2.getRotationMatrix2D((size[1]/2, size[0]/2), angle, 1)
    data = cv2.warpAffine(data, mat, (size[1], size[0]), flags=cv2.INTER_NEAREST)
    return data

class g_cut_plot(tk.Toplevel):
    def __init__(self, master, data_cut, cx, cy, cdx, cdy, cdensity, ty, z, x, angle, phi_offset, r1_offset, stop_event, pool, path, e_photon, slim, sym):
        super().__init__(master, background='white')
        self.cx_cut = cx
        self.cy_cut = cy
        self.cdx_cut = cdx
        self.cdy_cut = cdy
        self.phi_offset = phi_offset
        self.r1_offset = r1_offset
        self.slim_cut = slim
        self.sym_cut = sym
        self.data_cut = data_cut
        self.cdx = cdx
        self.cdy = cdy
        self.cdensity = cdensity
        self.ty = ty
        self.z = z
        self.x = x
        self.angle = angle
        self.e_photon = e_photon
        self.stop_event = stop_event
        self.pool = pool
        self.path = path

        self.create_window()

    def create_window(self):
        self.title('Cut Plot')
        self.protocol("WM_DELETE_WINDOW", self.on_closing)    

        fig = plt.Figure(figsize=(9, 9), constrained_layout=True)
        ax = fig.add_subplot(111)
        ax.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', fontsize=16)
        ax.set_ylabel('Kinetic Energy (eV)', fontsize=16)

        if self.cdx <= self.cdy:
            tx = np.linspace(min(self.z), max(self.z), self.cdensity)
        else:
            tx = np.linspace(min(self.x), max(self.x), self.cdensity)
        x, y = np.meshgrid(tx, self.ty)
        ax.pcolormesh(x, y, self.data_cut, cmap='gray')

        canvas = FigureCanvasTkAgg(fig, master=self)
        canvas.draw()
        self.x_cut = tx
        self.y_cut = self.ty
        self.angle_cut = self.angle
        self.phi_offset_cut = self.phi_offset
        self.r1_offset_cut = self.r1_offset

        del fig, ax
        gc.collect()

        canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)
        toolbar = NavigationToolbar2Tk(canvas, self)
        toolbar.update()
        toolbar.pack(side=tk.BOTTOM, fill=tk.BOTH, expand=1)

        save_button = tk.Button(self, text='Save', command=self.save_cut, bg='white', font=('Arial', 16, "bold"))
        save_button.pack(side=tk.BOTTOM)
        self.bind("<Return>", self.save_cut)
        self.focus_set()
        self.update()

    def save_cut(self, event=None):
        try:
            path = fd.asksaveasfilename(title="Save as", filetypes=(("HDF5 files", "*.h5"), ("NPZ files", "*.npz"),), initialdir=self.path[0], initialfile='data_cut', defaultextension=".h5")
            if not path:
                print('Save operation cancelled')
                return
            elif path.split('.')[-1] == 'npz':
                np.savez(path, path=self.path, data=self.data_cut, x=self.x_cut, y=self.y_cut, angle=self.angle_cut, cx=self.cx_cut, cy=self.cy_cut, cdx=self.cdx_cut, cdy=self.cdy_cut, phi_offset=self.phi_offset_cut, r1_offset=self.r1_offset_cut, e_photon=self.e_photon, slim=self.slim_cut, sym=self.sym_cut, desc=["Sliced data"])
            elif path.split('.')[-1] == 'h5':
                self.saveh5(path, path=self.path, data=self.data_cut, x=self.x_cut, y=self.y_cut, angle=self.angle_cut, cx=self.cx_cut, cy=self.cy_cut, cdx=self.cdx_cut, cdy=self.cdy_cut, phi_offset=self.phi_offset_cut, r1_offset=self.r1_offset_cut, e_photon=self.e_photon, slim=self.slim_cut, sym=self.sym_cut, desc=["Sliced data"])
            print('Data saved to %s'%path)
        except Exception as e:
            print(f"An error occurred: {e}")

    def on_closing(self):
        self.stop_event.clear()
        if self.pool:
            self.pool.terminate()
            print('Terminated')
            self.pool.join()
            print('Joined')
        self.destroy()
    
    def saveh5(self, tpath, path, data, x, y, angle, cx, cy, cdx, cdy, phi_offset, r1_offset, e_photon, slim, sym, desc):
        with h5py.File(tpath, 'w') as f:
            xsize = np.array([len(y)], dtype=int)
            f.create_dataset('Data/XSize/Value', data=xsize, dtype=int)
            ysize = np.array([len(x)], dtype=int)
            f.create_dataset('Data/YSize/Value', data=ysize, dtype=int)
            
            acquisition = [bytes('VolumeSlicer', 'utf-8')]
            acquisition = np.array(acquisition, dtype=h5py.special_dtype(vlen=str))
            f.create_dataset('Region/Acquisition', data=acquisition, dtype=h5py.special_dtype(vlen=str))
            center_energy = np.array([(y[-1]-y[0])/2], dtype=float)
            f.create_dataset('Region/CenterEnergy/Value', data=center_energy, dtype=float)
            description = np.array([bytes(desc[0], 'utf-8')], dtype=h5py.special_dtype(vlen=str))
            f.create_dataset('Region/Description', data=description, dtype=h5py.special_dtype(vlen=str))
            dwell = np.array([bytes('Unknown', 'utf-8')], dtype=h5py.special_dtype(vlen=str))
            f.create_dataset('Region/Dwell/Value', data=dwell, dtype=h5py.special_dtype(vlen=str))
            
            energy_mode = [bytes('Kinetic', 'utf-8')]
            energy_mode = np.array(energy_mode, dtype=h5py.special_dtype(vlen=str))
            f.create_dataset('Region/EnergyMode', data=energy_mode, dtype=h5py.special_dtype(vlen=str))
            excitation_energy = np.array([e_photon], dtype=float)
            f.create_dataset('Region/ExcitationEnergy/Value', data=excitation_energy, dtype=float)
            high_energy = np.array([y[-1]], dtype=float)
            f.create_dataset('Region/HighEnergy/Value', data=high_energy, dtype=float)
            iterations = np.array([bytes('Unknown', 'utf-8')], dtype=h5py.special_dtype(vlen=str))
            f.create_dataset('Region/Iterations/Value', data=iterations, dtype=h5py.special_dtype(vlen=str))
            
            lens_mode = [bytes('Angular', 'utf-8')]
            lens_mode = np.array(lens_mode, dtype=h5py.special_dtype(vlen=str))
            f.create_dataset('Region/LensMode', data=lens_mode, dtype=h5py.special_dtype(vlen=str))
            low_energy = np.array([y[0]], dtype=float)
            f.create_dataset('Region/LowEnergy/Value', data=low_energy, dtype=float)
            name = np.array([bytes(os.path.basename(tpath).removesuffix('.h5'), 'utf-8')], dtype=h5py.special_dtype(vlen=str))
            f.create_dataset('Region/Name', data=name, dtype=h5py.special_dtype(vlen=str))
            y_scale_max = np.array([x[-1]], dtype=float)
            f.create_dataset('Region/YScaleMax/Value', data=y_scale_max, dtype=float)
            y_scale_min = np.array([x[0]], dtype=float)
            f.create_dataset('Region/YScaleMin/Value', data=y_scale_min, dtype=float)
            pass_energy = np.array([bytes('Unknown', 'utf-8')], dtype=h5py.special_dtype(vlen=str))
            f.create_dataset('Region/PassEnergy/Value', data=pass_energy, dtype=h5py.special_dtype(vlen=str))
            step = np.array([y[1]-y[0]], dtype=float)
            f.create_dataset('Region/Step/Value', data=step, dtype=float)
            
            slit = [bytes('Unknown', 'utf-8')]
            slit = np.array(slit, dtype=h5py.special_dtype(vlen=str))
            f.create_dataset('Region/Slit', data=slit, dtype=h5py.special_dtype(vlen=str))
            
            # additional data
            path = np.array([bytes(i, 'utf-8') for i in path], dtype=h5py.special_dtype(vlen=str))
            f.create_dataset('VolumeSlicer/path', data=path)
            angle = np.array([angle], dtype=float)
            f.create_dataset('VolumeSlicer/angle', data=angle)
            cx = np.array([cx], dtype=float)
            f.create_dataset('VolumeSlicer/cx', data=cx)
            cy = np.array([cy], dtype=float)
            f.create_dataset('VolumeSlicer/cy', data=cy)
            cdx = np.array([cdx], dtype=float)
            f.create_dataset('VolumeSlicer/cdx', data=cdx)
            cdy = np.array([cdy], dtype=float)
            f.create_dataset('VolumeSlicer/cdy', data=cdy)
            phi_offset = np.array([phi_offset], dtype=float)
            f.create_dataset('VolumeSlicer/phi_offset', data=phi_offset)
            r1_offset = np.array([r1_offset], dtype=float)
            f.create_dataset('VolumeSlicer/r1_offset', data=r1_offset)
            slim = np.array([slim], dtype=int)
            f.create_dataset('VolumeSlicer/slim', data=slim)
            sym = np.array([sym], dtype=int)
            f.create_dataset('VolumeSlicer/sym', data=sym)
            
            f.create_dataset('Spectrum', data=np.array(data))
            
class wait(tk.Toplevel):
    def __init__(self, master):
        super().__init__(master, background = 'white')
        self.title('Info')
        self.geometry('400x200')
        self.resizable(False, False)
        tk.Label(self, bg='white', text='Please wait...', font=('Arial', 16, "bold")).pack(side=tk.TOP, pady=20)
        self.label_info = tk.Label(self, bg='white', text='', font=('Arial', 14))
        self.label_info.pack(side=tk.TOP, pady=20)
        self.grab_set()
        self.focus_set()
        self.update()
    
    def text(self, text):
        self.label_info.config(text=text)
        self.update_idletasks()
    
    def done(self):
        self.grab_release()
        self.destroy()
        del self
        gc.collect()

class VolumeSlicer(tk.Frame):
    def __init__(self, parent=None, path=None, volume=np.zeros((5,5,5), dtype=np.float64), cmap='gray', x=None, y=None, z=None, ev=None, e_photon=21.2, density=600):
        '''
        Args:
        ------
        parent: tk.Tk
        path: loadfiles.path
        volume: shape: (r1, phi, ev)
        
        Returns:
        ------
        None
        '''
        if parent is not None:
            super().__init__(parent, bg='white')
        if path is not None:
            self.path = path
        self.cmap=cmap
        # self.volume = volume    # data cube stored as a 3D numpy array
        self.slice_index = volume.shape[2] // 2
        self.angle = 0
        self.density = density
        self.ovolume = volume
        self.phi_offset = 48 # mm / 0 degree
        self.r1_offset = 11.5 # mm / -31 degree
        self.e_photon = e_photon
        self.z = None
        # base dimensions
        
        # temperaly window range set
        self.m=9.10938356e-31
        self.hbar=1.0545718e-34
        self.e=1.60217662e-19
        self.type = 'real'   # directly stack  'real', 'reciprocal'
        self.mode = 'normal'
        self.sym = 1
        
        if x is not None and y is not None:
            self.ox = np.float64(x)
            self.y = np.float64(y)
            if z is not None:
                self.z = np.float64(z)
            self.ev = np.float64(ev)
            self.slim = [0, 493]    # init phi slice range -10~10 degree or -2.5~2.5 mm
            # Create a figure and axis
            self.fig = plt.Figure(figsize=(9, 9),constrained_layout=True)
            self.ax = self.fig.add_subplot(111)
            self.ax.set_aspect('equal')
            # self.ax.set_xticks([])
            # self.ax.set_yticks([])
            self.fig.subplots_adjust(bottom=0.25)
            
            self.fig_region = plt.Figure(figsize=(4, 4),constrained_layout=True)
            self.ax_region = self.fig_region.add_subplot(111)
            self.fig_region.subplots_adjust(bottom=0.25)
            
            if self.type == 'real':
                self.ax.set_xlabel('x (mm)', fontsize=16)
                self.ax.set_ylabel('z (mm)', fontsize=16)
                if z is not None:
                    self.xmin = np.min(np.min(x)+np.min(z))
                    self.xmax = np.max(np.max(x)+np.max(z))
                else:
                    self.xmin = np.min(x)
                    self.xmax = np.max(x)
                self.ymin = np.min(y)
                self.ymax = np.max(y)
                if self.xmin+self.xmax > 2*self.phi_offset:
                    self.xmin = self.phi_offset-(self.xmax-self.phi_offset)
                if self.xmax+self.xmin < 2*self.phi_offset:
                    self.xmax = self.phi_offset-(self.xmin-self.phi_offset)
                if self.ymin+self.ymax > 2*self.r1_offset:
                    self.ymin = self.r1_offset-(self.ymax-self.r1_offset)
                if self.ymax+self.ymin < 2*self.r1_offset:
                    self.ymax = self.r1_offset-(self.ymin-self.r1_offset)
            elif self.type == 'reciprocal':
                self.ax.set_xlabel(r'kx ($\frac{2\pi}{\AA}$)', fontsize=16)
                self.ax.set_ylabel(r'ky ($\frac{2\pi}{\AA}$)', fontsize=16)
                self.set_xy_lim()
            
            self.fl_show = False
            # self.interpolate_slice(self.slice_index)
            self.surface = np.zeros((self.density, self.density))
            self.img = self.ax.imshow(self.surface, cmap=cmap, extent=[-1, 1, -1, 1], origin='lower')
            self.hl, = self.ax.plot([0, 0], [0, 0], color='green', linestyle='--')
            self.vl, = self.ax.plot([0, 0], [0, 0], color='green', linestyle='--')
            self.cut_l, = self.ax.plot([0, 0], [0, 0], color='red', linestyle='-')
            self.hl.set_data([],[])
            self.vl.set_data([],[])
            self.cut_l.set_data([], [])
            
            if parent is not None:
                self.fl_show = True     #flag to allow self.label_info window updating
                
                frame1 = tk.Frame(self, bg='white')
                frame1.grid(row=0, column=0)
                
                # Create a canvas and add it to the frame
                self.canvas = FigureCanvasTkAgg(self.fig, master=frame1)
                self.canvas.draw()
                self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)
                # self.canvas.get_tk_widget().grid(row=0, column=1)
                
                # Create a toolbar and add it to the frame
                self.toolbar = NavigationToolbar2Tk(self.canvas, frame1)
                self.toolbar.update()
                self.toolbar.pack(side=tk.BOTTOM, fill=tk.BOTH, expand=1)
                # self.toolbar.grid(row=1, column=0)
                
                frame2 = tk.Frame(self, bg='white')
                frame2.grid(row=0, column=1)
                
                frame_mode = tk.Frame(frame2, bg='white')
                frame_mode.pack(side=tk.TOP)
                self.b_mode = tk.Button(frame_mode, text='Transmission Mode', command=self.change_mode, bg='white', font=('Arial', 16, "bold"))
                self.b_mode.pack(side=tk.LEFT)
                label_d = tk.Label(frame_mode, text='Density:', bg='white', font=('Arial', 16, "bold")) 
                label_d.pack(side=tk.LEFT)
                self.entry_d = tk.Entry(frame_mode, bg='white', font=('Arial', 16, "bold"))
                self.entry_d.pack(side=tk.LEFT)
                self.entry_d.insert(0, str(self.density))
                self.b_d = tk.Button(frame_mode, text='Set Density', command=self.set_density, bg='white', font=('Arial', 16, "bold"))
                self.b_d.pack(side=tk.LEFT)
                
                
                frame_entry1 = tk.Frame(frame2, bg='white')
                frame_entry1.pack(side=tk.TOP)
                label_info = tk.Label(frame_entry1, text="Set Slit Slice Range (0-493 for initial range)", bg='white', font=('Arial', 14, "bold"))
                label_info.pack(side=tk.TOP)
                
                # Create entries and button to set self.slim
                label_min = tk.Label(frame_entry1, text="Min:", bg='white', font=('Arial', 14, "bold"))
                label_min.pack(side=tk.LEFT)
                self.entry_min = tk.Entry(frame_entry1, bg='white', font=('Arial', 14, "bold"))
                self.entry_min.pack(side=tk.LEFT)
                self.entry_min.insert(0, str(self.slim[0]))

                label_max = tk.Label(frame_entry1, text="Max:", bg='white', font=('Arial', 14, "bold"))
                label_max.pack(side=tk.LEFT)
                self.entry_max = tk.Entry(frame_entry1, bg='white', font=('Arial', 14, "bold"))
                self.entry_max.pack(side=tk.LEFT)
                self.entry_max.insert(0, str(self.slim[1]))

                self.set_slim_button = tk.Button(frame_entry1, text="Set Limit", command=self.set_slim, font=('Arial', 14, "bold"), bg='white')
                self.set_slim_button.pack(side=tk.LEFT)
                
                frame_entry2 = tk.Frame(frame2, bg='white')
                frame_entry2.pack(side=tk.TOP)
                # Create labels and entries for window range
                label_xmin = tk.Label(frame_entry2, text="X Min:", bg='white', font=('Arial', 14, "bold"))
                label_xmin.pack(side=tk.LEFT)
                self.entry_xmin = tk.Entry(frame_entry2, bg='white', font=('Arial', 14, "bold"))
                self.entry_xmin.pack(side=tk.LEFT)
                self.entry_xmin.insert(0, str(self.ymin))
                self.entry_xmin.config(state='disabled')

                label_xmax = tk.Label(frame_entry2, text="X Max:", bg='white', font=('Arial', 14, "bold"))
                label_xmax.pack(side=tk.LEFT)
                self.entry_xmax = tk.Entry(frame_entry2, bg='white', font=('Arial', 14, "bold"))
                self.entry_xmax.pack(side=tk.LEFT)
                self.entry_xmax.insert(0, str(self.ymax))
                self.entry_xmax.config(state='disabled')

                frame_entry3 = tk.Frame(frame2, bg='white')
                frame_entry3.pack(side=tk.TOP)

                label_ymin = tk.Label(frame_entry3, text="Y Min:", bg='white', font=('Arial', 14, "bold"))
                label_ymin.pack(side=tk.LEFT)
                self.entry_ymin = tk.Entry(frame_entry3, bg='white', font=('Arial', 14, "bold"))
                self.entry_ymin.pack(side=tk.LEFT)
                self.entry_ymin.insert(0, str(self.xmin))
                self.entry_ymin.config(state='disabled')

                label_ymax = tk.Label(frame_entry3, text="Y Max:", bg='white', font=('Arial', 14, "bold"))
                label_ymax.pack(side=tk.LEFT)
                self.entry_ymax = tk.Entry(frame_entry3, bg='white', font=('Arial', 14, "bold"))
                self.entry_ymax.pack(side=tk.LEFT)
                self.entry_ymax.insert(0, str(self.xmax))
                self.entry_ymax.config(state='disabled')

                self.win_sym_frame = tk.Frame(frame2, bg='white')
                self.win_sym_frame.pack(side=tk.TOP)
                self.set_window_button = tk.Button(self.win_sym_frame, text="Set Window Range", command=self.set_window, font=('Arial', 14, "bold"), bg='white')
                self.set_window_button.pack(side=tk.LEFT)
                self.set_sym_button = tk.Button(self.win_sym_frame, text="Symmetrical extend", command=self.symmetry, font=('Arial', 14, "bold"), bg='white')
                
                self.frame_region = tk.Frame(frame2, bg='white')
                # self.frame_region.pack(side=tk.TOP)
                self.canvas_region = FigureCanvasTkAgg(self.fig_region, master=self.frame_region)
                self.canvas_region.draw()
                self.canvas_region.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)
                self.pr_disp_region()
                
                frame_entry4 = tk.Frame(frame2, bg='white')
                frame_entry4.pack(side=tk.TOP)
                self.label_phi_offset = tk.Label(frame_entry4, text="Set Z Offset (mm):", bg='white', font=('Arial', 14, "bold"))
                self.label_phi_offset.pack(side=tk.LEFT)
                self.entry_phi_offset = tk.Entry(frame_entry4, bg='white', font=('Arial', 14, "bold"), state='normal')
                self.entry_phi_offset.pack(side=tk.LEFT)
                self.entry_phi_offset.insert(0, str(self.phi_offset))
                
                frame_entry5 = tk.Frame(frame2, bg='white')
                frame_entry5.pack(side=tk.TOP)
                self.label_r1_offset = tk.Label(frame_entry5, text="Set X Offset (mm):", bg='white', font=('Arial', 14, "bold"))
                self.label_r1_offset.pack(side=tk.LEFT)
                self.entry_r1_offset = tk.Entry(frame_entry5, bg='white', font=('Arial', 14, "bold"), state='normal')
                self.entry_r1_offset.pack(side=tk.LEFT)
                self.entry_r1_offset.insert(0, str(self.r1_offset))
                
                self.fig1 = plt.Figure(figsize=(5, 0.5),constrained_layout=True)
                self.ax_slider = self.fig1.add_axes([0.2, 0.6, 0.8, 0.3])
                self.slider = Slider(self.ax_slider, 'Energy', self.ev[0], self.ev[-1], valinit=self.ev[self.slice_index], valstep=self.ev[1]-self.ev[0])
                self.slider.on_changed(self.set_sl)

                self.ax_angle_slider = self.fig1.add_axes([0.2, 0.1, 0.8, 0.3])
                self.angle_slider = Slider(self.ax_angle_slider, 'Angle', 0, 360, valinit=self.angle, valstep=0.001)
                self.angle_slider.on_changed(self.set_angle_sl)                
                
                self.ea_frame = tk.Frame(frame2, bg='white')
                self.ea_frame.pack(side=tk.TOP)
                self.ea_text_frame = tk.Frame(self.ea_frame, bg='white')
                self.ea_text_frame.pack(side=tk.LEFT)
                self.text_e = tk.StringVar()
                self.text_e.set(str(f'%.3f'%self.ev[self.slice_index]))
                self.text_e.trace_add('write', self.set_tx)
                self.text = tk.Entry(self.ea_text_frame, bg='white', textvariable=self.text_e, font=('Arial', 12, "bold"), state='normal', width=7).pack(side=tk.TOP)
                self.text_a = tk.StringVar()
                self.text_a.set(str(self.angle))
                self.text_a.trace_add('write', self.set_angle_tx)
                self.text_ang = tk.Entry(self.ea_text_frame, bg='white', textvariable=self.text_a, font=('Arial', 12, "bold"), state='normal', width=7).pack(side=tk.TOP)
                
                self.canvas1 = FigureCanvasTkAgg(self.fig1, master=self.ea_frame)
                self.canvas1.draw()
                self.canvas1.get_tk_widget().pack(side=tk.LEFT, fill=tk.BOTH, expand=1, before=self.ea_text_frame)
                
                self.frame_cut_xy = tk.Frame(frame2, bg='white')
                frame_xy = tk.Frame(self.frame_cut_xy, bg='white')
                frame_xy.pack(side=tk.TOP)
                self.cut_xy_x_label = tk.Label(frame_xy, text="kx:", bg='white', font=('Arial', 14, "bold"))
                self.cut_xy_x_label.pack(side=tk.LEFT)
                self.cut_xy_x_entry = tk.Entry(frame_xy, bg='white', font=('Arial', 14, "bold"))
                self.cut_xy_x_entry.pack(side=tk.LEFT)
                self.cut_xy_x_entry.insert(0, '0')
                self.cut_xy_y_label = tk.Label(frame_xy, text="ky:", bg='white', font=('Arial', 14, "bold"))
                self.cut_xy_y_label.pack(side=tk.LEFT)
                self.cut_xy_y_entry = tk.Entry(frame_xy, bg='white', font=('Arial', 14, "bold"))
                self.cut_xy_y_entry.pack(side=tk.LEFT)
                self.cut_xy_y_entry.insert(0, '0')
                
                frame_dxy = tk.Frame(self.frame_cut_xy, bg='white')
                frame_dxy.pack(side=tk.TOP)
                self.cut_xy_dx_label = tk.Label(frame_dxy, text="kx bin:", bg='white', font=('Arial', 14, "bold"))
                self.cut_xy_dx_label.pack(side=tk.LEFT)
                self.cut_xy_dx_entry = tk.Entry(frame_dxy, bg='white', font=('Arial', 14, "bold"))
                self.cut_xy_dx_entry.pack(side=tk.LEFT)
                self.cut_xy_dx_entry.insert(0, '0.05')
                self.cut_xy_dy_label = tk.Label(frame_dxy, text="ky bin:", bg='white', font=('Arial', 14, "bold"))
                self.cut_xy_dy_label.pack(side=tk.LEFT)
                self.cut_xy_dy_entry = tk.Entry(frame_dxy, bg='white', font=('Arial', 14, "bold"))
                self.cut_xy_dy_entry.pack(side=tk.LEFT)
                self.cut_xy_dy_entry.insert(0, '0.4')
                
                frame_cut_button = tk.Frame(self.frame_cut_xy, bg='white')
                frame_cut_button.pack(side=tk.TOP,anchor='center')
                b_cut = tk.Button(frame_cut_button, text='Cut', command=self.cut_xy, bg='white', font=('Arial', 14, "bold"))
                b_cut.pack(side=tk.LEFT)
                b_cut_plot = tk.Button(frame_cut_button, text='Plot', command=self.pr_cut_plot, bg='white', font=('Arial', 14, "bold"))
                b_cut_plot.pack(side=tk.RIGHT)
    
    def symmetry(self):
        self.sym_g = tk.Toplevel(self, background='white')
        self.sym_g.title('Symmetry')
        self.sym_g.resizable(False, False)
        tk.Button(self.sym_g, text='2-fold symmetry', command=self.symmetry_2, bg='white', font=('Arial', 16, "bold")).pack(side=tk.TOP, pady=5)
        tk.Button(self.sym_g, text='3-fold symmetry', command=self.symmetry_3, bg='white', font=('Arial', 16, "bold")).pack(side=tk.TOP, pady=5)
        tk.Button(self.sym_g, text='4-fold symmetry', command=self.symmetry_4, bg='white', font=('Arial', 16, "bold")).pack(side=tk.TOP, pady=5)
        self.sym_g.update()        
    
    def gen_sym(self, n):
        try:
            self.sym_g.destroy()
        except:
            pass
        if n != 1:
            self.sym = n
            osurface = self.surface.copy()
            tmin = np.min(osurface[osurface>0])
            osurface[osurface < tmin-tmin/3] = np.nan
            for i in range(n-1):
                surface = rotate(self.surface, 360//n*(i+1), self.surface.shape)
                surface[surface < tmin-tmin/3] = np.nan
                osurface = np.nanmean([osurface, surface], axis=0)
            self.surface = np.nan_to_num(osurface)
            rotated_surface = rotate(self.surface, -self.angle, self.surface.shape)
            self.img.set_data(rotated_surface)
            copy_to_clipboard(self.fig)
            self.canvas.draw()
            
    def symmetry_2(self):
        self.gen_sym(2)
    
    def symmetry_3(self):
        self.gen_sym(3)
        
    def symmetry_4(self):
        self.gen_sym(4)
        
    def set_xy_lim(self):
        '''
        Input: self.x, self.y, self.r1_offset, self.phi_offset, self.e_photon
        Return: self.xmin, self.xmax, self.ymin, self.ymax
        '''
        r1 = self.y - self.r1_offset
        phi = self.x - self.phi_offset
        # r = np.sqrt(2*self.m*self.e*self.e_photon)/self.hbar*10**-10*(np.max(np.abs(np.sin(r1/180*np.pi)))**2+np.max(np.abs(np.sin(phi/180*np.pi)))**2)**0.5
        tr1, tphi = self.rot(np.max(np.abs(r1)), np.max(np.abs(phi)), 0, 0, 0)
        tx = np.sqrt(2*self.m*self.e*self.e_photon)/self.hbar*10**-10*np.sin(tr1/180*np.pi) * np.cos(tphi/180*np.pi)
        ty = np.sqrt(2*self.m*self.e*self.e_photon)/self.hbar*10**-10*np.sin(tphi/180*np.pi)
        r = np.sqrt(tx**2 + ty**2)
        self.xmin, self.xmax = -r, r
        self.ymin, self.ymax = -r, r
        
    def cut_xy(self):
        cx = np.float64(self.cut_xy_x_entry.get())
        cy = np.float64(self.cut_xy_y_entry.get())
        cdx = np.float64(self.cut_xy_dx_entry.get())
        cdy = np.float64(self.cut_xy_dy_entry.get())
        if cx-cdx/2 < self.ymin or cx+cdx/2 > self.ymax or cy-cdy/2 < self.xmin or cy+cdy/2 > self.xmax:
            if cx-cdx/2 < self.ymin:
                cdx = (cx-self.ymin)*2
            elif cx+cdx/2 > self.ymax:
                cdx = (self.ymax-cx)*2
            if cy-cdy/2 < self.xmin:
                cdy = (cy-self.xmin)*2
            elif cy+cdy/2 > self.xmax:
                cdy = (self.xmax-cy)*2
        self.cut_xy_dx_entry.delete(0, tk.END)
        self.cut_xy_dx_entry.insert(0, str(cdx))
        self.cut_xy_dy_entry.delete(0, tk.END)
        self.cut_xy_dy_entry.insert(0, str(cdy))
        self.cx = cx
        self.cy = cy
        self.cdx = cdx
        self.cdy = cdy
        self.cut_l.set_data([self.cx-self.cdx/2, self.cx+self.cdx/2, self.cx+self.cdx/2, self.cx-self.cdx/2, self.cx-self.cdx/2], [self.cy-self.cdy/2, self.cy-self.cdy/2, self.cy+self.cdy/2, self.cy+self.cdy/2, self.cy-self.cdy/2])
        self.canvas.draw()
    
    def k_map(self, data, density, xlim, ylim, kxlim, kylim, ev):
        ky_grid, kx_grid = np.meshgrid(
        np.linspace(kylim[0], kylim[1], int(density/180*(xlim[1]-xlim[0]))*4),
        np.linspace(kxlim[0], kxlim[1], int(density/180*(xlim[1]-xlim[0]))*4),
        indexing='ij'
        )
        Phi_target = np.arcsin(np.clip(ky_grid / np.sqrt(2*self.m*self.e*ev)*self.hbar*1e10, -1, 1)) * 180 / np.pi
        cos_phi = np.cos(np.deg2rad(Phi_target))
        cos_phi[cos_phi == 0] = 1e-8
        R1_target = np.arcsin(np.clip(kx_grid / (np.sqrt(2*self.m*self.e*ev)/self.hbar*1e-10 * cos_phi), -1, 1)) * 180 / np.pi            
        map_y = (R1_target - xlim[0]) / (xlim[1] - xlim[0]) * (data.shape[0] - 1)
        map_x = (Phi_target - ylim[0]) / (ylim[1] - ylim[0]) * (data.shape[1] - 1)
        valid_mask = (
            (R1_target >= xlim[0]) & (R1_target <= xlim[1]) &
            (Phi_target >= ylim[0]) & (Phi_target <= ylim[1]) &
            np.isfinite(map_x) & np.isfinite(map_y)
        )
        map_x[~np.isfinite(map_x)] = 0
        map_y[~np.isfinite(map_y)] = 0
        map_x = np.clip(map_x, 0, data.shape[1] - 1).astype(np.float32)
        map_y = np.clip(map_y, 0, data.shape[0] - 1).astype(np.float32)
        data = cv2.remap(data.astype(np.float32), map_x, map_y, interpolation=cv2.INTER_CUBIC, borderMode=cv2.BORDER_CONSTANT, borderValue=0)
        data[~valid_mask] = 0
        data = cv2.resize(data, (int(density/(self.xmax-self.xmin)*(kxlim[1]-kxlim[0])), int(density/(self.ymax-self.ymin)*(kylim[1]-kylim[0]))), interpolation=cv2.INTER_CUBIC)
        return data
    
    def combine_slice(self, data, xlim, ylim, r2=None, ev=None, step=0.25):  # complete
        '''
        Args:
        ---
        data: raw image (shape:(len(r1), len(phi)))
        xlim: [min, max]  x: r1
        ylim: [min, max]  y: phi
        step: width for only one r1 cube (default: 0.25 degree/mm)
        
        return:
        ---
        image
        shape: (density, density)
        '''
        xlim, ylim = sorted(xlim), sorted(ylim)
        fr2 = True
        if self.type == 'real':
            if int(self.cdensity/(self.ymax-self.ymin)*(xlim[1]-xlim[0])) ==0:
                xlim[1] += step
                xlim[0] -= step
            base = np.zeros((self.cdensity, self.cdensity))
            data = cv2.resize(data, (int(self.cdensity/(self.xmax-self.xmin)*(ylim[1]-ylim[0])), int(self.cdensity/(self.ymax-self.ymin)*(xlim[1]-xlim[0]))), interpolation=cv2.INTER_CUBIC)
            base[0:data.shape[0], 0:data.shape[1]] = data
            data = np.roll(base.T, (int((ylim[0]-self.xmin)/(self.xmax-self.xmin)*self.cdensity), int((xlim[0]-self.ymin)/(self.ymax-self.ymin)*self.cdensity)), axis=(0, 1))
            data = data
        elif self.type == 'reciprocal':
            if r2 is None:
                fr2=False
                r2, self.z = 0, [0, 0]
            if int(self.cdensity/180*(xlim[1]-xlim[0])) ==0: # at least 1 pixel
                d = 1/self.cdensity*180/2
                c = (xlim[0]+xlim[1])/2
                xlim = [float(c-d), float(c+d)]
                if self.cut_show:
                    print(f'Warning: R1-axis density is too low (R2=%.2f)'%r2)
                    print('in combine_slice')
            base = np.zeros((self.cdensity, self.cdensity))
            r1 = np.linspace(xlim[0], xlim[1], int(self.cdensity/180*(xlim[1]-xlim[0])+1))
            phi = np.linspace(ylim[0], ylim[1], int(self.cdensity/180*(ylim[1]-ylim[0])))
            r1, phi = np.meshgrid(r1, phi)
            x = np.sqrt(2*self.m*self.e*ev)/self.hbar*10**-10*np.sin(r1/180*np.pi) * np.cos(phi/180*np.pi)  # x: r1, y: phi, at r2=0
            y = np.sqrt(2*self.m*self.e*ev)/self.hbar*10**-10*np.sin(phi/180*np.pi)
            txlim, tylim = [np.min(x), np.max(x)], [np.min(y), np.max(y)]
            ####### new method start
            data = self.k_map(data, self.cdensity, xlim, ylim, txlim, tylim, ev)
            ####################### new method end
            
            ############## original method start
            # tmax = np.max(data)
            # fig, ax = plt.subplots(dpi=150)
            # fig.patch.set_facecolor('black')
            # ax.set_facecolor('black')
            # data = cv2.resize(data, (int(self.cdensity/180*(ylim[1]-ylim[0])), int(self.cdensity/180*(xlim[1]-xlim[0])+1)), interpolation=cv2.INTER_CUBIC)
            # ax.pcolormesh(x, y, data.T, cmap='gray')    # compatible with r2=0, phi: yaxis, r1: xaxis in transmission mode
            # ax.set_position([0, 0, 1, 1])
            # ax.axis('off')
            # fig.canvas.draw()
            # image_from_plot = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)
            # image_from_plot = image_from_plot.reshape(fig.canvas.get_width_height()[::-1] + (3,))
            # plt.close()
            # del fig, ax
            # image_gray = cv2.cvtColor(image_from_plot, cv2.COLOR_RGB2GRAY)/255*tmax
            # image_gray = cv2.resize(image_gray[::-1,:], (data.shape[1],data.shape[0]), interpolation=cv2.INTER_CUBIC)
            # data = cv2.resize(image_gray, (int(self.cdensity/(self.xmax-self.xmin)*(txlim[1]-txlim[0])), int(self.cdensity/(self.ymax-self.ymin)*(tylim[1]-tylim[0]))), interpolation=cv2.INTER_CUBIC)
            ########### original method end
            base[0:data.shape[0], 0:data.shape[1]] = data
            # del image_from_plot, image_gray, data
            del data
            data = np.roll(base, (int((tylim[0]-self.ymin)/(self.ymax-self.ymin)*self.cdensity), int((txlim[0]-self.xmin)/(self.xmax-self.xmin)*self.cdensity)), axis=(0, 1))
            # data = data[::-1, :]
            del base
            gc.collect()
            data = rotate(data, r2-self.z[0], data.shape)
            
            if not fr2:
                self.z = None
        if self.z is not None and fr2==True:  # for multiple cubes need np.nanmean
            msk = data<self.tmin-self.tmin/3
            data[msk] = np.nan
            
        return data
    
    def slice_data(self, i, angle=0, phi_offset=0, r1_offset=-31, self_x=None, self_volume=None, xlim=None, zlim=None):
        """
        Args
        ------
        self_x : phi-axis, slit limit
        self_volume : 3D numpy array, shape: (r1, phi, ev)
        angle : rotation angle
        xlim : cutting kx lim after rotation, [min, max]
        zlim : cutting ky lim after rotation, [min, max]
        """
        def filter(ind, ii, r2=None):
            r1 = np.linspace(min(self.y[ind]), max(self.y[ind]), len(self.y[ind]))
            phi = np.linspace(min(self_x), max(self_x), len(self_x))
            r1, phi = np.meshgrid(r1, phi)
            for i in range(self.sym):
                if r2 is None:
                    r1, phi = self.rot(r1, phi, r1_offset, phi_offset, angle-360//self.sym*i)
                else:
                    r1, phi = self.rot(r1, phi, r1_offset, phi_offset, angle-(r2-self.z[0])-360//self.sym*i)
                if i == 0:
                    x = np.sqrt(2*self.m*self.e*self.ev[ii])/self.hbar*10**-10*np.sin(r1/180*np.pi) * np.cos(phi/180*np.pi)  # x: r1, y: phi, at r2=0
                    y = np.sqrt(2*self.m*self.e*self.ev[ii])/self.hbar*10**-10*np.sin(phi/180*np.pi)
                else:
                    x = np.append(x, np.sqrt(2*self.m*self.e*self.ev[ii])/self.hbar*10**-10*np.sin(r1/180*np.pi) * np.cos(phi/180*np.pi), axis=0)
                    y = np.append(y, np.sqrt(2*self.m*self.e*self.ev[ii])/self.hbar*10**-10*np.sin(phi/180*np.pi), axis=0)
            ti=[]
            for i in range(r1.shape[1]):
                if any(xlim[0]<x[:,i]) and any(zlim[0]<y[:,i]) and any(x[:,i]<xlim[1]) and any(y[:,i]<zlim[1]):
                    ti.append(i)
            if len(ti) != 0:
                if min(ti)>0:
                    ti.insert(0, min(ti)-1)
                if max(ti)<len(self.y[ind])-1:
                    ti.append(max(ti)+1)
            return ind[ti]
        self.cut_show = False
        if i ==100:
            self.cut_show = True
        xlim, zlim = sorted(xlim), sorted(zlim)
        if self.z is None: # for 1 cube
            ind = filter(np.arange(len(self.y)), i)
            if len(ind) != 0:
                surface = self.combine_slice(self_volume[ind, :, i], xlim = [min(self.y[ind])-r1_offset, max(self.y[ind])-r1_offset], ylim = [min(self_x)-phi_offset, max(self_x)-phi_offset], ev=self.ev[i])
            else:
                surface = self.combine_slice(self_volume[:, :, i], xlim = [min(self.y)-r1_offset, max(self.y)-r1_offset], ylim = [min(self_x)-phi_offset, max(self_x)-phi_offset], ev=self.ev[i])
        elif self.z is not None: # for multiple cubes
            img = self_volume[:, :, i]
            try:
                self.tmin = np.min(img[img>0])
                r2 = sorted(set(self.z))
                surface = np.full((self.cdensity, self.cdensity), np.nan, dtype=np.float64)
                for z in r2:
                    ind = np.array(np.argwhere(self.z==z), dtype=np.int64).flatten()
                    ind = filter(ind, i, r2=z)
                    if len(ind) != 0:
                        surface = np.nanmean([surface, self.combine_slice(self_volume[ind, :, i], xlim = [min(self.y[ind])-r1_offset, max(self.y[ind])-r1_offset], ylim = [min(self_x)-phi_offset, max(self_x)-phi_offset], r2=z, ev=self.ev[i])], axis=0)
                surface = np.nan_to_num(surface)
            except:
                surface = np.zeros((self.cdensity, self.cdensity))
        surface = rotate(surface, -angle, surface.shape)
        osurface = surface.copy()
        try:
            tmin = np.min(osurface[osurface>0])
            for ii in range(self.sym-1):
                rotated_surface = rotate(surface, 360//self.sym*(ii+1), surface.shape)
                rotated_surface[rotated_surface < tmin-tmin/3] = np.nan
                osurface = np.nanmean([osurface, rotated_surface], axis=0)
                del rotated_surface
                gc.collect()
            del surface
            gc.collect()
            osurface[osurface < tmin-tmin/3] = np.nan
            surface = np.nan_to_num(osurface)
        except:
            surface = np.zeros((self.cdensity, self.cdensity))
        return surface
    
    def listen_for_stop_command(self):
        command = input()
        if command.strip().lower() == '':
            self.stop_event.set()
            if self.pool:
                self.pool.terminate()
                self.pool.join()
                self.pool = None
    
    def t_cut_job_y(self):
        angle = self.angle
        x = [self.cx-self.cdx/2, self.cx+self.cdx/2]
        z = [self.cy-self.cdy/2, self.cy+self.cdy/2]
        phi_offset = self.phi_offset
        r1_offset = self.r1_offset
        self_x = self.ox[self.slim[0]:self.slim[1]+1]
        self_volume = self.ovolume[:, self.slim[0]:self.slim[1]+1, :]
        self.set_xy_lim()
        try:
            with Pool(self.pool_size) as self.pool:
                args = [(i, angle, phi_offset, r1_offset, self_x, self_volume, self.cdensity, self.xmax, self.xmin, self.ymax, self.ymin, z, x, self.z, self.y, self.ev, self.e_photon, self.sym) for i in range(len(self.ev))]
                for i, result in enumerate(tqdm.tqdm(self.pool.imap(cut_job_y, args), total=len(self.ev), desc="Processing", file=sys.stdout, colour='blue')):
                    self.data_cut[i, :] = result[1]
                    if self.stop_event.is_set():
                        break
                if not self.stop_event.is_set():
                    print("\n\033[32mPress \033[31m'Enter' \033[32mto coninue...\033[0m")
        except Exception as e:
                print(f"An error occurred: {e}")
        finally:
            if self.pool:
                self.pool.close()
                self.pool.join()
                    
    def t_cut_job_x(self):
        angle = self.angle
        x = [self.cx-self.cdx/2, self.cx+self.cdx/2]
        z = [self.cy-self.cdy/2, self.cy+self.cdy/2]
        phi_offset = self.phi_offset
        r1_offset = self.r1_offset
        self_x = self.ox[self.slim[0]:self.slim[1]+1]
        self_volume = self.ovolume[:, self.slim[0]:self.slim[1]+1, :]
        self.set_xy_lim()
        try:
            with Pool(self.pool_size) as self.pool:
                args = [(i, angle, phi_offset, r1_offset, self_x, self_volume, self.cdensity, self.xmax, self.xmin, self.ymax, self.ymin, z, x, self.z, self.y, self.ev, self.e_photon, self.sym) for i in range(len(self.ev))]
                for i, result in enumerate(tqdm.tqdm(self.pool.imap(cut_job_x, args), total=len(self.ev), desc="Processing", file=sys.stdout, colour='blue')):
                    self.data_cut[i, :] = result[1]
                    if self.stop_event.is_set():
                        break
                if not self.stop_event.is_set():
                    print("\n\033[32mPress \033[31m'Enter' \033[32mto coninue...\033[0m")
        except Exception as e:
                print(f"An error occurred: {e}")
        finally:
            if self.pool:
                self.pool.close()
                self.pool.join()
    
    def confirm_cut(self, *args):
        self.pr_cut_g.destroy()
        self.cut_plot()
    
    def pr_cut_plot(self):
        if self.sym != 1:
            self.pr_cut_g = tk.Toplevel(self, background='white')
            self.pr_cut_g.title('Info')
            self.pr_cut_g.resizable(False, False)
            tk.Label(self.pr_cut_g, bg='white', text=f'Using {self.sym}-fold symmetry', font=('Arial', 16, "bold")).pack(side=tk.TOP, padx=10, pady=10)
            tk.Button(self.pr_cut_g, text='OK', command=self.confirm_cut, bg='white', font=('Arial', 16, "bold")).pack(side=tk.TOP, pady=10)
            self.pr_cut_g.bind("<Return>", self.confirm_cut)
            self.pr_cut_g.focus_set()
            self.pr_cut_g.update()
        else:
            self.cut_plot()
            
    
    def cut_plot(self):
        hwnd = windll.user32.FindWindowW(None, "C:\\Windows\\system32\\cmd.exe")
        if hwnd:
            windll.user32.SetForegroundWindow(hwnd)
        self.stop_event = threading.Event()
        t1 = threading.Thread(target=self.listen_for_stop_command, daemon=True)
        t1.start()
        self.cdensity = int((self.xmax-self.xmin)//2e-3)
        print('\nSampling Density: \033[31m500 per 2pi/Angstrom')
        print('\033[0mProcessing \033[32m%d x %d x %d \033[0msize data cube'%(self.cdensity, self.cdensity, len(self.ev)))
        print('\n\033[33mProcessor:\033[36m',cpuinfo.get_cpu_info()['brand_raw'])
        self.pool_size = max(1, int(psutil.cpu_count(logical=False)/4*3))
        print('\033[33mPhysical CPU cores:\033[36m', psutil.cpu_count(logical=False))
        print('\033[33mUsing \033[36m%d \033[33mcores\033[0m'%self.pool_size)
        print('\033[0mPlease wait...\n')
        print('\033[32mIf you want to stop the process, wait for 20 seconds and try.\nBut sometimes it may not work.\033[0m')
        print('\nThe following shows the progress bar and the estimation of the processing time')
        angle = self.angle
        self.cx_cut = self.cx
        self.cy_cut = self.cy
        self.cdx_cut = self.cdx
        self.cdy_cut = self.cdy
        x = [self.cx-self.cdx/2, self.cx+self.cdx/2]
        z = [self.cy-self.cdy/2, self.cy+self.cdy/2]
        ty = self.ev
        self.data_cut = np.zeros((len(ty), self.cdensity), dtype=np.float64)
        phi_offset = self.phi_offset
        r1_offset = self.r1_offset
        self.slim_cut = self.slim.copy()
        self.sym_cut = self.sym
        self_x = self.ox[self.slim[0]:self.slim[1]+1]   # -----stable version no multiprocessing-----
        self_volume = self.ovolume[:, self.slim[0]:self.slim[1]+1, :]   # -----stable version no multiprocessing-----
        if self.cdx<=self.cdy:  # cut along ky
            
            # -----stable version no multiprocessing-----
            # for i in range(len(y)):
            #     surface = self.slice_data(i, angle, phi_offset, r1_offset, self_x, self_volume)
            #     td = surface[int(self.cdensity/(self.xmax-self.xmin)*(min(z)-self.xmin)):int(self.cdensity/(self.xmax-self.xmin)*(max(z)-self.xmin)), int(self.cdensity/(self.ymax-self.ymin)*(min(x)-self.ymin)):int(self.cdensity/(self.ymax-self.ymin)*(max(x)-self.ymin))]
            #     del surface
            #     td = cv2.resize(td, (td.shape[0], self.cdensity), interpolation=cv2.INTER_CUBIC)
            #     data[i,:] = td.mean(axis=1)
            #     del td
            #     gc.collect()
            # -----stable version no multiprocessing-----
            
            self.t = threading.Thread(target=self.t_cut_job_x, daemon=True)
            self.t.start()
        else:   # cut along kx
            self.t = threading.Thread(target=self.t_cut_job_y, daemon=True)
            self.t.start()
        time.sleep(20)
        print("\n\033[32m-----Press \033[31m'Enter' \033[32mto terminate the pool-----\033[0m\n")
        t1.join()
        self.t.join()
        print('done')
        g_cut_plot(self, self.data_cut, self.cx, self.cy, self.cdx, self.cdy, self.cdensity, ty, z, x, angle, phi_offset, r1_offset, self.stop_event, self.pool, self.path, self.e_photon, self.slim_cut, self.sym_cut)
        
    def set_density(self, *args):
        try:
            self.density = int(self.entry_d.get())
            self.update()
        except ValueError:
            print("Invalid input for density value")
            
    def change_mode(self, mode='normal'):
        self.mode = mode
        self.__get_slim()
        self.x = self.ox[self.slim[0]:self.slim[1]+1]
        if self.type == 'real':
            try:
                self.type = 'reciprocal'
                self.phi_offset = 0
                self.r1_offset = -31
                r1 = self.y - self.r1_offset
                phi = self.x - self.phi_offset
                # r = np.sqrt(2*self.m*self.e*self.ev[self.slice_index])/self.hbar*10**-10*(np.max(np.abs(np.sin(r1/180*np.pi)))**2+np.max(np.abs(np.sin(phi/180*np.pi)))**2)**0.5
                tr1, tphi = self.rot(np.max(np.abs(r1)), np.max(np.abs(phi)), 0, 0, 0)
                tx = np.sqrt(2*self.m*self.e*self.ev[self.slice_index])/self.hbar*10**-10*np.sin(tr1/180*np.pi) * np.cos(tphi/180*np.pi)
                ty = np.sqrt(2*self.m*self.e*self.ev[self.slice_index])/self.hbar*10**-10*np.sin(tphi/180*np.pi)
                r = np.sqrt(tx**2 + ty**2)
                self.xmin, self.xmax = -r, r
                self.ymin, self.ymax = -r, r
                self.txlim, self.tylim = [-r, r], [-r, r]
                self.frame_region.pack(side=tk.TOP)
                self.b_mode.config(text='Reciprocal Mode')
                self.label_phi_offset.config(text="Set Phi Offset (degree):")
                self.label_r1_offset.config(text="Set R1 Offset (degree):")
                self.frame_cut_xy.pack(side=tk.TOP)
                self.set_sym_button.pack(side=tk.LEFT, after=self.set_window_button)
                if mode == 'normal':
                    self.update_window()
            except:
                self.type = 'real'
                if self.z is not None:
                    self.xmin = np.min(np.min(self.x)+np.min(self.z))
                    self.xmax = np.max(np.max(self.x)+np.max(self.z))
                else:
                    self.xmin = np.min(self.x)
                    self.xmax = np.max(self.x)
                self.ymin = np.min(self.y)
                self.ymax = np.max(self.y)
                self.phi_offset = 48
                self.r1_offset = 11.5
                if self.xmin+self.xmax > 2*self.phi_offset:
                    self.xmin = self.phi_offset-(self.xmax-self.phi_offset)
                if self.xmax+self.xmin < 2*self.phi_offset:
                    self.xmax = self.phi_offset-(self.xmin-self.phi_offset)
                if self.ymin+self.ymax > 2*self.r1_offset:
                    self.ymin = self.r1_offset-(self.ymax-self.r1_offset)
                if self.ymax+self.ymin < 2*self.r1_offset:
                    self.ymax = self.r1_offset-(self.ymin-self.r1_offset)
                self.ax.set_xlabel('x (mm)', fontsize=16)
                self.ax.set_ylabel('z (mm)', fontsize=16)
                self.b_mode.config(text='Transmission Mode')
                self.label_phi_offset.config(text="Set Z Offset (mm):")
                self.label_r1_offset.config(text="Set X Offset (mm):")
                
        elif self.type == 'reciprocal':
            try:
                self.type = 'real'
                if self.z is not None:
                    self.xmin = np.min(np.min(self.x)+np.min(self.z))
                    self.xmax = np.max(np.max(self.x)+np.max(self.z))
                else:
                    self.xmin = np.min(self.x)
                    self.xmax = np.max(self.x)
                self.ymin = np.min(self.y)
                self.ymax = np.max(self.y)
                self.phi_offset = 48
                self.r1_offset = 11.5
                if self.xmin+self.xmax > 2*self.phi_offset:
                    self.xmin = self.phi_offset-(self.xmax-self.phi_offset)
                if self.xmax+self.xmin < 2*self.phi_offset:
                    self.xmax = self.phi_offset-(self.xmin-self.phi_offset)
                if self.ymin+self.ymax > 2*self.r1_offset:
                    self.ymin = self.r1_offset-(self.ymax-self.r1_offset)
                if self.ymax+self.ymin < 2*self.r1_offset:
                    self.ymax = self.r1_offset-(self.ymin-self.r1_offset)
                self.b_mode.config(text='Transmission Mode')
                self.label_phi_offset.config(text="Set Z Offset (mm):")
                self.label_r1_offset.config(text="Set X Offset (mm):")
                self.frame_cut_xy.pack_forget()
                self.frame_region.pack_forget()
                self.set_sym_button.pack_forget()
                if mode == 'normal':
                    self.update_window()
            except:
                self.type = 'reciprocal'
                self.phi_offset = 0
                self.r1_offset = -31
                r1 = self.y - self.r1_offset
                phi = self.x - self.phi_offset
                # r = np.sqrt(2*self.m*self.e*self.ev[self.slice_index])/self.hbar*10**-10*(np.max(np.abs(np.sin(r1/180*np.pi)))**2+np.max(np.abs(np.sin(phi/180*np.pi)))**2)**0.5
                tr1, tphi = self.rot(np.max(np.abs(r1)), np.max(np.abs(phi)), 0, 0, 0)
                tx = np.sqrt(2*self.m*self.e*self.ev[self.slice_index])/self.hbar*10**-10*np.sin(tr1/180*np.pi) * np.cos(tphi/180*np.pi)
                ty = np.sqrt(2*self.m*self.e*self.ev[self.slice_index])/self.hbar*10**-10*np.sin(tphi/180*np.pi)
                r = np.sqrt(tx**2 + ty**2)
                self.xmin, self.xmax = -r, r
                self.ymin, self.ymax = -r, r
                self.txlim, self.tylim = [-r, r], [-r, r]
                self.ax.set_xlabel(r'$k_x$ ($\frac{2\pi}{\AA}$)', fontsize=16)
                self.ax.set_ylabel(r'$k_y$ ($\frac{2\pi}{\AA}$)', fontsize=16)
                self.b_mode.config(text='Reciprocal Mode')
                self.label_phi_offset.config(text="Set Phi Offset (degree):")
                self.label_r1_offset.config(text="Set R1 Offset (degree):")
    
    def __get_slim(self):
        min_val = int(float(self.entry_min.get()))
        max_val = int(float(self.entry_max.get()))
        self.slim = sorted([min_val, max_val])
        if self.slim[0] < 0:
            self.slim[0] = 0
        if self.slim[1] > 493:
            self.slim[1] = 493
        set_entry_value(self.entry_min, str(self.slim[0]))
        set_entry_value(self.entry_max, str(self.slim[1]))
        
    def set_slim(self, *args):
        self.sym = 1
        try:
            self.__get_slim()
            self.x, self.volume = [], []
            self.slice_index = np.argwhere(np.abs(self.ev-self.slider.val)<(self.ev[1]-self.ev[0])/2)[0][0]
            self.wait = wait(self)
            self.interpolate_slice(self.slice_index)
            self.disp_region()
            rotated_volume = rotate(self.surface, -self.angle, self.surface.shape)
            self.ax.clear()
            self.hl, = self.ax.plot([0, 0], [0, 0], color='green', linestyle='--')
            self.vl, = self.ax.plot([0, 0], [0, 0], color='green', linestyle='--')
            self.hl.set_data([],[])
            self.vl.set_data([],[])
            self.img = self.ax.imshow(rotated_volume, cmap=self.cmap, extent=[self.ymin, self.ymax, self.xmin, self.xmax], origin='lower')
            self.fig.canvas.draw_idle()
            self.wait.done()
            # setting entry
            self.entry_xmin.config(state='normal')
            self.entry_xmax.config(state='normal')
            self.entry_ymin.config(state='normal')
            self.entry_ymax.config(state='normal')
            if self.type == 'real':
                set_entry_value(self.entry_xmin, str(self.ymin))
                set_entry_value(self.entry_xmax, str(self.ymax))
                set_entry_value(self.entry_ymin, str(self.xmin))
                set_entry_value(self.entry_ymax, str(self.xmax))
                self.ax.set_xlabel('x (mm)', fontsize=16)
                self.ax.set_ylabel('z (mm)', fontsize=16)
                self.entry_xmin.config(state='disabled')
                self.entry_xmax.config(state='disabled')
                self.entry_ymin.config(state='disabled')
                self.entry_ymax.config(state='disabled')
            elif self.type == 'reciprocal':
                self.cut_l, = self.ax.plot([0, 0], [0, 0], color='red', linestyle='-')
                self.cut_l.set_data([], [])
                set_entry_value(self.entry_xmin, str(self.ymin))
                set_entry_value(self.entry_xmax, str(self.ymax))
                set_entry_value(self.entry_ymin, str(self.xmin))
                set_entry_value(self.entry_ymax, str(self.xmax))
                self.ax.set_xlabel(r'$k_x$ ($\frac{2\pi}{\AA}$)', fontsize=16)
                self.ax.set_ylabel(r'$k_y$ ($\frac{2\pi}{\AA}$)', fontsize=16)
        except ValueError:
            self.wait.done()
            print("Invalid input for slim values")
        except Exception as e:
            self.wait.done()
            print(f"An error occurred: {e}\nVolumeSlicer: set_slim()")

    def update_window(self):
        try:
            self.entry_xmin.config(state='normal')
            self.entry_xmax.config(state='normal')
            self.entry_ymin.config(state='normal')
            self.entry_ymax.config(state='normal')
            if self.type == 'real':
                set_entry_value(self.entry_xmin, str(self.ymin))
                set_entry_value(self.entry_xmax, str(self.ymax))
                set_entry_value(self.entry_ymin, str(self.xmin))
                set_entry_value(self.entry_ymax, str(self.xmax))
            elif self.type == 'reciprocal':
                set_entry_value(self.entry_xmin, str(self.tylim[0]))
                set_entry_value(self.entry_xmax, str(self.tylim[1]))
                set_entry_value(self.entry_ymin, str(self.txlim[0]))
                set_entry_value(self.entry_ymax, str(self.txlim[1]))
            set_entry_value(self.entry_phi_offset, str(self.phi_offset))
            set_entry_value(self.entry_r1_offset, str(self.r1_offset))
            self.x, self.volume = [], []
            self.wait = wait(self)
            self.interpolate_slice(self.slice_index)
            self.disp_region()
            rotated_volume = rotate(self.surface, -self.angle, self.surface.shape)
            self.ax.clear()
            self.img = self.ax.imshow(rotated_volume, cmap=self.cmap, extent=[self.ymin, self.ymax, self.xmin, self.xmax], origin='lower')
            self.hl, = self.ax.plot([0, 0], [0, 0], color='green', linestyle='--')
            self.vl, = self.ax.plot([0, 0], [0, 0], color='green', linestyle='--')
            self.hl.set_data([],[])
            self.vl.set_data([],[])
            if self.type == 'reciprocal':
                self.cut_l, = self.ax.plot([0, 0], [0, 0], color='red', linestyle='-')
                self.cut_l.set_data([], [])
                self.ax.set_xlim([self.tylim[0], self.tylim[1]])
                self.ax.set_ylim([self.txlim[0], self.txlim[1]])
                self.ax.set_xlabel(r'$k_x$ ($\frac{2\pi}{\AA}$)', fontsize=16)
                self.ax.set_ylabel(r'$k_y$ ($\frac{2\pi}{\AA}$)', fontsize=16)
            elif self.type == 'real':
                self.ax.set_xlim([self.ymin, self.ymax])
                self.ax.set_ylim([self.xmin, self.xmax])
                self.ax.set_xlabel('x (mm)', fontsize=16)
                self.ax.set_ylabel('z (mm)', fontsize=16)
            self.canvas.draw()
            self.wait.done()
            if self.type == 'real':
                self.entry_xmin.config(state='disabled')
                self.entry_xmax.config(state='disabled')
                self.entry_ymin.config(state='disabled')
                self.entry_ymax.config(state='disabled')
        except ValueError:
            self.wait.done()
            print("Range is not compatible with the current mode.")
        except Exception as e:
            self.wait.done()
            print(f"An error occurred: {e}\nVolumeSlicer: update_window()")
        
    def set_window(self):
        try:
            if self.type == 'reciprocal':
                self.txlim = sorted([float(self.entry_ymin.get()), float(self.entry_ymax.get())])
                self.tylim = sorted([float(self.entry_xmin.get()), float(self.entry_xmax.get())])
                self.update_window()
        except ValueError:
            print("Invalid input for window range values")
    
    def interpolate_slice(self, i):
        # self.xmin, self.xmax range should be larger than txlim, tylim in combine, and so as y
        try:
            self.phi_offset = float(self.entry_phi_offset.get())
            self.r1_offset = float(self.entry_r1_offset.get())
        except:pass
        self.x = self.ox[self.slim[0]:self.slim[1]+1]
        self.volume = self.ovolume[:, self.slim[0]:self.slim[1]+1, :]
        def filter(ind, i, r2=None):    #test the filtering process in slice_data function
            r1 = np.linspace(min(self.y[ind]), max(self.y[ind]), len(self.y[ind]))
            phi = np.linspace(min(self.x), max(self.x), len(self.x))
            r1, phi = np.meshgrid(r1, phi)
            if r2 is None:
                r1, phi = self.rot(r1, phi, self.r1_offset, self.phi_offset, self.angle)
            else:
                r1, phi = self.rot(r1, phi, self.r1_offset, self.phi_offset, self.angle-(r2-self.z[0]))
            x = np.sqrt(2*self.m*self.e*self.ev[i])/self.hbar*10**-10*np.sin(r1/180*np.pi) * np.cos(phi/180*np.pi)  # x: r1, y: phi, at r2=0
            y = np.sqrt(2*self.m*self.e*self.ev[i])/self.hbar*10**-10*np.sin(phi/180*np.pi)
            ti=[]
            for i in range(r1.shape[1]):
                if any(-0.1<x[:,i]) and any(-0.2<y[:,i]) and any(x[:,i]<0.1) and any(y[:,i]<0.2):
                    ti.append(i)
            if len(ti) != 0:
                if min(ti)>0:
                    ti.insert(0, min(ti)-1)
                if max(ti)<len(self.y[ind])-1:
                    ti.append(max(ti)+1)
            return ind[ti]
        if self.type == 'real':
            if self.z is not None:
                self.xmin = np.min(np.min(self.x)+np.min(self.z))
                self.xmax = np.max(np.max(self.x)+np.max(self.z))
            else:
                self.xmin = np.min(self.x)
                self.xmax = np.max(self.x)
            self.ymin = np.min(self.y)
            self.ymax = np.max(self.y)
            if self.xmin+self.xmax > 2*self.phi_offset:
                self.xmin = self.phi_offset-(self.xmax-self.phi_offset)
            elif self.xmax+self.xmin < 2*self.phi_offset:
                self.xmax = self.phi_offset-(self.xmin-self.phi_offset)
            if self.ymin+self.ymax > 2*self.r1_offset:
                self.ymin = self.r1_offset-(self.ymax-self.r1_offset)
            elif self.ymax+self.ymin < 2*self.r1_offset:
                self.ymax = self.r1_offset-(self.ymin-self.r1_offset)
            r = (((self.xmax-self.xmin)/2)**2+((self.ymax-self.ymin)/2)**2)**0.5
            self.xmin, self.xmax = self.phi_offset-r, self.phi_offset+r
            self.ymin, self.ymax = self.r1_offset-r, self.r1_offset+r
        elif self.type == 'reciprocal':
            r1 = self.y - self.r1_offset
            phi = self.x - self.phi_offset
            # r = np.sqrt(2*self.m*self.e*self.ev[i])/self.hbar*10**-10*(np.max(np.abs(np.sin(r1/180*np.pi)))**2+np.max(np.abs(np.sin(phi/180*np.pi)))**2)**0.5
            tr1, tphi = self.rot(np.max(np.abs(r1)), np.max(np.abs(phi)), 0, 0, 0)
            tx = np.sqrt(2*self.m*self.e*self.ev[i])/self.hbar*10**-10*np.sin(tr1/180*np.pi) * np.cos(tphi/180*np.pi)
            ty = np.sqrt(2*self.m*self.e*self.ev[i])/self.hbar*10**-10*np.sin(tphi/180*np.pi)
            r = np.sqrt(tx**2 + ty**2)
            self.xmin, self.xmax = -r, r
            self.ymin, self.ymax = -r, r
            
        if self.z is None: # for 1 cube
            if self.type == 'real':
                self.surface = self.combine(self.volume[:, :, i], xlim = [min(self.y), max(self.y)], ylim = [min(self.x), max(self.x)])
            elif self.type == 'reciprocal':
                self.surface = self.combine(self.volume[:, :, i], xlim = [min(self.y)-self.r1_offset, max(self.y)-self.r1_offset], ylim = [min(self.x)-self.phi_offset, max(self.x)-self.phi_offset], ev=self.ev[i])
        elif self.z is not None: # for multiple cubes
            img = self.volume[:, :, i]
            try:
                self.tmin = np.min(img[img>0])
                r2 = sorted(set(self.z))
                self.surface = np.full((self.density, self.density), np.nan, dtype=np.float64)
                if self.type == 'real':
                    tt=0
                    for z in r2:
                        t1=time.time()
                        ind = np.array(np.argwhere(self.z==z), dtype=np.int64).flatten()
                        self.surface = np.nanmean([self.surface, self.combine(data = self.volume[ind, :, i], xlim = [min(self.y[ind]), max(self.y[ind])], ylim = [min(self.x)+z, max(self.x)+z])], axis=0)
                        if self.fl_show:
                            tt+=1
                            self.wait.text(f'R2 = {z}: {time.time()-t1:.3f}s ({tt}/{len(r2)})')
                    self.surface = np.nan_to_num(self.surface)
                elif self.type == 'reciprocal':
                    tt=0
                    for z in r2:
                        t1=time.time()
                        ind = np.array(np.argwhere(self.z==z), dtype=np.int64).flatten()
                        # ind = filter(ind, i, r2=z)
                        # if len(ind) != 0:
                        self.surface = np.nanmean([self.surface, self.combine(self.volume[ind, :, i], xlim = [min(self.y[ind])-self.r1_offset, max(self.y[ind])-self.r1_offset], ylim = [min(self.x)-self.phi_offset, max(self.x)-self.phi_offset], r2=z, ev=self.ev[i])], axis=0)
                        if self.fl_show:
                            tt+=1
                            self.wait.text(f'R2 = {z}: {time.time()-t1:.3f}s ({tt}/{len(r2)})')
                    self.surface = np.nan_to_num(self.surface)
            except:
                self.surface = np.zeros((self.density, self.density))
        return self.surface
        
    def update(self, *args):
        self.hl.set_data([],[])
        self.vl.set_data([],[])
        self.slice_index = np.argwhere(np.abs(self.ev-self.slider.val)<(self.ev[1]-self.ev[0])/2)[0][0]
        self.wait = wait(self)
        self.interpolate_slice(self.slice_index)
        rotated_volume = rotate(self.surface, -self.angle, self.surface.shape)
        self.img.set_data(rotated_volume)
        self.canvas.draw()
        self.wait.done()

    def set_sl(self, *args):
        try:
            self.text_e.set(f'%.3f'%self.slider.val)
            # self.set_slim()
        except Exception as e:
            print(f"error: {e}\nVolumeSlicer: set_sl()")

    def set_tx(self, *args):
        try:
            self.slider.set_val(np.float64(self.text_e.get()))
            # self.set_slim()
        except Exception as e:
            print(f"error: {e}\nVolumeSlicer: set_tx()")
        
    def set_angle_sl(self, *args):
        try:
            self.angle = np.float64(self.angle_slider.val)
            self.text_a.set(f'%.3f'%self.angle)
            self.rotate_image()
        except ValueError:
            print("Invalid input for angle value")
    
    def set_angle_tx(self, *args):
        try:
            self.angle = np.float64(self.text_a.get())
            self.angle_slider.set_val(self.angle)
            self.rotate_image()
        except ValueError:
            print("Invalid input for angle value")
        
    def rotate_image(self):
        if self.mode == 'normal':
            self.disp_region()
            if self.type == 'real':
                self.hl.set_data([self.r1_offset, self.r1_offset], [self.xmin, self.xmax])
                self.vl.set_data([self.ymin, self.ymax], [self.phi_offset, self.phi_offset])
            elif self.type == 'reciprocal':
                self.hl.set_data([0, 0], [self.xmin, self.xmax])
                self.vl.set_data([self.ymin, self.ymax], [0, 0])
            rotated_volume = rotate(self.surface, -self.angle, self.surface.shape)
            self.img.set_data(rotated_volume)
            self.canvas.draw()

    def rot(self, x, y, r1_offset, phi_offset, angle):
        '''
        rotate the image with the given angle under the offset
        '''
        angle = np.deg2rad(angle)
        x = x - r1_offset   # ndimage.shift in the process
        y = y - phi_offset
        x_rot = x * np.cos(angle) - y * np.sin(angle)   # ndimage.rotate in the process
        y_rot = x * np.sin(angle) + y * np.cos(angle)
        return x_rot, y_rot


    
    def pr_disp_region(self):
        c = ['black', 'blue', 'green', 'magenta', 'purple', 'orange', 'pink', 'cyan', 'brown', 'gray', 'gold', 'lime', 'navy', 'teal', 'coral', 'salmon', 'yellow']
        self.reg_l1 = []
        self.reg_l2 = []
        if self.z is None:
            self.reg_l1.append(self.ax_region.plot([], [], color=c[0%len(c)], linewidth=0.5))
            self.reg_l2.append(self.ax_region.plot([], [], color=c[0%len(c)], linewidth=0.5))
        else:
            for i in range(len(set(self.z))):
                self.reg_l1.append(self.ax_region.plot([], [], color=c[i%len(c)], linewidth=0.5))
                self.reg_l2.append(self.ax_region.plot([], [], color=c[i%len(c)], linewidth=0.5))
    
    def disp_region(self):
        if self.type == 'reciprocal':
            tr1 = [0, 0]
            tphi = [0, 0]
            if self.z is None:
                r1 = self.y
                phi = np.linspace(min(self.x), max(self.x), int(max(self.x)-min(self.x)))
                r1, phi = np.meshgrid(r1, phi)
                r1, phi = self.rot(r1, phi, self.r1_offset, self.phi_offset, self.angle)
                r1, phi, r1_, phi_ = mesh(r1, phi)
                self.reg_l1[0][0].set_data(r1, phi)
                self.reg_l2[0][0].set_data(r1_, phi_)
                if np.min(r1)<tr1[0]:
                    tr1[0] = np.min(r1)
                if np.max(r1)>tr1[1]:
                    tr1[1] = np.max(r1)
                if np.min(phi)<tphi[0]:
                    tphi[0] = np.min(phi)
                if np.max(phi)>tphi[1]:
                    tphi[1] = np.max(phi)
            else:
                r2 = sorted(set(self.z))
                for i, z in enumerate(r2):
                    ind = np.array(np.argwhere(self.z==z), dtype=np.int64).flatten()
                    if len(self.y[ind]) > 1:
                        r1 = self.y[ind]
                    else:
                        r1 = np.linspace(self.y[ind]-0.25, self.y[ind]+0.25, 2)
                    phi = np.linspace(min(self.x), max(self.x), int(max(self.x)-min(self.x)))
                    r1, phi = np.meshgrid(r1, phi)
                    r1, phi = self.rot(r1, phi, self.r1_offset, self.phi_offset, self.angle-(z-r2[0]))
                    r1, phi, r1_, phi_ = mesh(r1, phi)
                    self.reg_l1[i][0].set_data(r1, phi)
                    self.reg_l2[i][0].set_data(r1_, phi_)
                    if np.min(r1)<tr1[0]:
                        tr1[0] = np.min(r1)
                    if np.max(r1)>tr1[1]:
                        tr1[1] = np.max(r1)
                    if np.min(phi)<tphi[0]:
                        tphi[0] = np.min(phi)
                    if np.max(phi)>tphi[1]:
                        tphi[1] = np.max(phi)
            self.ax_region.set_aspect('equal')
            txlim, tylim = tr1, tphi
            txlim = -np.max([np.abs(txlim), np.abs(tylim)]), np.max([np.abs(txlim), np.abs(tylim)])
            tylim = txlim
            self.ax_region.set_xlim(txlim)
            self.ax_region.set_ylim(tylim)
            self.ax_region.set_xlabel(r'$R1$ (deg)', fontsize=16)
            self.ax_region.set_ylabel(r'$Phi$ (deg)', fontsize=16)
            self.canvas_region.draw()

    def combine(self, data, xlim, ylim, r2=None, ev=None, step=0.25):  # complete
        '''
        Args:
        ---
        data: raw image (shape:(len(r1), len(phi)))
        xlim: [min, max]  x: r1
        ylim: [min, max]  y: phi
        step: width for only one r1 cube (default: 0.25 degree/mm)
        
        return:
        ---
            image
            shape: (density, density)
        '''
        xlim, ylim = sorted(xlim), sorted(ylim)
        fr2 = True
        if self.type == 'real':
            if int(self.density/(self.ymax-self.ymin)*(xlim[1]-xlim[0])) ==0:
                xlim[1] += step
                xlim[0] -= step
            base = np.zeros((self.density, self.density))
            data = cv2.resize(data, (int(self.density/(self.xmax-self.xmin)*(ylim[1]-ylim[0])), int(self.density/(self.ymax-self.ymin)*(xlim[1]-xlim[0]))), interpolation=cv2.INTER_CUBIC)
            base[0:data.shape[0], 0:data.shape[1]] = data
            data = np.roll(base.T, (int((ylim[0]-self.xmin)/(self.xmax-self.xmin)*self.density), int((xlim[0]-self.ymin)/(self.ymax-self.ymin)*self.density)), axis=(0, 1))
            data = data
        elif self.type == 'reciprocal':
            if r2 is None:
                fr2=False
                r2, self.z = 0, [0, 0]
            if int(self.density/180*(xlim[1]-xlim[0])) ==0: # at least 1 pixel
                d = 1/self.density*180/2
                c = (xlim[0]+xlim[1])/2
                xlim = [float(c-d), float(c+d)]
                print(f'Warning: R1-axis density is too low (R2=%.2f)'%r2)
                tk.messagebox.showwarning("Warning",f'Warning: R1-axis density is too low (R2=%.2f)'%r2)
                self.focus_set()
            base = np.zeros((self.density, self.density))
            r1 = np.linspace(xlim[0], xlim[1], int(self.density/180*(xlim[1]-xlim[0]))*4)
            phi = np.linspace(ylim[0], ylim[1], int(self.density/180*(ylim[1]-ylim[0]))*4)
            r1, phi = np.meshgrid(r1, phi)
            x = np.sqrt(2*self.m*self.e*ev)/self.hbar*10**-10*np.sin(r1/180*np.pi) * np.cos(phi/180*np.pi)  # x: r1, y: phi, at r2=0
            y = np.sqrt(2*self.m*self.e*ev)/self.hbar*10**-10*np.sin(phi/180*np.pi)
            txlim, tylim = [np.min(x), np.max(x)], [np.min(y), np.max(y)]
            ####### new method start
            # t=time.time()
            data = self.k_map(data, self.density, xlim, ylim, txlim, tylim, ev)
            ####################### new method end
            
            ####################### original plot start
            # tmax = np.max(data)
            # fig, ax = plt.subplots(dpi=150)
            # fig.patch.set_facecolor('black')
            # ax.set_facecolor('black')
            # data = cv2.resize(data, (int(self.density/180*(ylim[1]-ylim[0]))*4, int(self.density/180*(xlim[1]-xlim[0]))*4), interpolation=cv2.INTER_CUBIC)
            # ax.pcolormesh(x, y, data.T, cmap='gray')    # compatible with r2=0, phi: yaxis, r1: xaxis in transmission mode
            # ax.set_position([0, 0, 1, 1])
            # ax.axis('off')
            # fig.canvas.draw()
            # image_from_plot = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)
            # image_from_plot = image_from_plot.reshape(fig.canvas.get_width_height()[::-1] + (3,))
            # plt.close()
            # del fig, ax
            # image_gray = cv2.cvtColor(image_from_plot, cv2.COLOR_RGB2GRAY)/255*tmax
            # image_gray = cv2.resize(image_gray[::-1,:], (data.shape[1],data.shape[0]), interpolation=cv2.INTER_CUBIC)
            # data = cv2.resize(image_gray, (int(self.density/(self.xmax-self.xmin)*(txlim[1]-txlim[0])), int(self.density/(self.ymax-self.ymin)*(tylim[1]-tylim[0]))), interpolation=cv2.INTER_CUBIC)
            ########################### original plot end
            # print('1, resize+draw:', time.time()-t)
            # t = time.time()
            # print('2, resize*2:', time.time()-t)
            # t = time.time()
            base[0:data.shape[0], 0:data.shape[1]] = data
            # del data, image_gray, image_from_plot
            del data
            data = np.roll(base, (int((tylim[0]-self.ymin)/(self.ymax-self.ymin)*self.density), int((txlim[0]-self.xmin)/(self.xmax-self.xmin)*self.density)), axis=(0, 1))
            # print('3, shift:', time.time()-t)
            # data = data[::-1, :]
            del base
            gc.collect()
            # t = time.time()
            mat = cv2.getRotationMatrix2D((self.density/2, self.density/2), r2-self.z[0], 1)
            data = cv2.warpAffine(data, mat, (self.density, self.density), flags=cv2.INTER_NEAREST)
            # print('4, rotate:', time.time()-t)
            if not fr2:
                self.z = None
        if self.z is not None and fr2==True:  # for multiple cubes need np.nanmean
            msk = data<self.tmin-self.tmin/3
            data[msk] = np.nan
            
        return data

    # def cal_xz
    
    def show(self):
        self.pack(side=tk.TOP, fill=tk.BOTH, expand=1)

class CEC(loadfiles):
    def __init__(self, g, files, mode='normal'):
        super().__init__(files)
        if self.sort == 'r1r2':
            r2 = []
            for i in self.r2:
                for j in i:
                    r2.append(j)
            self.r2 = r2
        
        self.mode = mode
        self.g = g
        self.tlg = tk.Toplevel(g, bg='white')
        self.tlg.title('Constant Energy Cut')
        self.tlg.focus_set()
        self.frame1 = tk.Frame(self.tlg, bg='white')
        self.frame1.grid(row=0, column=1)
        self.__check_re()
        
        self.tlg.geometry(f"{1900}x{990}+0+0")
        self.tlg.protocol("WM_DELETE_WINDOW", self.on_closing)
        self.tlg.update()
    
    def on_closing(self):
        try:
            plt.close()
        except:
            pass
        self.tlg.destroy()
    
    def load(self, angle, cx, cy, cdx, cdy, phi_offset, r1_offset, slim, sym, name, path):
        vs = self.view
        set_entry_value(vs.entry_min, str(slim[0]))
        set_entry_value(vs.entry_max, str(slim[1]))
        set_entry_value(vs.entry_phi_offset, str(phi_offset))
        set_entry_value(vs.entry_r1_offset, str(r1_offset))
        vs.change_mode(mode=self.mode) # change from 'real' to 'reciprocal' in 'load' mode
        set_entry_value(vs.cut_xy_x_entry, str(cx))
        set_entry_value(vs.cut_xy_y_entry, str(cy))
        set_entry_value(vs.cut_xy_dx_entry, str(cdx))
        set_entry_value(vs.cut_xy_dy_entry, str(cdy))
        vs.angle = angle
        vs.text_a.set(f'%.3f'%angle)
        vs.angle_slider.set_val(angle)
        vs.set_slim()
        vs.gen_sym(sym)
        vs.cut_xy()
        vs.mode = 'normal'
        self.info_name = name
        self.info_path = path
        self.info_angle = angle
        self.info_sym = sym
        self.info_r1_offset = r1_offset
        self.info_phi_offset = phi_offset
        self.info_slim = slim
        self.info_cut_xy_x = cx
        self.info_cut_xy_y = cy
        self.info_cut_xy_dx = cdx
        self.info_cut_xy_dy = cdy
        
    def info(self):
        print('\nData Cube Info:')
        print('\033[32mPath:\033[36m',f'{self.path[0]}')
        for i, v in enumerate(self.path):
            if i > 0:
                print(f'\033[36m      {v}')
        text = self.l1.get("1.0", tk.END).split('\n')[0:-1]
        if ':' in text[0]:
            for i in text:
                print('\033[0m%s=%7s:%s'%(i.split(":")[0].split('=')[0],i.split(":")[0].split('=')[1],i.split(":")[1]))
        else:
            s=''
            for i, v in enumerate(text):
                if i != len(text)-1:
                    s += v.split('=')[1]+', '
                else:
                    s += v.split('=')[1]
            print('\033[0m%s=%s'%(v.split('=')[0], s))
        print('Slices: %d'%len(self.r1))
        print('Data Cube Size: %f MB'%(np.float64(self.size)/1024/1024))
        if self.mode == 'load':
            print(f'\033[32mFile Name: \033[36m{self.info_name}\033[0m')
            print(f'\033[32mFile Path: \033[36m{self.info_path}\033[0m')
            print(f'\033[32mAngle: \033[36m{self.info_angle} degree\033[0m')
            if self.info_sym != 1:
                print(f'\033[32mSymmetry: \033[36m{self.info_sym}-fold\033[0m')
            else:
                print(f'\033[32mSymmetry: \033[36mN/A\033[0m')
            print(f'\033[32mR1 Offset: \033[36m{self.info_r1_offset} degree\033[0m')
            print(f'\033[32mPhi Offset: \033[36m{self.info_phi_offset} degree\033[0m')
            print(f'\033[32mSlit Limit: \033[36m{self.info_slim[0]} ~ {self.info_slim[1]}\033[0m')
            print(f'\033[32mkx: \033[36m{self.info_cut_xy_x}\033[0m')
            print(f'\033[32mky: \033[36m{self.info_cut_xy_y}\033[0m')
            print(f'\033[32mkx bin: \033[36m{self.info_cut_xy_dx}\033[0m')
            print(f'\033[32mky bin: \033[36m{self.info_cut_xy_dy}\033[0m')
        hwnd = windll.user32.FindWindowW(None, "C:\\Windows\\system32\\cmd.exe")
        if hwnd:
            windll.user32.SetForegroundWindow(hwnd)
    
    def __set_data(self, odata=[], density=800, *args):
        if len(odata) > 0:
            self.size = 0
            for i in self.path:
                self.size += os.path.getsize(i)
            if self.sort == 'r1':
                odataframe = np.stack([i.to_numpy().transpose() for i in odata], axis=0)
                print('Input Data Shape: '+str(odataframe.shape))   # shape: (r1, phi, ev)
                
                r1 = self.r1
                ev, phi = odata[0].indexes.values()
                e_photon = float(odata[0].attrs['ExcitationEnergy'].removesuffix(' eV'))
                self.view = VolumeSlicer(parent=self.frame1, path=self.path, volume=odataframe, cmap='viridis', x=phi, y=r1, ev=ev, e_photon=e_photon, density=density)
            elif self.sort == 'r1r2':
                r1 = self.r1
                r2 = self.r2
                odataframe = np.stack([i.to_numpy().transpose() for i in odata], axis=0)
                print('Input Data Shape: '+str(odataframe.shape))
                
                ev, phi = odata[0].indexes.values()
                e_photon = float(odata[0].attrs['ExcitationEnergy'].removesuffix(' eV'))
                self.view = VolumeSlicer(parent=self.frame1, path=self.path, volume=odataframe, cmap='viridis', x=phi, y=r1, z=r2, ev=ev, e_photon=e_photon, density=density)
                
            self.tlg.bind('<Return>', self.view.set_slim)
            if self.mode == 'normal':
                self.view.set_slim()
            self.view.show()

    def __rlist(self):
        self.frame0 = tk.Frame(self.tlg, bg='white')
        self.frame0.grid(row=0, column=0)
        tk.Button(self.frame0, text='Info', width=6, height=2, font=('Arial', 18, 'bold'), bg='white', bd=5, command=self.info).pack(side=tk.TOP, padx=2)
        self.l1 = tk.Text(self.frame0, wrap='none', width=30, height=9, font=('Arial', 12, 'bold'), bg='white', bd=5)
        self.l1.pack(side=tk.TOP)
        
        if self.sort == 'r1r2':
            r2 = sorted(set(self.r2))
            t = 0
            s=''
            ls=0
            tt = False
            for i,v in enumerate(self.r2):
                if i<len(self.r2)-1:
                    if self.r2[i+1] == r2[t]:   # current r2 is same as next r2
                        if not tt:
                            s+=self.r2s[2]+'='+str(r2[t])+': '
                            tt = True
                        s+=str(self.r1[i])+', '
                        if i+1 == len(self.r2)-1:   # next r2 is the last r2
                            s+=str(self.r1[i+1])
                            if len(s)>ls:
                                ls=len(s)
                            self.l1.insert(tk.END, s)
                            s=''
                            tt = False
                    else:   # current r2 is different from next r2
                        if i+1 == len(self.r2)-1:   # next r2 is the last r2
                            s.removesuffix(', ')
                            s+=self.r2s[2]+'='+str(r2[t])+': '+str(self.r1[i])+'\n'
                            s+=self.r2s[2]+'='+str(r2[t+1])+': '+str(self.r1[i+1])
                        else:   # not last r2
                            if not tt:
                                s+=self.r2s[2]+'='+str(r2[t])+': '
                            s+=str(self.r1[i])+'\n'
                        if len(s)>ls:
                            ls=len(s)
                        self.l1.insert(tk.END, s)
                        s=''
                        tt = False
                        t+=1
        else:
            ls=0
            for i,v in enumerate(self.r1):
                if len(self.r1s[2]+'='+str(v))>ls:
                    ls=len(self.r1s[2]+'='+str(v))
                if i != len(self.r1)-1:
                    self.l1.insert(tk.END, self.r1s[2]+'='+str(v)+'\n')
                else:
                    self.l1.insert(tk.END, self.r1s[2]+'='+str(v))
            self.l1.config(width=ls)
    
    def __check(self, *args, f=False):
        name = self.lb.name
        t = self.preserve
        for i, v in enumerate(self.name):
            if v in name:
                t[i] = True
        self.preserve = t
        if self.sort == 'r1r2':
            r1 = []
            r2 = []
            for i, v in enumerate(self.r2):
                if self.preserve[i]:
                    r1.append(self.r1[i])
                    r2.append(v)
            self.r1 = r1
            self.r2 = r2
        elif self.sort == 'r1':
            r1 = []
            for i, v in enumerate(self.r1):
                if self.preserve[i]:
                    r1.append(v)
            self.r1 = r1
        
        if f==False:
            path = []
            name = []
            data = []
            for i, v in enumerate(self.preserve):
                if v:
                    path.append(self.path[i])
                    name.append(self.name[i])
                    data.append(self.data[i])
            self.path = path
            self.name = name
            self.data = data
        self.tlg.focus_set()
        if f==False:
            self.gg.destroy()
        self.__prework()
        
    def __check_file(self):
        self.gg = tk.Toplevel(self.g, bg='white')
        self.gg.protocol("WM_DELETE_WINDOW", self.__check)
        self.gg.title('File Check')
        self.gg.focus_set()
        text = 'Same File Name Exists\nSelect the file you want to preserve'
        tk.Label(self.gg, text=text, width=len(text), height=2, font=('Arial', 14, "bold"), bg='white', bd=5).grid(row=0, column=0)
        frame1 = tk.Frame(self.gg, bg='white')
        frame1.grid(row=1, column=0)
        name = [i.split('#id#')[0] for i in self.name]
        tname = [i for i in name]
        self.preserve = []
        for i in self.name:
            if '#id#' in i:
                self.preserve.append(False)
            else:
                self.preserve.append(True)
        t = 0
        self.lb = add_lb(frame1, self.sort)
        n = 0
        r1 = []
        r2 = []
        ss = []
        while t < len(name):
            if self.sort == 'r1r2':
                s = ''
                fj = False
                tt = False
                ti=1
                tj=t
                for jj in range(t+1, len(name)):
                    if name[t] == name[jj]:
                        ti+=1
                        if not tt:
                            tname[t] = tname[t]+'#id#'+str(t)
                            s+=tname[t]+'\n'
                            tt = True
                        tname[jj] = tname[jj]+'#id#'+str(jj)
                        s+=tname[jj]+'\n'
                        fj = True
                        tj = jj
                if fj:
                    t = tj
                t+=1
                s.removesuffix('\n')
                if s != '':
                    n+=1
                    r2.append(self.r2[t-1])
                    ss.append(s)
                    # self.lb.add(s, self.r2[t-1])
            elif self.sort == 'r1':
                s = ''
                fj = False
                tt = False
                ti=1
                tj=t
                for jj in range(t+1, len(name)):
                    if name[t] == name[jj]:
                        ti+=1
                        if not tt:
                            tname[t] = tname[t]+'#id#'+str(t)
                            s+=tname[t]+'\n'
                            tt = True
                        tname[jj] = tname[jj]+'#id#'+str(jj)
                        s+=tname[jj]+'\n'
                        fj = True
                        tj = jj
                if fj:
                    t = tj
                t+=1
                s.removesuffix('\n')
                if s != '':
                    n+=1
                    r1.append(self.r1[t-1])
                    ss.append(s)
                    # self.lb.add(s, self.r1[t-1])
        self.lb.name = ['name' for i in range(n)]
        for i in range(n):
            if self.sort == 'r1r2':
                self.lb.add(ss[i], r2[i], self.r1s[2], self.r2s[2])
            elif self.sort == 'r1':
                self.lb.add(ss[i], r1[i], self.r1s[2], self.r2s[2])
                
        tk.Button(self.gg, text='OK', command=self.__check, width=15, height=1, font=('Arial', 14, "bold"), bg='white', bd=5).grid(row=2, column=0)
        self.f1 = False
        self.gg.bind('<Return>', self.__check)
        self.gg.update()
        
    def __select_file(self):
        if self.f2:
            self.gg = tk.Toplevel(self.g, bg='white')
            self.gg.protocol("WM_DELETE_WINDOW", self.__check)
            self.gg.title('File Check')
            self.gg.focus_set()
            if self.sort == 'r1r2':
                text = f'Same {self.r1s[2]} and {self.r2s[2]} Exists\nSelect the file you want to preserve'
            elif self.sort == 'r1':
                text = f'Same {self.r1s[2]} Exists\nSelect the file you want to preserve'
            tk.Label(self.gg, text=text, width=len(text), height=2, font=('Arial', 14, "bold"), bg='white', bd=5).grid(row=0, column=0)
            frame1 = tk.Frame(self.gg, bg='white')
            frame1.grid(row=1, column=0)
            self.lb = add_lb(frame1, self.sort)
            self.preserve = [True for i in range(len(self.name))]        
            ti=[]
            ss=[]
            tt=[]
            t=0
            if self.sort == 'r1r2':
                for i in range(len(self.r2)):
                    for j in range(len(self.r2)):
                        if self.r2[i] == self.r2[j] and self.r1[i] == self.r1[j] and i != j:
                            ti.append(i)
                            self.preserve[i] = False
                ti = sorted(set(ti))
                while t < len(ti):
                    s=''
                    for i in range(len(np.argwhere(self.r1 == self.r1[ti[t]]))):
                        s+=self.name[ti[t]]+'\n'
                        t+=1
                    if s != '':
                        tt.append(t-1)
                        ss.append(s.removesuffix('\n'))
                self.lb.name = ['name' for i in range(len(ss))]
                for i, v in enumerate(ss):
                    self.lb.add(v, self.r2[tt[i]], self.r1s[2], self.r2s[2])
            elif self.sort == 'r1':
                for i in range(len(self.r1)):
                    for j in range(len(self.r1)):
                        if self.r1[i] == self.r1[j] and i != j:
                            ti.append(i)
                            self.preserve[i] = False
                            
                ti = sorted(set(ti))
                while t < len(ti):
                    s=''
                    for i in range(len(np.argwhere(self.r1 == self.r1[ti[t]]))):
                        s+=self.name[ti[t]]+'\n'
                        t+=1
                    if s != '':
                        tt.append(t-1)
                        ss.append(s.removesuffix('\n'))
                self.lb.name = ['name' for i in range(len(ss))]
                for i, v in enumerate(ss):
                    self.lb.add(v, self.r1[tt[i]], self.r1s[2], self.r2s[2])
                    
            tk.Button(self.gg, text='OK', command=self.__check, width=15, height=1, font=('Arial', 14, "bold"), bg='white', bd=5).grid(row=2, column=0)
            self.f2 = False
            self.gg.bind('<Return>', self.__check)
            self.gg.update()
        else:
            self.__check(f=True)
        
    def __prework(self):
        if self.f1:
            self.__check_file()
        elif self.f2:
            self.f2 = False
            if self.sort == 'r1r2':
                for i in range(len(self.r2)):
                    for j in range(len(self.r2)):
                        if self.r2[i] == self.r2[j] and self.r1[i] == self.r1[j] and i != j:
                            self.f2 = True
            elif self.sort == 'r1':
                for i in range(len(self.r1)):
                    for j in range(len(self.r1)):
                        if self.r1[i] == self.r1[j] and i != j:
                            self.f2 = True
            self.__select_file()
        else:
            self.__rlist()
            self.__set_data(odata=self.data)
    
    def __gen_f1_f2(self):
        self.f1 = False
        self.f2 = False
        for i in self.name:
            if '#id#' in i:
                self.f1 = True
        if self.sort == 'r1r2':
            for i in range(len(self.r2)):
                for j in range(len(self.r2)):
                    if self.r2[i] == self.r2[j] and self.r1[i] == self.r1[j] and i != j:
                        self.f2 = True
        elif self.sort == 'r1':
            for i in range(len(self.r1)):
                for j in range(len(self.r1)):
                    if self.r1[i] == self.r1[j] and i != j:
                        self.f2 = True
    
    def __check_re(self):
        self.__gen_f1_f2()
        self.__prework()

class add_lb():
    def __init__(self, fr, sort):
        self.fr = fr
        self.lb = []
        self.s = []
        self.l = []
        self.r = []
        self.name = []
        self.sort = sort
        
    def add(self, s, r, r1s, r2s):    
        self.s.append(s.removesuffix('\n'))
        if self.sort == 'r1r2':
            ltex = r2s+':'+str(r)+' '
        elif self.sort == 'r1':
            ltex = r1s+':'+str(r)+' '
        else:
            ltex = ''
        l = tk.Label(self.fr, text=ltex, width=len(ltex), height=1, font=('Arial', 14, "bold"), bg='white', bd=5)
        l.pack()
        self.l.append(l)
        self.r.append(r)
        ls=0
        for i in self.s[-1].split('\n'):
            if len(i)>ls:
                ls=len(i)+1
        listbox = tk.Listbox(self.fr, selectmode='single', font=('Arial', 14, "bold"), bg='white', bd=5, width=ls, height=len(self.s[-1].split('\n')))
        listbox.pack()
        self.lb.append(listbox)
        
        self.l[-1].config(text=ltex+self.s[-1].split('\n')[0], width=len(ltex+self.s[-1].split('\n')[0]))
        
        for i in self.s[-1].split('\n'):
            listbox.insert(tk.END, i)
        
        # Set focus to the Listbox
        listbox.focus_set()
        
        # Bind events
        listbox.bind('<<ListboxSelect>>', lambda event, lb=listbox, l=l, ltex=ltex: self.__on_select(event, lb, l, ltex))
        listbox.bind('<Up>', lambda event, lb=listbox, l=l: self.__on_up(event, lb, l))
        listbox.bind('<Down>', lambda event, lb=listbox, l=l: self.__on_down(event, lb, l))
        
        # Pre-select the first item
        if listbox.size() > 0:
            listbox.select_set(0)
            listbox.event_generate('<<ListboxSelect>>')
        
    def __on_up(self, event, lb, l):
        selected_index = lb.curselection()
        if selected_index and selected_index[0] > 0:
            lb.select_clear(selected_index[0])
            lb.select_set(selected_index[0] - 1)
            lb.event_generate('<<ListboxSelect>>')
    
    def __on_down(self, event, lb, l):
        selected_index = lb.curselection()
        if selected_index and selected_index[0] < lb.size() - 1:
            lb.select_clear(selected_index[0])
            lb.select_set(selected_index[0] + 1)
            lb.event_generate('<<ListboxSelect>>')
    
    def __on_select(self, event, lb, l, ltex):
        selected_index = lb.curselection()
        if selected_index:
            selected_item = lb.get(selected_index)
            l.config(text=ltex+selected_item, width=len(ltex+selected_item))
            for i,v in enumerate(self.r):
                if str(v)+' ' in ltex:
                    self.name[i] = selected_item.replace('\n', '')
        
def pr_load(data):
    global name,optionList,optionList1,optionList2,menu1,menu2,menu3,b_fit,dvalue,e_photon,lensmode,description,tst,lst,dpath
    dvalue = [data.attrs[i] for i in data.attrs.keys()]
    dpath = dvalue[14]
    st=''
    lst=[]
    for _ in data.attrs.keys():
        if _ == 'Description':
            ts=str(data.attrs[_])
            ts=ts.replace('\n\n\n','\n')
            ts=ts.replace('\n\n','\n')
            t=ts.split('\n')
            st+=str(_)+' : '+str(data.attrs[_]).replace('\n','\n                     ')
            # st+=str(_)+' : '+str(data.attrs[_]).replace('\n','\n                         ')
            lst.append(len(' : '+t[0]))
            for i in range(1,len(t)):
                lst.append(len('              '+t[i]))
            print(_,':', data.attrs[_].replace('\n','\n              '))
        elif _ == 'Path':
            pass
        else:
            st+=str(_)+' : '+str(data.attrs[_])+'\n'
            lst.append(len(str(_)+' : '+str(data.attrs[_])))
            print(_,':', data.attrs[_])
    print()
    tst=st
    l_path.config(width=max(lst), state='normal')
    l_path.delete(1.0, tk.END)
    l_path.insert(tk.END,dpath)
    l_path.see(1.0)
    l_path.config(state='disabled')
    info.config(height=len(st.split('\n'))+1, width=max(lst), state='normal')
    if len(st.split('\n'))>24:
        info.config(height=24, width=max(lst)+1, state='normal')
    info.insert(tk.END, '\n'+st+'\n')
    info.see(tk.END)
    info.config(state='disabled')
    global ev, phi
    ev, phi = data.indexes.values()
    ev = np.float64(ev)
    phi = np.float64(phi)
    name=dvalue[0]
    e_photon=np.float64(dvalue[3].split(' ')[0])
    lensmode=dvalue[8]
    description=dvalue[13]
    description=description.replace('\n\n\n\n\n','\n')
    description=description.replace('\n\n\n\n','\n')
    description=description.replace('\n\n\n','\n')
    description=description.replace('\n\n','\n')
    if lensmode=='Transmission':
        menu1.config(state='disabled')
        menu2.config(state='disabled')
        menu3.config(state='disabled')
        in_fit.config(state='disabled')
        b_fit.config(state='disabled')
    else:
        menu1.config(state='normal')
        menu2.config(state='normal')
        menu3.config(state='normal')
        in_fit.config(state='normal')
        b_fit.config(state='normal')
    os.chdir(cdir)
    np.savez('rd', path=dpath, name=name, lpath=[i for i in lfs.path], ev=ev,
             phi=phi, st=st, lst=lst)

fpr = 0

def o_load():
    global data, h, m, limg, img, rdd, path, st, fpr, lfs, l_name, namevar, nlist, b_tools, f_npz, npzf
    files=fd.askopenfilenames(title="Select Raw Data", filetypes=(
        ("HDF5 files", "*.h5"), ("NPZ files", "*.npz"), ("JSON files", "*.json"), ("TXT files", "*.txt")))
    st.put('Loading...')
    if len(files) > 0:
        f_npz = 0   # initial value to determine if CEC when loaded npz
        lfs = loadfiles(files)
        tpath = lfs.path[0]
        b_name.config(state='normal')
        b_excitation.config(state='normal')
        b_desc.config(state='normal')
        rdd = tpath
        fpr = 0
        if len(files) > 1:  #mulitple files
            if len(lfs.n)>0:lfs.sort='no'
            try:
                b_tools.grid_forget()
                l_name.grid_forget()
            except:
                pass
            b_tools = tk.Button(fr_tool, text='Batch Master', command=tools, width=12, height=1, font=('Arial', 12, "bold"), bg='white')
            b_tools.grid(row=0, column=0)
            nlist = lfs.name
            namevar = tk.StringVar(value=nlist[0])
            l_name = tk.OptionMenu(fr_tool, namevar, *nlist, command=change_file)
            l_name.config(font=('Arial', 16, 'bold'))
            l_name.grid(row=0, column=1)
        else:   #single file
            try:
                b_tools.grid_forget()
                l_name.grid_forget()
            except:
                pass
        if lfs.f_npz[0]:npzf = True
        else:npzf = False
        if npzf:
            koffset.config(state='normal')
            k_offset.set('0')
            koffset.config(state='disable')
        else:
            koffset.config(state='normal')
            try:
                k_offset.set(ko)
            except:
                k_offset.set('0')
    else:
        b_name.config(state='disable')
        b_excitation.config(state='disable')
        b_desc.config(state='disable')
        rdd = path
        
    limg.config(image=img[np.random.randint(len(img))])
    tbasename = os.path.basename(tpath)
    if '.h5' in tbasename:
        data = lfs.data[0]  # data save as xarray.DataArray format
        pr_load(data)
        tname = lfs.name[0]
        print(tname)
        if tname != name:
            print('path: ',tname, '\nh5: ', name)
            print('name need correction')
        else:
            print('name correct')
        st.put(tname)
    elif '.json' in tbasename:
        data = lfs.data[0]
        pr_load(data)
        tname = lfs.name[0]
        print(tname)
        if tname != name:
            print('path: ',tname, '\njson: ', name)
            print('name need correction')
        else:
            print('name correct')
        st.put(tname)
    elif '.txt' in tbasename:
        data = lfs.data[0]
        pr_load(data)
        st.put(tname)
    elif '.npz' in tbasename:
        data = lfs.data[0]
        pr_load(data)
        tname = lfs.name[0]
        st.put(tname)
    else:
        st.put('')
        pass
    #   print Attributes


def o_ecut():
    global data, ev, phi, mfpath, limg, img, name, rdd, st
    limg.config(image=img[np.random.randint(len(img))])
    mfpath = ''
    # os.chdir(rdd.removesuffix(rdd.split('/')[-1]))
    os.chdir(os.path.dirname(rdd))
    try:
        ndir = os.path.dirname(rdd)
        if ndir.split(os.sep)[-1] == name+'_MDC_'+lowlim.get():
            os.chdir('../')
        os.chdir(ndir)
        os.makedirs(name+'_MDC_'+lowlim.get())
    except:
        pass
    os.chdir(name+'_MDC_'+lowlim.get())
    pbar = tqdm.tqdm(total=len(ev), desc='MDC', colour='green')
    for n in range(len(ev)):
        ecut = data.sel(eV=ev[n], method='nearest')
        if npzf:x = phi
        else:x = (2*m*ev[n]*1.602176634*10**-19)**0.5*np.sin(phi/180*np.pi)*10**-10/(h/2/np.pi)
        y = ecut.to_numpy().reshape(len(x))
        y = np.where(y > int(lowlim.get()), y, int(lowlim.get()))
        path = 'ecut_%.3f.txt' % ev[n]
        mfpath += path
        pbar.update(1)
        # print(n+1,'/',len(ev))
        if (n+1) % (len(ev)//100) == 0:
            # print(str(round((n+1)/len(ev)*100))+'%'+' ('+str(len(ev))+')')
            st.put(str(round((n+1)/len(ev)*100))+'%'+' ('+str(len(ev))+')')
        f = open(path, 'w', encoding='utf-8')  # tab 必須使用 '\t' 不可"\t"
        f.write('#Wave Vector'+'\t'+'#Intensity'+'\n')
        for i in range(len(x)-1, -1, -1):
            f.write('%-6e' % x[i]+'\t'+'%-6e' % y[i]+'\n')
        f.close()
    os.chdir(cdir)
    np.savez('mfpath', mfpath=mfpath)
    # os.chdir(rdd.removesuffix(rdd.split('/')[-1]))
    os.chdir(os.path.dirname(rdd))
    pbar.close()
    print('Done')
    st.put('Done')


def o_angcut():
    global data, ev, phi, efpath, limg, img, name, rdd, st
    limg.config(image=img[np.random.randint(len(img))])
    efpath = ''
    # os.chdir(rdd.removesuffix(rdd.split('/')[-1]))
    os.chdir(os.path.dirname(rdd))
    try:
        ndir = os.path.dirname(rdd)
        if ndir.split(os.sep)[-1] == name+'_EDC'+lowlim.get():
            os.chdir('../')
        os.chdir(ndir)
        os.makedirs(name+'_EDC'+lowlim.get())
    except:
        pass
    os.chdir(name+'_EDC'+lowlim.get())
    pbar = tqdm.tqdm(total=len(phi), desc='EDC', colour='blue')
    for n in range(len(phi)):
        angcut = data.sel(phi=phi[n], method='nearest')
        x = ev
        y = angcut.to_numpy().reshape(len(x))
        y = np.where(y > int(lowlim.get()), y, int(lowlim.get()))
        path = 'angcut_%.5d.txt' % (phi[n]*1000)
        efpath += path
        pbar.update(1)
        # print(n+1,'/',len(phi))
        if (n+1) % (len(phi)//100) == 0:
            # print(str(round((n+1)/len(phi)*100))+'%'+' ('+str(len(phi))+')')
            st.put(str(round((n+1)/len(phi)*100))+'%'+' ('+str(len(phi))+')')
        f = open(path, 'w', encoding='utf-8')  # tab 必須使用 '\t' 不可"\t"
        f.write('#Wave Vector'+'\t'+'#Intensity'+'\n')
        for i in range(len(x)-1, -1, -1):
            f.write('%-6e' % x[i]+'\t'+'%-6e' % y[i]+'\n')
        f.close()
    os.chdir(cdir)
    np.savez('efpath', efpath=efpath)
    # os.chdir(rdd.removesuffix(rdd.split('/')[-1]))
    os.chdir(os.path.dirname(rdd))
    pbar.close()
    print('Done')
    st.put('Done')

# def res(a, b):
#     a = np.array(a)
#     det = [1 for i in range(len(a)-1)]
#     while sum(det) != 0:
#         for i in range(len(a)-1):
#             if a[i+1] < a[i]:
#                 det[i] = 1
#                 a[i+1], a[i] = a[i], a[i+1]
#                 b[i+1], b[i] = b[i], b[i+1]
#             else:
#                 det[i] = 0
#     return np.array(b)

def res(a, b):
    return np.array([b[i] for i in np.argsort(a)])

def loadmfit_re():
    file = fd.askopenfilename(
        title="Select MDC Fitted file", filetypes=(("VMS files", "*.vms"),))
    global st
    global data, rdd, lmgg
    mfpath = ''
    yy = []
    for n in range(len(ev)):
        ecut = data.sel(eV=ev[n], method='nearest')
        y = ecut.to_numpy().reshape(len(phi))
        y = np.where(y > int(lowlim.get()), y, int(lowlim.get()))
        yy.append(y)
        path = 'ecut_%.3f.txt' % ev[n]
        mfpath += path
    if len(file) > 2:
        rdd = file
        print('Loading...')
        st.put('Loading...')
    else:
        rdd = path
        lmgg.destroy()
    if ".vms" in file:
        n = -1
        fev = np.array([], dtype=float)
        t_fwhm = []
        t_pos = []
        t_kmax = []
        t_kmin = []
        smfi = []
        skmin = []
        skmax = []
        smfp = [1 for i in range(len(ev))]
        # os.chdir(rdd.removesuffix(rdd.split('/')[-1]))
        os.chdir(os.path.dirname(rdd))
        fc = open('rev_'+os.path.basename(file), 'w', encoding='utf-8')
        ff = open(name+'_mdc_fitted_raw_data.txt', 'w',
                  encoding='utf-8')  # tab 必須使用 '\t' 不可"\t"
        ff.write('K.E. (eV)'+'\t'+'FWHM (k)'+'\t'+'Position (k)'+'\n')
        try:
            with open(file) as f:
                f1 = 0
                f2 = 0
                indf = 0
                for i, line in enumerate(f):
                    if line[0:11] in mfpath:
                        fi = int(mfpath.find(line[0:11])/15)
                        n = -1
                        f1 = 0
                        f2 = 0
                        indf = 0
                    if line[0:22] == 'CASA region (*Survey*)':
                        tkmax = line.split(' ')[4]
                        tkmin = line.split(' ')[5]
                        ts = line.split(' ')
                        if float(tkmax) > 1000:
                            ts[4], ts[5] = str(
                                round(-(float(ts[5])-1486.6)+1486.6, 6)), str(round(-(float(ts[4])-1486.6)+1486.6, 6))
                        else:
                            ts[4], ts[5] = str(
                                round(-float(ts[5]), 6)), str(round(-float(ts[4]), 6))
                        fc.write(' '.join(ts))
                    elif line[0:12] == 'CASA comp (*':  # 若無篩選條件   indent於此if以下
                        tpos = line.split(' ')[17]
                        tfwhm = line.split(' ')[11]
                        area = line.split(' ')[5]
                        # tkmax=line.split(' ')[18]
                        # tkmin=line.split(' ')[19]
                        #####################################
                        s = line.split(' ')
                        if float(tpos) > 1000:
                            s[17] = str(
                                round(-(float(s[17])-1486.6)+1486.6, 6))
                            s[18], s[19] = str(
                                round(-(float(s[19])-1486.6)+1486.6, 6)), str(round(-(float(s[18])-1486.6)+1486.6, 6))
                        else:
                            s[17] = str(round(-float(s[17]), 6))
                            s[18], s[19] = str(
                                round(-float(s[19]), 6)), str(round(-float(s[18]), 6))
                        fc.write(' '.join(s))
                        '''
                        s=line.split(' ')
                        s[2]='(*Survey_*)'
                        s[8]=str(0)
                        s[9]=str(0.3)     #Area B=A*2
                        s[14]=str(0)
                        s[15]=str(1)    #FWHM B=A*1
                        
                        s[17]=str(round(float(s[17]),6))
                        s[18]=str(round(float(s[18]),6))
                        s[17]=str(round(float(s[17])-0.05,6))
                        s[18]=ts[4]
                        s[19]=ts[5]
                        fc.write(' '.join(s))
                        '''
                        #####################################

                        # 以下if判斷式區段---------可自訂篩選條件------可多層if-----注意indent----------條件篩選值可至 xxxx_fitted_raw_data.txt---檢查需求
                        ##################################################################################################
                        ##################################################################################################
                        # area tfwhm,tpos(1486.6+...)
                        if (ev[fi] > 20.58 and np.float64(tpos) < 1486.6+0.023) or (ev[fi] < 20.58 and np.float64(tpos) > 1486.6+0.023) or 1 == 1:
                            fev = np.append(fev, ev[fi])  # 內容勿動 indent小最內圈if一階
                            t_fwhm.append(tfwhm)  # 內容勿動 indent小最內圈if一階
                            t_pos.append(tpos)  # 內容勿動 indent小最內圈if一階
                            t_kmax.append(tkmax)
                            t_kmin.append(tkmin)
                            if fi not in smfi:
                                smfi.append(fi)
                                skmin.append(tkmin)
                                skmax.append(tkmax)
                            elif fi in smfi:
                                smfp[fi] += 1
                            if float(tpos) > 1000:
                                # 內容勿動 indent小最內圈if一階
                                ff.write(
                                    str(ev[fi])+'\t'+tfwhm+'\t'+str(np.float64(tpos)-1486.6)+'\n')
                            else:
                                ff.write(str(ev[fi])+'\t'+tfwhm +
                                         '\t'+str(np.float64(tpos))+'\n')
                        ##################################################################################################
                        ##################################################################################################
                    elif line[0:100] == 'XPS\n':
                        fc.write('XPS'+'\n')
                        indf = 1
                    elif line[0:100] == 'Al\n':
                        fc.write('Al'+'\n')
                        indf = 0
                    elif line[0:100] == '494\n' and f1 == 0:
                        if indf == 1:
                            fc.write('494'+'\n')
                            indf = 0
                        else:
                            f1 = 1
                            ti = i
                    elif line[0:100] == '0\n' and f1 == 1:
                        if ti == i-1:
                            f2 = 1
                            ti = i
                        else:
                            f1 = 0
                            ti = 0
                    elif line[0:100] == '1\n' and f2 == 1:
                        if ti == i-1:
                            ti = 0
                            f2 = 0
                            fc.write('494'+'\n')
                            fc.write('0'+'\n')
                            fc.write('1'+'\n')
                            for j in range(len(phi)):
                                # fc.write(str(int(yy[fi][-j-1]))+'\n')
                                fc.write(str(int(yy[fi][j]))+'\n')
                            n = len(phi)
                        else:
                            f1 = 0
                            f2 = 0
                            ti = 0
                    else:
                        if n <= 0:
                            if f2 == 1:
                                fc.write('494'+'\n')
                                fc.write('0'+'\n')
                                f2 = 0
                                f1 = 0
                            elif f1 == 1:
                                fc.write('494'+'\n')
                                f1 = 0
                            fc.write(line)
                        if n > 0:
                            f1 = 2
                            n -= 1
                            if n == 0:
                                f1 = 0
                    # pass  # process line i      #勿動
        except UnicodeDecodeError:
            with open(file, encoding='utf-8') as f:
                f1 = 0
                f2 = 0
                indf = 0
                for i, line in enumerate(f):
                    if line[0:11] in mfpath:
                        fi = int(mfpath.find(line[0:11])/15)
                        n = -1
                        f1 = 0
                        f2 = 0
                        indf = 0
                    if line[0:22] == 'CASA region (*Survey*)':
                        tkmax = line.split(' ')[4]
                        tkmin = line.split(' ')[5]
                        ts = line.split(' ')
                        if float(tkmax) > 1000:
                            ts[4], ts[5] = str(
                                round(-(float(ts[5])-1486.6)+1486.6, 6)), str(round(-(float(ts[4])-1486.6)+1486.6, 6))
                        else:
                            ts[4], ts[5] = str(
                                round(-float(ts[5]), 6)), str(round(-float(ts[4]), 6))
                        fc.write(' '.join(ts))
                    elif line[0:12] == 'CASA comp (*':  # 若無篩選條件   indent於此if以下
                        tpos = line.split(' ')[17]
                        tfwhm = line.split(' ')[11]
                        area = line.split(' ')[5]
                        # tkmax=line.split(' ')[18]
                        # tkmin=line.split(' ')[19]
                        #####################################
                        s = line.split(' ')
                        if float(tpos) > 1000:
                            s[17] = str(
                                round(-(float(s[17])-1486.6)+1486.6, 6))
                            s[18], s[19] = str(
                                round(-(float(s[19])-1486.6)+1486.6, 6)), str(round(-(float(s[18])-1486.6)+1486.6, 6))
                        else:
                            s[17] = str(round(-float(s[17]), 6))
                            s[18], s[19] = str(
                                round(-float(s[19]), 6)), str(round(-float(s[18]), 6))
                        fc.write(' '.join(s))
                        '''
                        s=line.split(' ')
                        s[2]='(*Survey_*)'
                        s[8]=str(0)
                        s[9]=str(0.3)     #Area B=A*2
                        s[14]=str(0)
                        s[15]=str(1)    #FWHM B=A*1
                        
                        s[17]=str(round(float(s[17]),6))
                        s[18]=str(round(float(s[18]),6))
                        s[17]=str(round(float(s[17])-0.05,6))
                        s[18]=ts[4]
                        s[19]=ts[5]
                        fc.write(' '.join(s))
                        '''
                        #####################################

                        # 以下if判斷式區段---------可自訂篩選條件------可多層if-----注意indent----------條件篩選值可至 xxxx_fitted_raw_data.txt---檢查需求
                        ##################################################################################################
                        ##################################################################################################
                        # area tfwhm,tpos(1486.6+...)
                        if (ev[fi] > 20.58 and np.float64(tpos) < 1486.6+0.023) or (ev[fi] < 20.58 and np.float64(tpos) > 1486.6+0.023) or 1 == 1:
                            fev = np.append(fev, ev[fi])  # 內容勿動 indent小最內圈if一階
                            t_fwhm.append(tfwhm)  # 內容勿動 indent小最內圈if一階
                            t_pos.append(tpos)  # 內容勿動 indent小最內圈if一階
                            t_kmax.append(tkmax)
                            t_kmin.append(tkmin)
                            if fi not in smfi:
                                smfi.append(fi)
                                skmin.append(tkmin)
                                skmax.append(tkmax)
                            elif fi in smfi:
                                smfp[fi] += 1
                            if float(tpos) > 1000:
                                # 內容勿動 indent小最內圈if一階
                                ff.write(
                                    str(ev[fi])+'\t'+tfwhm+'\t'+str(np.float64(tpos)-1486.6)+'\n')
                            else:
                                ff.write(str(ev[fi])+'\t'+tfwhm +
                                         '\t'+str(-np.float64(tpos))+'\n')
                        ##################################################################################################
                        ##################################################################################################
                    elif line[0:100] == 'XPS\n':
                        fc.write('XPS'+'\n')
                        indf = 1
                    elif line[0:100] == 'Al\n':
                        fc.write('Al'+'\n')
                        indf = 0
                    elif line[0:100] == '494\n' and f1 == 0:
                        if indf == 1:
                            fc.write('494'+'\n')
                            indf = 0
                        else:
                            f1 = 1
                            ti = i
                    elif line[0:100] == '0\n' and f1 == 1:
                        if ti == i-1:
                            f2 = 1
                            ti = i
                        else:
                            f1 = 0
                            ti = 0
                    elif line[0:100] == '1\n' and f2 == 1:
                        if ti == i-1:
                            ti = 0
                            f2 = 0
                            fc.write('494'+'\n')
                            fc.write('0'+'\n')
                            fc.write('1'+'\n')
                            for j in range(len(phi)):
                                # fc.write(str(int(yy[fi][-j-1]))+'\n')
                                fc.write(str(int(yy[fi][j]))+'\n')
                            n = len(phi)
                        else:
                            f1 = 0
                            f2 = 0
                            ti = 0
                    else:
                        if n <= 0:
                            if f2 == 1:
                                fc.write('494'+'\n')
                                fc.write('0'+'\n')
                                f2 = 0
                                f1 = 0
                            elif f1 == 1:
                                fc.write('494'+'\n')
                                f1 = 0
                            fc.write(line)
                        if n > 0:
                            f1 = 2
                            n -= 1
                            if n == 0:
                                f1 = 0
                    # pass  # process line i      #勿動
        ff.close()
        fc.close()
        os.chdir(cdir)
        print('Done')
        st.put('Done')
        lmgg.destroy()


def loadmfit_():
    file = fd.askopenfilename(title="Select MDC Fitted file", filetypes=(
        ("NPZ files", "*.npz"), ("VMS files", "*.vms"),))
    global h, m, fwhm, fev, pos, limg, img, name, ophi, rpos, st, kmax, kmin, lmgg
    global data, rdd, skmin, skmax, smaa1, smaa2, smfp, smfi, fpr, mfi_x, smresult, smcst
    mfpath = ''
    yy = []
    for n in range(len(ev)):
        ecut = data.sel(eV=ev[n], method='nearest')
        y = ecut.to_numpy().reshape(len(phi))
        y = np.where(y > int(lowlim.get()), y, int(lowlim.get()))
        yy.append(y)
        path = 'ecut_%.3f.txt' % ev[n]
        mfpath += path
    if len(file) > 2:
        fpr = 0
        rdd = file
        print('Loading...')
        st.put('Loading...')
    else:
        rdd = path
        lmgg.destroy()
    if ".vms" in file:
        n = -1
        fev = np.array([], dtype=float)
        mfi_x = np.arange(len(ev))
        t_fwhm = []
        t_pos = []
        t_kmax = []
        t_kmin = []
        smfi = []
        skmin = []
        skmax = []
        smfp = [1 for i in range(len(ev))]
        # os.chdir(rdd.removesuffix(rdd.split('/')[-1]))
        os.chdir(os.path.dirname(rdd))
        fc = open('copy2p_'+os.path.basename(file), 'w', encoding='utf-8')
        ff = open(name+'_mdc_fitted_raw_data.txt', 'w',
                  encoding='utf-8')  # tab 必須使用 '\t' 不可"\t"
        ff.write('K.E. (eV)'+'\t'+'FWHM (k)'+'\t'+'Position (k)'+'\n')
        try:
            with open(file) as f:
                for i, line in enumerate(f):
                    if line[0:11] in mfpath:
                        fi = int(mfpath.find(line[0:11])/15)
                    if line[0:22] == 'CASA region (*Survey*)':
                        tkmax = line.split(' ')[4]
                        tkmin = line.split(' ')[5]
                    # 若無篩選條件   indent於此if以下
                    elif line[0:20] == 'CASA comp (*Survey*)':
                        tpos = line.split(' ')[17]
                        tfwhm = line.split(' ')[11]
                        area = line.split(' ')[5]
                        # tkmax=line.split(' ')[18]
                        # tkmin=line.split(' ')[19]
                        # 以下if判斷式區段---------可自訂篩選條件------可多層if-----注意indent----------條件篩選值可至 xxxx_fitted_raw_data.txt---檢查需求
                        ##################################################################################################
                        ##################################################################################################
                        # area tfwhm,tpos(1486.6+...)
                        if (ev[fi] > 20.58 and np.float64(tpos) < 1486.6+0.023) or (ev[fi] < 20.58 and np.float64(tpos) > 1486.6+0.023) or 1 == 1:
                            if npzf:tkk = phi
                            else:tkk = (2*m*ev[fi]*1.602176634*10**-19)**0.5*np.sin(phi/180*np.pi)*10**-10/(h/2/np.pi)
                            if float(tpos) > 1200:
                                tkk+=1486.6
                            d = tkk[1]-tkk[0]
                            tr = float(tpos)+float(tfwhm)/2
                            tl = float(tpos)-float(tfwhm)/2
                            ri = int((tr-tkk[0])/d)
                            li = int((tl-tkk[0])/d)
                            tr = tkk[ri]+(float(tr)-(tkk[0]+ri*d)
                                          )/d*(tkk[ri+1]-tkk[ri])
                            tl = tkk[li]+(float(tl)-(tkk[0]+li*d)
                                          )/d*(tkk[li+1]-tkk[li])
                            tfwhm = tr-tl
                            tpi = int((float(tpos)-tkk[0])/d)
                            tpos = tkk[tpi]+(float(tpos)-(tkk[0]+tpi*d)
                                             )/d*(tkk[tpi+1]-tkk[tpi])
                            tpi = int((float(tkmax)-tkk[0])/d)
                            tkmax = tkk[tpi]+(float(tkmax) -
                                              (tkk[0]+tpi*d))/d*(tkk[tpi+1]-tkk[tpi])
                            tpi = int((float(tkmin)-tkk[0])/d)
                            if tpi > 492:
                                tpi = 492
                            tkmin = tkk[tpi]+(float(tkmin) -
                                              (tkk[0]+tpi*d))/d*(tkk[tpi+1]-tkk[tpi])

                            fev = np.append(fev, ev[fi])  # 內容勿動 indent小最內圈if一階
                            t_fwhm.append(tfwhm)  # 內容勿動 indent小最內圈if一階
                            t_pos.append(tpos)  # 內容勿動 indent小最內圈if一階
                            t_kmax.append(tkmax)
                            t_kmin.append(tkmin)
                            if fi not in smfi:
                                smfi.append(fi)
                                skmin.append(tkmin)
                                skmax.append(tkmax)
                            elif fi in smfi:
                                smfp[fi] += 1
                            if tpos > 1000:
                                # 內容勿動 indent小最內圈if一階
                                ff.write(
                                    str(ev[fi])+'\t'+str(tfwhm)+'\t'+str(np.float64(tpos)-1486.6)+'\n')
                            else:
                                ff.write(
                                    str(ev[fi])+'\t'+str(tfwhm)+'\t'+str(np.float64(tpos))+'\n')

                    # pass  # process line i      #勿動
        except UnicodeDecodeError:
            with open(file, encoding='utf-8') as f:
                for i, line in enumerate(f):
                    if line[0:11] in mfpath:
                        fi = int(mfpath.find(line[0:11])/15)
                    if line[0:22] == 'CASA region (*Survey*)':
                        tkmax = line.split(' ')[4]
                        tkmin = line.split(' ')[5]
                    # 若無篩選條件   indent於此if以下
                    elif line[0:20] == 'CASA comp (*Survey*)':
                        tpos = line.split(' ')[17]
                        tfwhm = line.split(' ')[11]
                        area = line.split(' ')[5]
                        # tkmax=line.split(' ')[18]
                        # tkmin=line.split(' ')[19]
                        # 以下if判斷式區段---------可自訂篩選條件------可多層if-----注意indent----------條件篩選值可至 xxxx_fitted_raw_data.txt---檢查需求
                        ##################################################################################################
                        ##################################################################################################
                        # area tfwhm,tpos(1486.6+...)
                        if (ev[fi] > 20.58 and np.float64(tpos) < 1486.6+0.023) or (ev[fi] < 20.58 and np.float64(tpos) > 1486.6+0.023) or 1 == 1:
                            if npzf:tkk = phi
                            else:tkk = (2*m*ev[fi]*1.602176634*10**-19)**0.5*np.sin(phi/180*np.pi)*10**-10/(h/2/np.pi)
                            if float(tpos) > 1200:
                                tkk+=1486.6
                            d = tkk[1]-tkk[0]
                            tr = float(tpos)+float(tfwhm)/2
                            tl = float(tpos)-float(tfwhm)/2
                            ri = int((tr-tkk[0])/d)
                            li = int((tl-tkk[0])/d)
                            tr = tkk[ri]+(float(tr)-(tkk[0]+ri*d)
                                          )/d*(tkk[ri+1]-tkk[ri])
                            tl = tkk[li]+(float(tl)-(tkk[0]+li*d)
                                          )/d*(tkk[li+1]-tkk[li])
                            tfwhm = tr-tl
                            tpi = int((float(tpos)-tkk[0])/d)
                            tpos = tkk[tpi]+(float(tpos)-(tkk[0]+tpi*d)
                                             )/d*(tkk[tpi+1]-tkk[tpi])
                            tpi = int((float(tkmax)-tkk[0])/d)
                            tkmax = tkk[tpi]+(float(tkmax) -
                                              (tkk[0]+tpi*d))/d*(tkk[tpi+1]-tkk[tpi])
                            tpi = int((float(tkmin)-tkk[0])/d)
                            if tpi > 492:
                                tpi = 492
                            tkmin = tkk[tpi]+(float(tkmin) -
                                              (tkk[0]+tpi*d))/d*(tkk[tpi+1]-tkk[tpi])

                            fev = np.append(fev, ev[fi])  # 內容勿動 indent小最內圈if一階
                            t_fwhm.append(tfwhm)  # 內容勿動 indent小最內圈if一階
                            t_pos.append(tpos)  # 內容勿動 indent小最內圈if一階
                            t_kmax.append(tkmax)
                            t_kmin.append(tkmin)
                            if fi not in smfi:
                                smfi.append(fi)
                                skmin.append(tkmin)
                                skmax.append(tkmax)
                            elif fi in smfi:
                                smfp[fi] += 1
                            if tpos > 1000:
                                # 內容勿動 indent小最內圈if一階
                                ff.write(
                                    str(ev[fi])+'\t'+str(tfwhm)+'\t'+str(np.float64(tpos)-1486.6)+'\n')
                            else:
                                ff.write(
                                    str(ev[fi])+'\t'+str(tfwhm)+'\t'+str(np.float64(tpos))+'\n')

                    # pass  # process line i      #勿動
        ff.close()
        fc.close()
        fwhm = np.float64(t_fwhm)     # FWHM
        if np.max(np.float64(t_pos)) > 50:
            rpos = np.float64(t_pos)-1486.6    # Pos
            kmax = np.float64(t_kmax)-1486.6
            kmin = np.float64(t_kmin)-1486.6
            skmax = np.float64(skmax)-1486.6
            skmin = np.float64(skmin)-1486.6
        else:
            rpos = np.float64(t_pos)    # Pos
            kmax = np.float64(t_kmax)
            kmin = np.float64(t_kmin)
            skmax = np.float64(skmax)
            skmin = np.float64(skmin)

        ophi = np.arcsin(rpos/(2*m*fev*1.602176634*10**-19)**0.5 /
                         10**-10*(h/2/np.pi))*180/np.pi
        pos = (2*m*fev*1.602176634*10**-19)**0.5 * \
            np.sin((np.float64(k_offset.get())+ophi) /
                   180*np.pi)*10**-10/(h/2/np.pi)
        okmphi = np.arcsin(kmin/(2*m*fev*1.602176634*10**-19) **
                           0.5/10**-10*(h/2/np.pi))*180/np.pi
        kmin = (2*m*fev*1.602176634*10**-19)**0.5 * \
            np.sin((np.float64(k_offset.get())+okmphi) /
                   180*np.pi)*10**-10/(h/2/np.pi)
        okMphi = np.arcsin(kmax/(2*m*fev*1.602176634*10**-19) **
                           0.5/10**-10*(h/2/np.pi))*180/np.pi
        kmax = (2*m*fev*1.602176634*10**-19)**0.5 * \
            np.sin((np.float64(k_offset.get())+okMphi) /
                   180*np.pi)*10**-10/(h/2/np.pi)

        rpos = res(fev, rpos)
        ophi = res(fev, ophi)
        fwhm = res(fev, fwhm)
        pos = res(fev, pos)
        kmin = res(fev, kmin)
        kmax = res(fev, kmax)
        fev = res(fev, fev)

        smfi = res(smfi, smfi)
        tkmin = res(smfi, skmin)
        tkmax = res(smfi, skmax)
        skmin, skmax = [], []
        smaa1 = np.float64(np.arange(4*len(ev)).reshape(len(ev), 4))
        smaa2 = np.float64(np.arange(8*len(ev)).reshape(len(ev), 8))
        ti = 0
        ti2 = 0
        for i, v in enumerate(ev):
            if i in smfi:
                skmin.append(tkmin[ti2])
                skmax.append(tkmax[ti2])
                ti2 += 1
                if smfp[i] == 2:  # 2peak以上要改
                    ti += 1
            else:
                skmin.append((2*m*v*1.602176634*10**-19)**0.5 *
                             np.sin(-0.5/180*np.pi)*10**-10/(h/2/np.pi))
                skmax.append((2*m*v*1.602176634*10**-19)**0.5 *
                             np.sin(0.5/180*np.pi)*10**-10/(h/2/np.pi))
            a1 = [(skmin[i]+skmax[i])/2, 10, 0.5, int(base.get())]
            a2 = [(skmin[i]+skmax[i])/2, 10, 0.5, int(base.get()),
                  (skmin[i]+skmax[i])/2, 10, 0.5, int(base.get())]

            if i in smfi:
                if smfp[i] == 1:
                    a1 = [rpos[ti], 10, fwhm[ti], int(base.get())]
                elif smfp[i] == 2:
                    a2 = [rpos[ti-1], 10, fwhm[ti-1],
                          int(base.get()), rpos[ti], 10, fwhm[ti], int(base.get())]
                ti += 1
            smaa1[i, :] = a1
            smaa2[i, :] = a2

        skmin, skmax = np.float64(skmin), np.float64(skmax)
        fpr = 1
        try:
            smresult=[]
        except:
            pass
        os.chdir(cdir)
    elif ".npz" in file:
        try:
            with np.load(file, 'rb') as f:
                rdd = str(f['path'])
                fev = f['fev']
                fwhm = f['fwhm']
                pos = f['pos']
                skmin = f['skmin']
                skmax = f['skmax']
                smaa1 = f['smaa1']
                smaa2 = f['smaa2']
                smfp = f['smfp']
                smfi = f['smfi']
                smresult = f['smresult']
                smcst = f['smcst']
            rpos = np.copy(pos)
            ophi = np.arcsin(rpos/(2*m*fev*1.602176634*10**-19) **
                             0.5/10**-10*(h/2/np.pi))*180/np.pi
            fpr = 1
            tbasename = os.path.basename(rdd)
            if '.h5' in tbasename:
                data = load_h5(rdd)
                pr_load(data)
            elif '.json' in tbasename:
                data = load_json(rdd)
                pr_load(data)
            elif '.txt' in tbasename:
                data = load_txt(rdd)
                pr_load(data)
        except:
            pass
    if ".vms" in file:
        np.savez('mfit', ko=k_offset.get(), fev=fev, rpos=rpos, ophi=ophi, fwhm=fwhm, pos=pos, kmin=kmin,
                 kmax=kmax, skmin=skmin, skmax=skmax, smaa1=smaa1, smaa2=smaa2, smfp=smfp, smfi=smfi)
    elif ".npz" in file:
        np.savez('mfit', ko=k_offset.get(), fev=fev, rpos=rpos, ophi=ophi, fwhm=fwhm, pos=pos, kmin=skmin,
                 kmax=skmax, skmin=skmin, skmax=skmax, smaa1=smaa1, smaa2=smaa2, smfp=smfp, smfi=smfi, smresult=smresult, smcst=smcst)
    limg.config(image=img[np.random.randint(len(img))])
    print('Done')
    st.put('Done')
    lmgg.destroy()


def loadmfit_2p():
    file = fd.askopenfilename(
        title="Select MDC Fitted file", filetypes=(("VMS files", "*.vms"),))
    global st
    global data, rdd, lmgg
    mfpath = ''
    yy = []
    for n in range(len(ev)):
        ecut = data.sel(eV=ev[n], method='nearest')
        y = ecut.to_numpy().reshape(len(phi))
        y = np.where(y > int(lowlim.get()), y, int(lowlim.get()))
        yy.append(y)
        path = 'ecut_%.3f.txt' % ev[n]
        mfpath += path
    if len(file) > 2:
        rdd = file
        print('Loading...')
        st.put('Loading...')
    else:
        rdd = path
        lmgg.destroy()
    if ".vms" in file:
        n = -1
        # os.chdir(rdd.removesuffix(rdd.split('/')[-1]))
        os.chdir(os.path.dirname(rdd))
        fc = open('copy2p_'+os.path.basename(file), 'w', encoding='utf-8')
        try:
            with open(file) as f:
                f1 = 0
                f2 = 0
                indf = 0
                for i, line in enumerate(f):
                    if line[0:11] in mfpath:
                        fi = int(mfpath.find(line[0:11])/15)
                        n = -1
                        f1 = 0
                        f2 = 0
                        indf = 0
                    if line[0:22] == 'CASA region (*Survey*)':
                        ts = line.split(' ')
                        ts[4] = str(round(float(ts[4]), 6))
                        ts[5] = str(round(float(ts[5]), 6))
                        fc.write(' '.join(ts))
                        fc.write('2'+'\n')
                        n = 1
                    # 若無篩選條件   indent於此if以下
                    elif line[0:20] == 'CASA comp (*Survey*)':
                        s = line.split(' ')
                        s[17] = str(round(float(s[17]), 6))
                        s[18] = str(round(float(s[17])-0.0001, 6))
                        s[19] = str(round(float(s[17])+0.0001, 6))
                        fc.write(' '.join(s))

                        s = line.split(' ')
                        s[2] = '(*Survey_*)'
                        s[8] = str(0)
                        s[9] = str(0.3)  # Area B=A*2
                        s[14] = str(0)
                        s[15] = str(1)  # FWHM B=A*1

                        s[17] = str(round(float(s[17]), 6))
                        s[18] = str(round(float(s[18]), 6))
                        s[17] = str(round(float(s[17])-0.05, 6))
                        s[18] = ts[4]
                        s[19] = ts[5]
                        fc.write(' '.join(s))
                    elif line[0:100] == 'XPS\n':
                        fc.write('XPS'+'\n')
                        indf = 1
                    elif line[0:100] == 'Al\n':
                        fc.write('Al'+'\n')
                        indf = 0
                    elif line[0:100] == '494\n' and f1 == 0:
                        if indf == 1:
                            fc.write('494'+'\n')
                            indf = 0
                        else:
                            f1 = 1
                            ti = i
                    elif line[0:100] == '0\n' and f1 == 1:
                        if ti == i-1:
                            f2 = 1
                            ti = i
                        else:
                            f1 = 0
                            ti = 0
                    elif line[0:100] == '1\n' and f2 == 1:
                        if ti == i-1:
                            ti = 0
                            f2 = 0
                            fc.write('494'+'\n')
                            fc.write('0'+'\n')
                            fc.write('1'+'\n')
                            for j in range(len(phi)):
                                fc.write(str(int(yy[fi][-j-1]))+'\n')
                            n = len(phi)
                        else:
                            f1 = 0
                            f2 = 0
                            ti = 0
                    elif line[0:100] == '8\n':
                        if indf == 1:
                            fc.write('8'+'\n')
                            indf = 0
                        else:
                            fc.write('9'+'\n')
                    elif line[0:100] == '9\n':
                        if indf == 1:
                            fc.write('9'+'\n')
                            indf = 0
                        else:
                            fc.write('10'+'\n')
                    elif line[0:100] == '10\n':
                        if indf == 1:
                            fc.write('10'+'\n')
                            indf = 0
                        else:
                            fc.write('11'+'\n')
                    elif line[0:100] == '11\n':
                        if indf == 1:
                            fc.write('11'+'\n')
                            indf = 0
                        else:
                            fc.write('12'+'\n')
                    else:
                        if n <= 0:
                            if f2 == 1:
                                fc.write('494'+'\n')
                                fc.write('0'+'\n')
                                f2 = 0
                                f1 = 0
                            elif f1 == 1:
                                fc.write('494'+'\n')
                                f1 = 0
                            fc.write(line)
                        if n > 0:
                            f1 = 2
                            n -= 1
                            if n == 0:
                                f1 = 0
                    # pass  # process line i      #勿動
        except UnicodeDecodeError:
            with open(file, encoding='utf-8') as f:
                f1 = 0
                f2 = 0
                indf = 0
                for i, line in enumerate(f):
                    if line[0:11] in mfpath:
                        fi = int(mfpath.find(line[0:11])/15)
                        n = -1
                        f1 = 0
                        f2 = 0
                        indf = 0
                    if line[0:22] == 'CASA region (*Survey*)':
                        ts = line.split(' ')
                        ts[4] = str(round(float(ts[4]), 6))
                        ts[5] = str(round(float(ts[5]), 6))
                        fc.write(' '.join(ts))
                        fc.write('2'+'\n')
                        n = 1
                    # 若無篩選條件   indent於此if以下
                    elif line[0:20] == 'CASA comp (*Survey*)':
                        s = line.split(' ')
                        s[17] = str(round(float(s[17]), 6))
                        s[18] = str(round(float(s[17])-0.0001, 6))
                        s[19] = str(round(float(s[17])+0.0001, 6))
                        fc.write(' '.join(s))

                        s = line.split(' ')
                        s[2] = '(*Survey_*)'
                        s[8] = str(0)
                        s[9] = str(0.3)  # Area B=A*2
                        s[14] = str(0)
                        s[15] = str(1)  # FWHM B=A*1

                        s[17] = str(round(float(s[17]), 6))
                        s[18] = str(round(float(s[18]), 6))
                        s[17] = str(round(float(s[17])-0.05, 6))
                        s[18] = ts[4]
                        s[19] = ts[5]
                        fc.write(' '.join(s))
                    elif line[0:100] == 'XPS\n':
                        fc.write('XPS'+'\n')
                        indf = 1
                    elif line[0:100] == 'Al\n':
                        fc.write('Al'+'\n')
                        indf = 0
                    elif line[0:100] == '494\n' and f1 == 0:
                        if indf == 1:
                            fc.write('494'+'\n')
                            indf = 0
                        else:
                            f1 = 1
                            ti = i
                    elif line[0:100] == '0\n' and f1 == 1:
                        if ti == i-1:
                            f2 = 1
                            ti = i
                        else:
                            f1 = 0
                            ti = 0
                    elif line[0:100] == '1\n' and f2 == 1:
                        if ti == i-1:
                            ti = 0
                            f2 = 0
                            fc.write('494'+'\n')
                            fc.write('0'+'\n')
                            fc.write('1'+'\n')
                            for j in range(len(phi)):
                                fc.write(str(int(yy[fi][-j-1]))+'\n')
                            n = len(phi)
                        else:
                            f1 = 0
                            f2 = 0
                            ti = 0
                    elif line[0:100] == '8\n':
                        if indf == 1:
                            fc.write('8'+'\n')
                            indf = 0
                        else:
                            fc.write('9'+'\n')
                    elif line[0:100] == '9\n':
                        if indf == 1:
                            fc.write('9'+'\n')
                            indf = 0
                        else:
                            fc.write('10'+'\n')
                    elif line[0:100] == '10\n':
                        if indf == 1:
                            fc.write('10'+'\n')
                            indf = 0
                        else:
                            fc.write('11'+'\n')
                    elif line[0:100] == '11\n':
                        if indf == 1:
                            fc.write('11'+'\n')
                            indf = 0
                        else:
                            fc.write('12'+'\n')
                    else:
                        if n <= 0:
                            if f2 == 1:
                                fc.write('494'+'\n')
                                fc.write('0'+'\n')
                                f2 = 0
                                f1 = 0
                            elif f1 == 1:
                                fc.write('494'+'\n')
                                f1 = 0
                            fc.write(line)
                        if n > 0:
                            f1 = 2
                            n -= 1
                            if n == 0:
                                f1 = 0
                    # pass  # process line i      #勿動
        fc.close()
        os.chdir(cdir)
    print('Done')
    st.put('Done')
    lmgg.destroy()


def o_loadefit():
    file = fd.askopenfilename(title="Select EDC Fitted file", filetypes=(
        ("NPZ files", "*.npz"), ("VMS files", "*.vms"),))
    global h, m, efwhm, ffphi, fphi, epos, fk, limg, img, name, st, emin, emax
    global data, rdd, semin, semax, seaa1, seaa2, sefp, sefi, fpr, efi_x
    if len(file) > 2:
        fpr = 0
        rdd = file
        print('Loading...')
        st.put('Loading...')
    else:
        rdd = path
    if ".vms" in file:
        fphi = np.array([], dtype=float)
        efi_x = np.arange(len(phi))
        t_fwhm = []
        t_pos = []
        t_emax = []
        t_emin = []
        sefi = []
        semin = []
        semax = []
        sefp = [1 for i in range(len(phi))]
        tphi = []
        # os.chdir(rdd.removesuffix(rdd.split('/')[-1]))
        os.chdir(os.path.dirname(rdd))
        ff = open(name+'_edc_fitted_raw_data.txt', 'w',
                  encoding='utf-8')  # tab 必須使用 '\t' 不可"\t"
        if npzf:ff.write('k (2pi/A)'+'\t'+'FWHM (eV)'+'\t'+'Position (eV)'+'\n')
        else:ff.write('Angle (deg)'+'\t'+'FWHM (eV)'+'\t'+'Position (eV)'+'\n')
        with open(file) as f:
            for i, line in enumerate(f):
                if line[0:16] in efpath:
                    if '-' in line[0:16]:
                        fi = int(efpath.find(line[0:16])/17)
                    else:
                        fi = int(
                            len(phi)//2+(efpath.find(line[0:16])-17*len(phi)//2)/16)
                if line[0:22] == 'CASA region (*Survey*)':
                    temax = line.split(' ')[4]
                    temin = line.split(' ')[5]
                # 若無篩選條件   indent於此if以下
                if line[0:20] == 'CASA comp (*Survey*)':
                    tpos = line.split(' ')[17]
                    tfwhm = line.split(' ')[11]
                    area = line.split(' ')[5]
                    # temax=line.split(' ')[18]
                    # temin=line.split(' ')[19]

                    # 以下if判斷式區段---------可自訂篩選條件------可多層if-----注意indent----------條件篩選值可至 xxxx_fitted_raw_data.txt---檢查需求
                    ##################################################################################################
                    ##################################################################################################
                    # area tfwhm,tpos(1486.6+...)
                    if np.float64(area) > 0 and np.float64(tfwhm) < 3:
                        if (phi[fi] > 20.58 and np.float64(tpos) < 1486.6+0.023) or (phi[fi] < 20.58 and np.float64(tpos) > 1486.6+0.023) or 1 == 1:

                            # 內容勿動 indent小最內圈if一階
                            fphi = np.append(fphi, phi[fi])
                            t_fwhm.append(tfwhm)  # 內容勿動 indent小最內圈if一階
                            t_pos.append(tpos)  # 內容勿動 indent小最內圈if一階
                            t_emax.append(temax)
                            t_emin.append(temin)
                            if fi not in sefi:
                                tphi.append(phi[fi])
                                sefi.append(fi)
                                semin.append(temin)
                                semax.append(temax)
                            elif fi in sefi:
                                sefp[fi] += 1
                            if float(tpos) > 1000:
                                # 內容勿動 indent小最內圈if一階
                                ff.write(
                                    str(phi[fi])+'\t'+tfwhm+'\t'+str(np.float64(tpos)-1486.6)+'\n')
                            else:
                                ff.write(str(phi[fi])+'\t'+tfwhm +
                                         '\t'+str(-np.float64(tpos))+'\n')
                    ##################################################################################################
                    ##################################################################################################
                pass  # process line i      #勿動
        ff.close()
        efwhm = np.float64(t_fwhm)     # FWHM
        if np.max(np.float64(t_pos)) > 50:
            epos = np.float64(t_pos)-1486.6    # Pos
            emax = np.float64(t_emax)-1486.6
            emin = np.float64(t_emin)-1486.6
            semax = np.float64(semax)-1486.6
            semin = np.float64(semin)-1486.6
        else:
            epos = np.float64(t_pos)    # Pos
            emax = np.float64(t_emax)
            emin = np.float64(t_emin)
            semax = np.float64(semax)
            semin = np.float64(semin)
        ffphi = np.float64(k_offset.get())+fphi
        fk = (2*m*epos*1.602176634*10**-19)**0.5 * \
            np.sin(ffphi/180*np.pi)*10**-10/(h/2/np.pi)

        epos = res(fphi, epos)
        ffphi = res(fphi, ffphi)
        efwhm = res(fphi, efwhm)
        fk = res(fphi, fk)
        emin = res(fphi, emin)
        emax = res(fphi, emax)
        fphi = res(fphi, fphi)

        sefi = res(tphi, sefi)
        temin = res(tphi, semin)
        temax = res(tphi, semax)
        semin, semax = [], []
        seaa1 = np.float64(np.arange(4*len(phi)).reshape(len(phi), 4))
        seaa2 = np.float64(np.arange(8*len(phi)).reshape(len(phi), 8))
        ti = 0
        ti2 = 0
        for i in range(len(phi)):
            if i in sefi:
                semin.append(temin[ti2])
                semax.append(temax[ti2])
                ti2 += 1
                if sefp[i] == 2:  # 2peak以上要改
                    ti += 1
            else:
                semin.append(np.min(ev))
                semax.append(np.max(ev))
            a1 = [(semin[i]+semax[i])/2, 10, 5, int(base.get())]
            a2 = [(semin[i]+semax[i])/2, 10, 5, int(base.get()),
                  (semin[i]+semax[i])/2, 10, 0.5, int(base.get())]
            if i in sefi:
                if sefp[i] == 1:
                    a1 = [epos[ti], 10, efwhm[ti], int(base.get())]
                elif sefp[i] == 2:
                    a2 = [epos[ti-1], 10, efwhm[ti-1],
                          int(base.get()), epos[ti], 10, efwhm[ti], int(base.get())]
                ti += 1
            seaa1[i, :] = a1
            seaa2[i, :] = a2
        semin, semax = np.float64(semin), np.float64(semax)
        fpr = 1
        os.chdir(cdir)
    elif ".npz" in file:
        try:
            with np.load(file, 'rb') as f:
                rdd = str(f['path'])
                fphi = f['fphi']
                efwhm = f['efwhm']
                epos = f['epos']
                semin = f['semin']
                semax = f['semax']
                seaa1 = f['seaa1']
                seaa2 = f['seaa2']
                sefp = f['sefp']
                sefi = f['sefi']
            ffphi = np.float64(k_offset.get())+fphi
            fk = (2*m*epos*1.602176634*10**-19)**0.5 * \
                np.sin(ffphi/180*np.pi)*10**-10/(h/2/np.pi)
            fpr = 1
            tbasename = os.path.basename(rdd)
            if '.h5' in tbasename:
                data = load_h5(rdd)
                pr_load(data)
            elif '.json' in tbasename:
                data = load_json(rdd)
                pr_load(data)
            elif '.txt' in tbasename:
                data = load_txt(rdd)
                pr_load(data)
        except:
            pass
    if ".vms" in file or ".npz" in file:
        np.savez('efit', ko=k_offset.get(), fphi=fphi, epos=epos, ffphi=ffphi, efwhm=efwhm, fk=fk,
                 emin=emin, emax=emax, semin=semin, semax=semax, seaa1=seaa1, seaa2=seaa2, sefp=sefp, sefi=sefi)
    limg.config(image=img[np.random.randint(len(img))])
    print('Done')
    st.put('Done')

def gl1(x, x0, a, w, y0):
    """
    Calculate the value of a Lorentzian function at a given x-coordinate.

    Parameters:
    x (float): The x-coordinate at which to evaluate the function.
    x0 (float): The center of the Lorentzian function.
    a (float): The amplitude of the Lorentzian function.
    w (float): The full width at half maximum (FWHM) of the Lorentzian function.
    y0 (float): The y-offset of the Lorentzian function.

    Returns:
    float: The value of the Lorentzian function at the given x-coordinate.
    """
    v = a/(1+(x-x0)**2/(1/2*w)**2)+y0
    return v

def gl2(x, x1, h1, w1, y1, x2, h2, w2, y2):
    """
    Calculates the sum of two Lorentzian functions.

    Parameters:
    x (float): The input value.
    x1 (float): The center of the first Lorentzian function.
    h1 (float): The height of the first Lorentzian function.
    w1 (float): The width of the first Lorentzian function.
    y1 (float): The y-offset of the first Lorentzian function.
    x2 (float): The center of the second Lorentzian function.
    h2 (float): The height of the second Lorentzian function.
    w2 (float): The width of the second Lorentzian function.
    y2 (float): The y-offset of the second Lorentzian function.

    Returns:
    float: The sum of the two Lorentzian functions.
    """
    v1 = h1/(1+(x-x1)**2/(1/2*w1)**2)+y1
    v2 = h2/(1+(x-x2)**2/(1/2*w2)**2)+y2
    return v1+v2

wr1 = 0
wr2 = 0
fa1 = 0
fa2 = 0

def pr_fitgl2(params, x, data):
    fitter0 = Minimizer(fgl2, params, fcn_args=(x, data))
    result = fitter0.minimize()
    pars = Parameters()
    pars.add('y1', value=0, vary=False)
    pars.add('y2', value=0, vary=False)
    pars.add('x1', value=result.params['x1'].value, vary=False)
    pars.add('x2', value=result.params['x2'].value, vary=False)
    pars.add('h1', value=result.params['h1'].value)
    pars.add('h2', value=result.params['h2'].value)
    pars.add('w1', value=result.params['w1'].value,
             min=result.params['w1'].min, max=result.params['w1'].max)
    pars.add('w2', value=result.params['w2'].value,
             min=result.params['w2'].min, max=result.params['w2'].max)
    return pars['h1'], pars['h2'], pars['w1'], pars['w2'], pars['x1'], pars['x2'], pars['y1'], pars['y2']


def fgl2_1(params, x, data):
    par = params
    h1, h2, w1, w2, x1, x2, y1, y2 = pr_fitgl2(par, x, data)
    area1 = np.sum(gl1(x, x1, h1, w1, y1))
    area2 = np.sum(gl1(x, x2, h2, w2, y2))
    return area2/fa2 - area1/fa1


def fgl2_a(params, x, data):
    h1 = params['h1']
    h2 = params['h2']
    x1 = params['x1']
    x2 = params['x2']
    w1 = params['w1']
    w2 = params['w2']
    y1 = params['y1']
    y2 = params['y2']
    model = (gl1(x, x1, h1, w1, y1) +
             gl1(x, x2, h2, w2, y2))
    area1 = np.sum(gl1(x, x1, h1, w1, y1))
    area2 = np.sum(gl1(x, x2, h2, w2, y2))
    return model - data + area1/fa1 - area2/fa2


def fgl2(params, x, data):
    h1 = params['h1']
    h2 = params['h2']
    x1 = params['x1']
    x2 = params['x2']
    w1 = params['w1']
    w2 = params['w2']
    y1 = params['y1']
    y2 = params['y2']
    model = (gl1(x, x1, h1, w1, y1) +
             gl1(x, x2, h2, w2, y2))
    return model - data


def fgl1(params, xx, data):
    h = params['h']
    x = params['x']
    w = params['w']
    y = params['y']
    model = gl1(xx, x, h, w, y)
    return model - data


def toa1():
    a1 = []
    a1.append(result.params['x'].value)
    a1.append(result.params['h'].value)
    a1.append(result.params['w'].value)
    a1.append(result.params['y'].value)
    return a1


def toa2(xx):
    global fswa1a2
    a2 = []
    a2.append(result.params['x1'].value)
    a2.append(result.params['h1'].value)
    a2.append(result.params['w1'].value)
    a2.append(result.params['y1'].value)
    a2.append(result.params['x2'].value)
    a2.append(result.params['h2'].value)
    a2.append(result.params['w2'].value)
    a2.append(result.params['y2'].value)
    
    fswa1a2 = 0
    i = mfiti.get()
    
    # fmxx[i, :len(xx)] = xx
    # x = fmxx[i, np.argwhere(fmxx[i, :] >= -20)].flatten()
    x = xx
    ty = gl1(x, *a2[:4])
    s1 = np.sum(np.array([((ty[i]+ty[i+1])/2)for i in range(len(x)-1)])
            # Area 1
            * np.array(([(x[i+1]-x[i])for i in range(len(x)-1)])))
    ty = gl1(x, *a2[-4:])
    s2 = np.sum(np.array([((ty[i]+ty[i+1])/2)for i in range(len(x)-1)])
            # Area 2
            * np.array(([(x[i+1]-x[i])for i in range(len(x)-1)])))
    if s1 < s2:
        t1, t2 = a2[:4], a2[-4:]
        a2 = np.array([t2, t1]).flatten()
        fswa1a2 = 1
    return a2


def swapc1c2():
    i = mfiti.get()
    if mfp[i] == 2 and fswa1a2 == 1:
        o_result = copy.deepcopy(result)
        a1=['x1', 'h1', 'w1', 'y1']
        a2=['x2', 'h2', 'w2', 'y2']
        for i in range(4):
            if o_result.params[a2[i]].expr is not None:
                if a1[i] in o_result.params[a2[i]].expr:
                    o_result.params[a2[i]].set(expr=o_result.params[a2[i]].expr.replace(a1[i], a2[i]))
            result.params[a1[i]].set(value=o_result.params[a2[i]].value, min=o_result.params[a2[i]].min, max=o_result.params[a2[i]].max, expr=o_result.params[a2[i]].expr, brute_step=o_result.params[a2[i]].brute_step, vary=o_result.params[a2[i]].vary)
            result.params[a2[i]].set(value=o_result.params[a1[i]].value, min=o_result.params[a1[i]].min, max=o_result.params[a1[i]].max, expr=o_result.params[a1[i]].expr, brute_step=o_result.params[a1[i]].brute_step, vary=o_result.params[a1[i]].vary)
    return result


fit_warn = 0


def checkfit():
    global fit_warn
    fit_warn = 0
    t = 0
    for i in result.params:
        par = result.params[i]
        if par.value != 0:
            try:
                if par.stderr/par.value > 0.2:  # uncertainty 20%
                    t += 1
            except TypeError:
                fit_warn = 1
    if t >= 2:
        fit_warn = 1


def putfitpar(inpars, modelpars=None, show_correl=True, min_correl=0.1,
              sort_pars=False, correl_mode='list'):
    from lmfit.parameter import Parameters
    if isinstance(inpars, Parameters):
        result, params = None, inpars
    if hasattr(inpars, 'params'):
        result = inpars
        params = inpars.params

    if sort_pars:
        if callable(sort_pars):
            key = sort_pars
        else:
            key = alphanumeric_sort
        parnames = sorted(params, key=key)
    else:
        parnames = list(params.keys())

    buff = []
    add = buff.append
    namelen = max(len(n) for n in parnames)
    for name in parnames:
        if name != 'y1' and name != 'y2':
            par = params[name]
            space = ' '*(namelen-len(name))
            nout = f"{name}:{space}"
            inval = '(init = ?)'
            if par.init_value is not None:
                inval = f'(init = {par.init_value:.7g})'
            if modelpars is not None and name in modelpars:
                inval = f'{inval}, model_value = {modelpars[name].value:.7g}'
            try:
                sval = gformat(par.value)
            except (TypeError, ValueError):
                sval = ' Non Numeric Value?'
            if par.stderr is not None:
                serr = gformat(par.stderr)
                try:
                    spercent = f'({abs(par.stderr/par.value):.2%})'
                except ZeroDivisionError:
                    spercent = ''
                sval = f'{sval} +/-{serr} {spercent}'

            if par.vary:
                add(f"    {nout} {sval} {inval}")
            elif par.expr is not None:
                add(f"    {nout} {sval} == '{par.expr}'")
            else:
                add(f"    {nout} {par.value: .7g} (fixed)")
    return buff


def fitpar1(result, lm1, lm2, lm3, lm4, lm5, lm6):
    s = putfitpar(result)
    x = s[0]
    h = s[1]
    w = s[2]
    for l, v in zip([lm1, lm2, lm3, lm4, lm5, lm6], [x, h, w, '', '', '']):
        l.config(text=v)
        l.config(anchor='w')


def fitpar2(result, lm1, lm2, lm3, lm4, lm5, lm6):
    s = putfitpar(result)
    for i in s:
        '''preprocess the string to put values in the labels'''
        if 'x1*xr1+xr2' in i:
            if xr2>=0:
                i = i.replace(' == \'x1*xr1+xr2\'', '='+str(xr1)+'*x1+'+str(xr2))
            else:
                i = i.replace(' == \'x1*xr1+xr2\'', '='+str(xr1)+'*x1-'+str(-xr2))
        if 'x2*xr1+xr2' in i:
            if xr2>=0:
                i = i.replace(' == \'x2*xr1+xr2\'', '='+str(xr1)+'*x2+'+str(xr2))
            else:
                i = i.replace(' == \'x2*xr1+xr2\'', '='+str(xr1)+'*x2-'+str(-xr2))
        if "(x2-xr2) / xr1" in i:
            if xr2>=0:
                i = i.replace(' == \'(x2-xr2) / xr1\'','=(x2-'+str(xr2) + ')/'+str(xr1))
            else:
                i = i.replace(' == \'(x2-xr2) / xr1\'','=(x2+'+str(-xr2) + ')/'+str(xr1))
        if "(x1-xr2) / xr1" in i:
            if xr2>=0:
                i = i.replace(' == \'(x1-xr2) / xr1\'','=(x1-'+str(xr2) + ')/'+str(xr1))
            else:
                i = i.replace(' == \'(x1-xr2) / xr1\'','=(x1+'+str(-xr2) + ')/'+str(xr1))
        if 'w1/wr1*wr2' in i:
            i = i.replace(' == \'w1/wr1*wr2\'', '=w1/'+str(wr1)+'*'+str(wr2))
        if 'w2/wr1*wr2' in i:
            i = i.replace(' == \'w2/wr1*wr2\'', '=w2/'+str(wr1)+'*'+str(wr2))
        if 'x1:' in i:
            x1 = i
        if 'x2:' in i:
            x2 = i
        if 'h1:' in i:
            h1 = i
        if 'h2:' in i:
            h2 = i
        if 'w1:' in i:
            w1 = i
        if 'w2:' in i:
            w2 = i
    for l, v in zip([lm1, lm2, lm3, lm4, lm5, lm6], [x1, x2, h1, h2, w1, w2]):
        l.config(text=v)
        l.config(anchor='w')

def lnr_bg(x: np.ndarray, n_samples=5) -> np.ndarray:
    while len(x) < 2*n_samples:
        if len(x) < 2:
            o = np.array([])
        n_samples -= 1
    left, right = np.mean(x[:n_samples]), np.mean(x[-n_samples:])
    o = np.ones(len(x))*np.mean([left, right])
    return o+mbgv


def shirley_bg(
        xps: np.ndarray, eps=1e-7, max_iters=50, n_samples=5) -> np.ndarray:
    global bg_warn
    """Core routine for calculating a Shirley background on np.ndarray data."""
    background = np.copy(xps)
    cumulative_xps = np.cumsum(xps, axis=0)
    total_xps = np.sum(xps, axis=0)

    rel_error = np.inf

    i_left = np.mean(xps[:n_samples], axis=0)
    i_right = np.mean(xps[-n_samples:], axis=0)

    iter_count = 0

    k = i_left - i_right
    for iter_count in range(max_iters):
        cumulative_background = np.cumsum(background, axis=0)
        total_background = np.sum(background, axis=0)

        new_bkg = np.copy(background)

        for i in range(len(new_bkg)):
            new_bkg[i] = i_right + k * (
                (total_xps - cumulative_xps[i] -
                 (total_background - cumulative_background[i]))
                / (total_xps - total_background + 1e-5)
            )

        rel_error = np.abs(np.sum(new_bkg, axis=0) -
                           total_background) / (total_background)

        background = new_bkg

        if np.any(rel_error < eps):
            break

    if (iter_count + 1) == max_iters:
        bg_warn = 1
        warnings.warn(
            "Shirley background calculation did not converge "
            + "after {} steps with relative error {}!".format(max_iters, rel_error)
        )
    else:
        bg_warn = 0

    return background


def fecgl2():
    global ebcgl2, emin, emax, flecgl2, eicgl2, efp
    i = efiti.get()
    flecgl2 *= -1
    if flecgl2 == 1:
        eicgl2 = i
        ebcgl2.config(text='End Add 2 Peaks', bg='red')
    else:
        ti = sorted([i, eicgl2])
        for i in np.linspace(ti[0], ti[1], ti[1]-ti[0]+1, dtype=int):
            efp[i] = 2
            if i not in efi_x:
                efi_x.append(i)
            if i in efi:
                efi.remove(i)
            if i in efi_err:
                efi_err.remove(i)
        ebcgl2.config(text='Start Add 2 Peaks', bg='white')
        efitplot()


def efitjob():
    global fexx, feyy, fex, fey, evv, eaa1, eaa2, emin, emax, efi, efi_err, efi_x, st, est, result, fa1, fa2, fit_warn, bg_warn
    if len(efi) < 1:
        efi, efi_err, efi_x = [], [], []
    else:
        efi, efi_err, efi_x = list(efi), list(efi_err), list(efi_x)
    pbar = tqdm.tqdm(total=len(phi), desc='Fitting EDC', colour='blue')
    for i in range(len(phi)):
        ebase[i] = int(base.get())  # 待調整
        fexx[i, :] = fexx[i, :]/fexx[i, :]*-50
        feyy[i, :] = feyy[i, :]/feyy[i, :]*-50
        angcut = data.sel(phi=phi[i], method='nearest')
        x = ev
        y = angcut.to_numpy().reshape(len(x))
        tx = x[np.argwhere(x >= emin[i])].flatten()
        xx = tx[np.argwhere(tx <= emax[i])].flatten()
        ty = y[np.argwhere(x >= emin[i])].flatten()
        yy = ty[np.argwhere(tx <= emax[i])].flatten()
        yy = np.where(yy > ebase[i], yy, ebase[i])
        try:
            # if (emin[i],emax[i])==(np.min(ev),np.max(ev)) and i not in efi:
            if i not in efi:
                if i not in efi_x:
                    efi_x.append(i)
                if i in efi:
                    efi.remove(i)
                if i in efi_err:
                    efi_err.remove(i)
                a1 = [(emin[i]+emax[i])/2, (np.max(y)-ebase[i]), 5, ebase[i]]
                a2 = [(emin[i]+emax[i])/2, (np.max(y)-ebase[i]), 5, ebase[i],
                      (emin[i]+emax[i])/2, (np.max(y)-ebase[i]), 5, ebase[i]]
            # elif (emin[i],emax[i])!=(np.min(ev),np.max(ev)):
            else:
                if efp[i] == 1:
                    if i in efi and i not in efi_err:
                        a1 = eaa1[i, :]
                    else:
                        a1, b = curve_fit(gl1, xx, yy-shirley_bg(yy), bounds=(
                            [emin[i], (np.max(y)-ebase[i])/10, 0, 0], [emax[i], np.max(y)-ebase[i]+1, 3, 0.01]))
                        fit_warn = 0
                elif efp[i] == 2:
                    if i in efi and i not in efi_err:
                        a2 = eaa1[i, :]
                    else:
                        pars = Parameters()
                        wr1, wr2 = int(ewf1.get()), int(ewf2.get())
                        fa1, fa2 = int(eaf1.get()), int(eaf2.get())
                        pars.add(
                            'x1', value=emin[i]+(emax[i]-emin[i])*0.3, min=emin[i], max=emax[i])
                        pars.add(
                            'x2', value=emax[i]-(emax[i]-emin[i])*0.3, min=emin[i], max=emax[i])
                        pars.add('h1', value=(
                            np.max(y)-ebase[i])+1, min=(np.max(y)-ebase[i])/10, max=np.max(y)-ebase[i]+1)
                        pars.add('h2', value=(
                            np.max(y)-ebase[i])+1, min=(np.max(y)-ebase[i])/10, max=np.max(y)-ebase[i]+1)
                        pars.add('w1', value=1, min=0, max=3)
                        if wr1 != 0 and wr2 != 0:
                            pars.add('wr1', value=wr1, vary=False)
                            pars.add('wr2', value=wr2, vary=False)
                            pars.add('w2', expr='w1/wr1*wr2')
                        else:
                            pars.add('w2', value=1, min=0, max=3)
                        pars.add('y1', value=0, vary=False)
                        pars.add('y2', value=0, vary=False)
                        fitter = Minimizer(
                            fgl2, pars, fcn_args=(xx, yy-shirley_bg(yy)))
                        result = fitter.minimize()
                        a2 = toa2(xx)
                        checkfit()
                        if fit_warn == 1:
                            t = 5
                            while t > 0 and fit_warn == 1:
                                result = fitter.minimize()
                                a2 = toa2(xx)
                                checkfit()
                                t -= 1

                if bg_warn == 0 and fit_warn == 0:  # shirley base line warn
                    if i not in efi:
                        efi.append(i)
                    if i in efi_x:
                        efi_x.remove(i)
                    if i in efi_err:
                        efi_err.remove(i)
                else:
                    if i not in efi_err:
                        efi_err.append(i)
                    if i in efi_x:
                        efi_x.remove(i)
                    if i in efi:
                        efi.remove(i)
        except RuntimeError:
            if i not in efi_err:
                efi_err.append(i)
            if i in efi_x:
                efi_x.remove(i)
            if i in efi:
                efi.remove(i)
            a1 = [(emin[i]+emax[i])/2, (np.max(y)-ebase[i]), 5, ebase[i]]
            a2 = [(emin[i]+emax[i])/2, (np.max(y)-ebase[i]), 5, ebase[i],
                  (emin[i]+emax[i])/2, (np.max(y)-ebase[i]), 5, ebase[i]]

        fexx[i, :len(xx)] = xx
        feyy[i, :len(yy)] = yy
        fex[i, :] = x
        fey[i, :] = y
        evv[i] = phi[i]
        if efp[i] == 1:
            eaa1[i, :] = a1
        elif efp[i] == 2:
            eaa2[i, :] = a2
        pbar.update(1)
        # print('Fitting EDC '+str(round((i+1)/len(phi)*100))+'%'+' ('+str(len(phi))+')')
        st.put('Fitting EDC '+str(round((i+1)/len(phi)*100)) +
               '%'+' ('+str(len(phi))+')')
        est.put('Fitting EDC '+str(round((i+1)/len(phi)*100)) +
                '%'+' ('+str(len(phi))+')')
    pbar.close()
    efitplot()


def efit():
    global fexx, feyy, fex, fey, evv, eaa1, eaa2, emin, emax, efi, efi_err, efi_x, result, fa1, fa2, fit_warn, bg_warn
    efi, efi_err, efi_x = list(efi), list(efi_err), list(efi_x)
    i = efiti.get()
    ebase[i] = int(base.get())  # 待調整
    fexx[i, :] = fexx[i, :]/fexx[i, :]*-50
    feyy[i, :] = feyy[i, :]/feyy[i, :]*-50
    angcut = data.sel(phi=phi[i], method='nearest')
    x = ev
    y = angcut.to_numpy().reshape(len(x))
    tx = x[np.argwhere(x >= emin[i])].flatten()
    xx = tx[np.argwhere(tx <= emax[i])].flatten()
    ty = y[np.argwhere(x >= emin[i])].flatten()
    yy = ty[np.argwhere(tx <= emax[i])].flatten()
    yy = np.where(yy > ebase[i], yy, ebase[i])
    try:
        if efp[i] == 1:
            a1, b = curve_fit(gl1, xx, yy-shirley_bg(yy), bounds=(
                [emin[i], (np.max(y)-ebase[i])/10, 0, 0], [emax[i], np.max(y)-ebase[i]+1, 3, 0.01]))
            fit_warn = 0
        elif efp[i] == 2:
            pars = Parameters()
            wr1, wr2 = int(ewf1.get()), int(ewf2.get())
            fa1, fa2 = int(eaf1.get()), int(eaf2.get())
            pars.add('x1', value=emin[i]+(emax[i]-emin[i])
                     * 0.4, min=emin[i], max=emax[i])
            pars.add('x2', value=emax[i]-(emax[i]-emin[i])
                     * 0.4, min=emin[i], max=emax[i])
            pars.add('h1', value=(
                np.max(y)-ebase[i])+1, min=(np.max(y)-ebase[i])/10, max=np.max(y)-ebase[i]+1)
            pars.add('h2', value=(
                np.max(y)-ebase[i])+1, min=(np.max(y)-ebase[i])/10, max=np.max(y)-ebase[i]+1)
            pars.add('w1', value=1, min=0, max=3)
            if wr1 != 0 and wr2 != 0:
                pars.add('wr1', value=wr1, vary=False)
                pars.add('wr2', value=wr2, vary=False)
                pars.add('w2', expr='w1/wr1*wr2')
            else:
                pars.add('w2', value=1, min=0, max=3)
            pars.add('y1', value=0, vary=False)
            pars.add('y2', value=0, vary=False)
            fitter = Minimizer(fgl2, pars, fcn_args=(xx, yy-shirley_bg(yy)))
            result = fitter.minimize()
            a2 = toa2(xx)
            checkfit()
            if fit_warn == 1:
                t = 5
                while t > 0 and fit_warn == 1:
                    result = fitter.minimize()
                    a2 = toa2(xx)
                    checkfit()
                    t -= 1
            report_fit(result)

        if (emin[i], emax[i]) == (np.min(ev), np.max(ev)):
            if i not in efi_x:
                efi_x.append(i)
            if i in efi:
                efi.remove(i)
            if i in efi_err:
                efi_err.remove(i)
        elif (emin[i], emax[i]) != (np.min(ev), np.max(ev)):
            if bg_warn == 0 and fit_warn == 0:  # shirley base line warn
                if i not in efi:
                    efi.append(i)
                if i in efi_x:
                    efi_x.remove(i)
                if i in efi_err:
                    efi_err.remove(i)
            else:
                if i not in efi_err:
                    efi_err.append(i)
                if i in efi_x:
                    efi_x.remove(i)
                if i in efi:
                    efi.remove(i)
    except RuntimeError:
        if i not in efi_err:
            efi_err.append(i)
        if i in efi_x:
            efi_x.remove(i)
        if i in efi:
            efi.remove(i)
        a1 = [(emin[i]+emax[i])/2, (np.max(y)-ebase[i]), 5, ebase[i]]
        a2 = [(emin[i]+emax[i])/2, (np.max(y)-ebase[i]), 5, ebase[i],
              (emin[i]+emax[i])/2, (np.max(y)-ebase[i]), 5, ebase[i]]

    fexx[i, :len(xx)] = xx
    feyy[i, :len(yy)] = yy
    fex[i, :] = x
    fey[i, :] = y
    evv[i] = phi[i]
    if efp[i] == 1:
        eaa1[i, :] = a1
    elif efp[i] == 2:
        eaa2[i, :] = a2


def fermv():
    global ebrmv, flermv, eirmv, emin, emax, efi, efi_err, efi_x, cei, efp
    i = efiti.get()
    flermv *= -1
    if flermv == 1:
        eirmv = i
        ebrmv.config(text='End Remove', bg='red')
    else:
        ti = sorted([i, eirmv])
        for i in np.linspace(ti[0], ti[1], ti[1]-ti[0]+1, dtype=int):
            efp[i] = 1
            emin[i], emax[i] = np.min(ev), np.max(ev)
            if i not in efi_x:
                efi_x.append(i)
            if i in efi:
                efi.remove(i)
            if i in efi_err:
                efi_err.remove(i)
            if i in cei:
                cei.remove(i)
        eplfi()
        ebrmv.config(text='Start Remove', bg='white')
        efitplot()


def feedmove(event):
    global eedxdata, eedydata, eedfitout
    if event.xdata != None:
        eedfitout.get_tk_widget().config(cursor="crosshair")
        eedxdata.config(text='xdata:'+str('%.3f' % event.xdata))
        eedydata.config(text='ydata:'+str('%.3f' % event.ydata))
    else:
        eedfitout.get_tk_widget().config(cursor="")
        try:
            eedxdata.config(text='xdata:')
            eedydata.config(text='ydata:')
        except NameError:
            pass


def saveefit():
    global epos, efwhm, fphi, efwhm, epos, semin, semax, seaa1, seaa2, sefp, sefi
    path = fd.asksaveasfilename(title="Save EDC Fitted Data", initialdir=dpath,
                                initialfile=name+"_efit", filetype=[("NPZ files", ".npz"),], defaultextension=".npz")
    if len(path) > 2:
        global eendg
        try:
            egg.focus_set()
            eendg.destroy()
        except:
            pass
        efwhm = res(sefi, efwhm)
        epos = res(sefi, epos)
        # semin = res(sefi, semin)
        # semax = res(sefi, semax)
        # sefp = res(sefi, sefp)
        fphi = res(sefi, fphi)
        sefi = res(sefi, sefi)
        np.savez(path, path=dpath, fphi=fphi, efwhm=efwhm, epos=epos, semin=semin,
                 semax=semax, seaa1=seaa1, seaa2=seaa2, sefp=sefp, sefi=sefi)
    else:
        egg.focus_set()
        eendg.focus_set()

scei = []


def feend():
    global epos, efwhm, fphi, eedxdata, eedydata, eedfitout, semin, semax, seaa1, seaa2, sefp, sefi, fk, fpr, scei, eendg
    fphi, epos, efwhm = [], [], []
    semin, semax, seaa1, seaa2 = emin, emax, eaa1, eaa2
    sefp = efp
    sefi = efi
    for i, v in enumerate(efi):
        if efp[v] == 1:
            fphi.append(phi[v])
            epos.append(eaa1[v, 0])
            efwhm.append(eaa1[v, 2])
        elif efp[v] == 2:
            fphi.append(phi[v])
            fphi.append(phi[v])
            epos.append(eaa2[v, 0])
            epos.append(eaa2[v, 4])
            efwhm.append(eaa2[v, 2])
            efwhm.append(eaa2[v, 6])
            
    efwhm = res(sefi, efwhm)
    epos = res(sefi, epos)
    # semin = res(sefi, semin)
    # semax = res(sefi, semax)
    # sefp = res(sefi, sefp)
    fphi = res(sefi, fphi)
    sefi = res(sefi, sefi)
            
    fphi, epos, efwhm = np.float64(fphi), np.float64(epos), np.float64(efwhm)
    ffphi = np.float64(k_offset.get())+fphi
    fk = (2*m*epos*1.602176634*10**-19)**0.5 * \
        np.sin(ffphi/180*np.pi)*10**-10/(h/2/np.pi)
    scei = cei
    fpr = 1
    try:
        eendg.destroy()
    except:
        pass
    eendg = tk.Toplevel(g)
    eendg.title('EDC Lorentz Fit Result')
    fr = tk.Frame(master=eendg, bd=5)
    fr.grid(row=0, column=0)
    efitfig = Figure(figsize=(8, 6), layout='constrained')
    eedfitout = FigureCanvasTkAgg(efitfig, master=fr)
    eedfitout.get_tk_widget().grid(row=0, column=0)
    eedfitout.mpl_connect('motion_notify_event', feedmove)

    a = efitfig.subplots()
    a.scatter(fphi, epos+efwhm/2, c='r', s=10)
    a.scatter(fphi, epos-efwhm/2, c='r', s=10)
    a.scatter(fphi, epos, c='k', s=10)
    if npzf:a.set_xlabel(r'k ($\frac{2\pi}{\AA}$)')
    else:a.set_xlabel('Angle (deg)')
    a.set_ylabel('Kinetic Energy (eV)', fontsize=14)
    eedfitout.draw()

    xydata = tk.Frame(master=fr, bd=5)
    xydata.grid(row=1, column=0)

    eedxdata = tk.Label(xydata, text='xdata:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=10, bg='white')
    eedxdata.grid(row=0, column=0)
    eedydata = tk.Label(xydata, text='ydata:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=10, bg='white')
    eedydata.grid(row=0, column=1)

    bsave = tk.Button(master=eendg, text='Save Fitted Data', command=saveefit,
                      width=30, height=1, font=('Arial', 14, "bold"), bg='white', bd=10)
    bsave.grid(row=1, column=0)

    eendg.update()


def fefall():
    t = threading.Thread(target=efitjob)
    t.daemon = True
    t.start()


def func_cei():
    global cei, emin, emax
    if efiti.get() not in cei:
        cei.append(efiti.get())
    if len(cei) >= 2:
        cei.sort()
        for i in range(len(cei)-1):
            emin[cei[i]:cei[i+1] +
                 1] = np.linspace(emin[cei[i]], emin[cei[i+1]], cei[i+1]-cei[i]+1)
            emax[cei[i]:cei[i+1] +
                 1] = np.linspace(emax[cei[i]], emax[cei[i+1]], cei[i+1]-cei[i]+1)


def fchei(*e):
    global efitout, edxdata, edydata
    try:
        efitout.get_tk_widget().delete('rec')
        edxdata.config(text='dx:')
        edydata.config(text='dy:')
    except:
        pass
    efitplot()


def eplfi():
    global eiout, eifig, elind, erind
    i = efiti.get()
    eifig.clear()
    eiax = eifig.add_axes([0, 0, 1, 1])
    eiax.scatter(efi_x, [0 for i in range(len(efi_x))], marker='|', c='k')
    eiax.scatter(efi, [0 for i in range(len(efi))], marker='|', c='b')
    eiax.scatter(efi_err, [0 for i in range(len(efi_err))], marker='|', c='r')
    if i in efi_x:
        elind.config(bg='white')
        erind.config(bg='white')
    if i in efi:
        elind.config(bg='blue')
        erind.config(bg='blue')
    if i in efi_err:
        elind.config(bg='red')
        erind.config(bg='red')
    try:
        eiax.set_xlim([np.min([efi, efi_x, efi_err]),
                      np.max([efi, efi_x, efi_err])])
    except ValueError:
        pass
    eiax.set_yticks([])
    eiout.draw()


def efitplot():  # efiti Scale
    global efitax, exl, eyl, elmin, elmax, texl, emin, emax
    i = efiti.get()
    efitfig.clear()
    efitax = efitfig.subplots()
    # 'Pos:'+str(round(eaa1[i,0],3))+' (eV)'+', FWHM:'+str(round(eaa1[i,2],3))+' (eV)'
    if npzf:
        efitax.set_title('k:'+str(round(evv[i], 3))+r' ($\frac{2\pi}{\AA}$)'+', '+str(efp[i])+' Peak')
    else:
        efitax.set_title('Deg:'+str(round(evv[i], 3))+r' $^{\circ}$'+', '+str(efp[i])+' Peak')
    efitax.scatter(fex[i, :], fey[i, :], c='k', s=4)
    sbg = shirley_bg(feyy[i, np.argwhere(feyy[i, :] >= -20)])
    if efp[i] == 1:
        if eaa1[i, 0] == (emin[i]+emax[i])/2 and eaa1[i, 2] == 5:
            fl, = efitax.plot(fexx[i, np.argwhere(fexx[i, :] >= -20)], gl1(
                fexx[i, np.argwhere(fexx[i, :] >= -20)], *eaa1[i, :])+sbg, 'r-', lw=2)
        else:
            gl1_1 = np.float64(np.concatenate(
                gl1(fexx[i, np.argwhere(fexx[i, :] >= -20)], *eaa1[i, :]))+sbg.transpose())
            fl, = efitax.plot(fexx[i, np.argwhere(fexx[i, :] >= -20)], gl1(
                fexx[i, np.argwhere(fexx[i, :] >= -20)], *eaa1[i, :])+sbg, 'b-', lw=2)
            efitax.fill_between(np.concatenate((fexx[i, np.argwhere(fexx[i, :] >= -20)])), np.float64(
                np.concatenate(sbg.transpose())), np.concatenate(gl1_1), facecolor='blue', alpha=0.5)

    elif efp[i] == 2:
        if eaa2[i, 0] == (emin[i]+emax[i])/2 and eaa2[i, 2] == 5:
            fl, = efitax.plot(fexx[i, np.argwhere(fexx[i, :] >= -20)], gl2(
                fexx[i, np.argwhere(fexx[i, :] >= -20)], *eaa2[i, :])+sbg, 'r-', lw=2)
        else:
            gl2_1 = np.float64(np.concatenate(
                gl1(fexx[i, np.argwhere(fexx[i, :] >= -20)], *eaa2[i, :4]))+sbg.transpose())
            gl2_2 = np.float64(np.concatenate(
                gl1(fexx[i, np.argwhere(fexx[i, :] >= -20)], *eaa2[i, -4:]))+sbg.transpose())
            fl, = efitax.plot(fexx[i, np.argwhere(fexx[i, :] >= -20)], gl2(
                fexx[i, np.argwhere(fexx[i, :] >= -20)], *eaa2[i, :])+sbg, 'b-', lw=2)
            efitax.fill_between(np.concatenate(fexx[i, np.argwhere(fexx[i, :] >= -20)]), np.float64(
                np.concatenate(sbg.transpose())), np.concatenate(gl2_1), facecolor='green', alpha=0.5)
            efitax.fill_between(np.concatenate(fexx[i, np.argwhere(fexx[i, :] >= -20)]), np.float64(
                np.concatenate(sbg.transpose())), np.concatenate(gl2_2), facecolor='purple', alpha=0.5)

    if bg_warn == 1:  # shirley base line warn
        efitax.plot(fexx[i, np.argwhere(fexx[i, :] >= -20)], sbg, 'r--')
    else:
        efitax.plot(fexx[i, np.argwhere(fexx[i, :] >= -20)], sbg, 'g--')

    efitax.scatter(fexx[i, np.argwhere(fexx[i, :] >= -20)],
                   feyy[i, np.argwhere(feyy[i, :] >= -20)], c='g', s=4)
    if (emin[i], emax[i]) != (np.min(ev), np.max(ev)):
        elmin = efitax.axvline(emin[i], c='r')
        elmax = efitax.axvline(emax[i], c='r')
    else:
        elmin = efitax.axvline(emin[i], c='grey')
        elmax = efitax.axvline(emax[i], c='grey')
        fl.set_alpha(0.3)

    efitax.set_xlabel('Kinetic Energy (eV)', fontsize=14)
    efitax.set_ylabel('Intensity (Counts)', fontsize=14)
    exl = efitax.get_xlim()
    eyl = efitax.get_ylim()
    texl = np.copy(exl)
    efitout.draw()
    eplfi()


def emove(event):
    global exdata, eydata, edxdata, edydata, x2, y2, efitax, efitout, elmin, elmax, emin, emax, tpx1, tpx2, tpy1, tpy2, tx2, ty2
    if event.xdata != None:
        if emof == -1:
            x2, y2 = event.xdata, event.ydata
            px2, py2 = event.x, event.y

            if felmin == 1 and temin+(x2-x1) >= exl[0] and temin+(x2-x1) <= exl[1]:
                elmin.remove()
                elmin = efitax.axvline(x2, c='r')
                emin[efiti.get()] = x2
                elmax.set_color('r')
                efitout.draw()
            elif felmax == 1 and temax+(x2-x1) >= exl[0] and temax+(x2-x1) <= exl[1]:
                elmax.remove()
                elmax = efitax.axvline(x2, c='r')
                emax[efiti.get()] = x2
                elmin.set_color('r')
                efitout.draw()
            elif feregion == 1 and temin+(x2-x1) >= exl[0] and temax+(x2-x1) <= exl[1]:
                elmin.remove()
                elmin = efitax.axvline(temin+(x2-x1), c='r')
                emin[efiti.get()] = temin+(x2-x1)
                elmax.remove()
                elmax = efitax.axvline(temax+(x2-x1), c='r')
                emax[efiti.get()] = temax+(x2-x1)
                efitout.draw()
            elif felmin == 0 and felmax == 0 and feregion == 0:
                efitout.get_tk_widget().delete('rec')
                tpx1, tpy1, tpx2, tpy2 = px1, py1, px2, py2
                efitout.get_tk_widget().create_rectangle(
                    (px1, 600-py1), (px2, 600-py2), outline='grey', width=2, tag='rec')
                [tpx1, tpx2] = sorted([tpx1, tpx2])
                [tpy1, tpy2] = sorted([tpy1, tpy2])
                tx2, ty2 = x2, y2
                edxdata.config(text='dx:'+str('%.3f' % abs(x2-x1)))
                edydata.config(text='dy:'+str('%.3f' % abs(y2-y1)))
        exdata.config(text='xdata:'+str('%.3f' % event.xdata))
        eydata.config(text='ydata:'+str('%.3f' % event.ydata))
    else:
        efitout.get_tk_widget().config(cursor="")
        try:
            exdata.config(text='xdata:')
            eydata.config(text='ydata:')
        except NameError:
            pass

    # print("event.xdata", event.xdata)
    # print("event.ydata", event.ydata)
    # print("event.inaxes", event.inaxes)
    # print("x", event.x)
    # print("y", event.y)
emof = 1


def epress(event):
    # event.button 1:left 3:right 2:mid
    # event.dblclick : bool
    # print('%s click: button=%d, x=%d, y=%d, xdata=%f, ydata=%f' %
    #       ('double' if event.dblclick else 'single', event.button,
    #        event.x, event.y, event.xdata, event.ydata))
    global x1, y1, emof, px1, py1, efitax, efitout, elmin, elmax, felmin, felmax, cei, ebase, feregion, temin, temax, tx1, ty1
    if event.button == 1 and event.inaxes:
        x1, y1 = event.xdata, event.ydata
        px1, py1 = event.x, event.y
        felmin, felmax, feregion = 0, 0, 0
        temin, temax = emin[efiti.get()], emax[efiti.get()]
        if efitout.get_tk_widget().find_withtag('rec') != () and px1 > tpx1 and px1 < tpx2 and py1 > tpy1 and py1 < tpy2:
            pass
        elif abs(x1-emin[efiti.get()]) < (texl[1]-texl[0])/80:
            felmin = 1

        elif abs(x1-emax[efiti.get()]) < (texl[1]-texl[0])/80:
            felmax = 1

        elif x1 > emin[efiti.get()] and x1 < emax[efiti.get()]:
            feregion = 1

        elif efitout.get_tk_widget().find_withtag('rec') == ():
            tx1, ty1 = x1, y1
        emof = -1
    elif event.button == 3:
        try:
            efitout.get_tk_widget().delete('rec')
            edxdata.config(text='dx:')
            edydata.config(text='dy:')
        except:
            pass
        efitax.set_xlim(exl)
        efitax.set_ylim(eyl)
        efitout.draw()
        emof = 1


def erelease(event):
    global x1, y1, x2, y2, emof, efitout, efitax, felmax, felmin, elmin, elmax, emin, emax, feregion, texl
    if event.button == 1 and emof == -1 and event.inaxes:
        x2, y2 = event.xdata, event.ydata
        if emin[efiti.get()] > emax[efiti.get()]:
            emin[efiti.get()], emax[efiti.get()
                                    ] = emax[efiti.get()], emin[efiti.get()]
            elmin, elmax = elmax, elmin
        else:
            emin[efiti.get()], emax[efiti.get()
                                    ] = emin[efiti.get()], emax[efiti.get()]
            elmin, elmax = elmin, elmax
        if felmin == 0 and felmax == 0 and feregion == 0 and (x2, y2) == (x1, y1) and px1 > tpx1 and px1 < tpx2 and py1 > tpy1 and py1 < tpy2:
            try:
                efitout.get_tk_widget().delete('rec')
            except:
                pass
            efitax.set_xlim(sorted([tx1, tx2]))
            efitax.set_ylim(sorted([ty1, ty2]))
            texl = sorted([x1, x2])
            efitout.draw()
        elif felmin == 1 or felmax == 1 or feregion == 1:
            func_cei()
            x1, x2, y1, y2 = [], [], [], []
            efit()
            efitplot()
        emof = 1


def testate():
    try:
        while True:
            estate.config(text=str(est.get()))
    except KeyboardInterrupt:
        pass


def eflind():
    global efiti
    ti = efiti.get()
    if ti in efi:
        for i in range(ti+1):
            if ti-i not in efi:
                efiti.set(ti-i)
                break
    elif ti in efi_err:
        for i in range(ti+1):
            if ti-i not in efi_err:
                efiti.set(ti-i)
                break
    elif ti in efi_x:
        for i in range(ti+1):
            if ti-i in efi or ti-i in efi_err:
                efiti.set(ti-i)
                break
        if i == ti and ti != 0:
            efiti.set(ti-1)


def efrind():
    global efiti
    ti = efiti.get()
    if ti in efi:
        for i in range(len(phi)-ti):
            if ti+i not in efi:
                efiti.set(ti+i)
                break
    elif ti in efi_err:
        for i in range(len(phi)-ti):
            if ti+i not in efi_err:
                efiti.set(ti+i)
                break
    elif ti in efi_x:
        for i in range(len(phi)-ti):
            if ti+i in efi or ti+i in efi_err:
                efiti.set(ti+i)
                break
        if i == len(phi)-ti-1 and ti != len(phi)-1:
            efiti.set(ti+1)


def o_fewf1(*e):
    global ewf1
    if '' == ewf1.get():
        ewf1.set('0')
        ein_w1.select_range(0, 1)


def fewf1(*e):
    t = threading.Thread(target=o_fewf1)
    t.daemon = True
    t.start()


def o_fewf2(*e):
    global ewf2
    if '' == ewf2.get():
        ewf2.set('0')
        ein_w2.select_range(0, 1)


def fewf2(*e):
    t = threading.Thread(target=o_fewf2)
    t.daemon = True
    t.start()


def o_feaf1(*e):
    global eaf1
    if '' == eaf1.get():
        eaf1.set('0')
        ein_a1.select_range(0, 1)


def feaf1(*e):
    t = threading.Thread(target=o_feaf1)
    t.daemon = True
    t.start()


def o_feaf2(*e):
    global eaf2
    if '' == eaf2.get():
        eaf2.set('0')
        ein_a2.select_range(0, 1)


def feaf2(*e):
    t = threading.Thread(target=o_feaf2)
    t.daemon = True
    t.start()


def ejob():     # MDC Fitting GUI
    global g, efiti, efitfig, efitout, egg, exdata, eydata, edxdata, edydata, eiout, eifig, efi, efi_err, efi_x, ebrmv, flermv, ebcgl2, efp, flecgl2, fpr, est, estate, ewf1, ewf2, eaf1, eaf2, elind, erind, ein_w1, ein_w2, ein_a1, ein_a2
    egg = tk.Toplevel(g, bg='white')
    egg.geometry(f"1900x1000+0+0")
    egg.title('EDC Lorentz Fit')
    est = queue.Queue(maxsize=0)
    estate = tk.Label(egg, text='', font=(
        "Arial", 14, "bold"), bg="white", fg="black")
    estate.grid(row=0, column=0)

    fr = tk.Frame(master=egg, bg='white')
    fr.grid(row=1, column=0)
    frind = tk.Frame(master=fr, bg='white')
    frind.grid(row=0, column=0)
    elind = tk.Button(frind, text='<<', command=eflind, width=10,
                      height=5, font=('Arial', 12, "bold"), bg='white')
    elind.grid(row=0, column=0)
    erind = tk.Button(frind, text='>>', command=efrind, width=10,
                      height=5, font=('Arial', 12, "bold"), bg='white')
    erind.grid(row=0, column=2)

    efiti = tk.IntVar()
    efiti.set(0)
    efiti.trace_add('write', fchei)
    chi = tk.Scale(frind, label='Index', from_=0, to=len(phi)-1, orient='horizontal',
                   variable=efiti, state='active', bg='white', fg='black', length=580, width=50, resolution=1)
    chi.grid(row=0, column=1)

    efi, efi_err, efi_x = [], [], [i for i in range(len(phi))]
    eifig = Figure(figsize=(6, 0.2), layout='tight')
    eiout = FigureCanvasTkAgg(eifig, master=frind)
    eiout.get_tk_widget().grid(row=1, column=1)

    efitfig = Figure(figsize=(8, 6), layout='constrained')
    efitout = FigureCanvasTkAgg(efitfig, master=fr)
    efitout.get_tk_widget().grid(row=1, column=0)
    efitout.mpl_connect('motion_notify_event', emove)
    efitout.mpl_connect('button_press_event', epress)
    efitout.mpl_connect('button_release_event', erelease)

    xydata = tk.Frame(master=fr, bd=5, bg='white')
    xydata.grid(row=2, column=0)

    exdata = tk.Label(xydata, text='xdata:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=5, bg='white')
    exdata.grid(row=0, column=0)
    eydata = tk.Label(xydata, text='ydata:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=5, bg='white')
    eydata.grid(row=0, column=1)
    edxdata = tk.Label(xydata, text='dx:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=5, bg='white')
    edxdata.grid(row=0, column=2)
    edydata = tk.Label(xydata, text='dy:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=5, bg='white')
    edydata.grid(row=0, column=3)

    frpara = tk.Frame(master=egg, bd=5, bg='white')
    frpara.grid(row=1, column=1)
    try:
        if fpr == 1:
            efp = list(sefp)
            efi = list(sefi)
        else:
            efp = [1 for i in range(len(phi))]
    except:
        efp = [1 for i in range(len(phi))]
    flecgl2 = -1
    frpara00 = tk.Frame(master=frpara, bd=5, bg='white')
    frpara00.grid(row=0, column=0)
    l1 = tk.Label(frpara00, text='Index Operation', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=5, bg='white')
    l1.grid(row=0, column=0)
    froperind = tk.Frame(master=frpara00, bd=5, bg='white')
    froperind.grid(row=1, column=0)
    ebcgl2 = tk.Button(froperind, text='Start Add 2 Peaks', command=fecgl2,
                       width=30, height=1, font=('Arial', 16, "bold"), bg='white')
    ebcgl2.grid(row=0, column=0)
    ebrmv = tk.Button(froperind, text='Start Remove', command=fermv,
                      width=30, height=1, font=('Arial', 16, "bold"), bg='white')
    ebrmv.grid(row=0, column=1)

    frwr = tk.Frame(master=froperind, bd=5, bg='white')
    frwr.grid(row=1, column=0)
    l2 = tk.Label(frwr, text='FWHM Ratio', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=5, bg='white')
    l2.grid(row=0, column=1)
    l3 = tk.Label(frwr, text=':', font=("Arial", 12, "bold"),
                  width='15', height='1', bd=5, bg='white')
    l3.grid(row=1, column=1)
    ewf1 = tk.StringVar()
    ewf1.set('0')
    ewf1.trace_add('write', fewf1)
    ein_w1 = tk.Entry(frwr, font=("Arial", 12, "bold"),
                      width=7, textvariable=ewf1, bd=5)
    ein_w1.grid(row=1, column=0)
    ewf2 = tk.StringVar()
    ewf2.set('0')
    ewf2.trace_add('write', fewf2)
    ein_w2 = tk.Entry(frwr, font=("Arial", 12, "bold"),
                      width=7, textvariable=ewf2, bd=5)
    ein_w2.grid(row=1, column=2)

    frar = tk.Frame(master=froperind, bd=5, bg='white')
    frar.grid(row=2, column=0)
    l2 = tk.Label(frar, text='Area Ratio', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=5, bg='white')
    l2.grid(row=0, column=1)
    l3 = tk.Label(frar, text=':', font=("Arial", 12, "bold"),
                  width='15', height='1', bd=5, bg='white')
    l3.grid(row=1, column=1)
    eaf1 = tk.StringVar()
    eaf1.set('0')
    eaf1.trace_add('write', feaf1)
    ein_a1 = tk.Entry(frar, font=("Arial", 12, "bold"),
                      width=7, textvariable=eaf1, bd=5)
    ein_a1.grid(row=1, column=0)
    eaf2 = tk.StringVar()
    eaf2.set('0')
    eaf2.trace_add('write', feaf2)
    ein_a2 = tk.Entry(frar, font=("Arial", 12, "bold"),
                      width=7, textvariable=eaf2, bd=5)
    ein_a2.grid(row=1, column=2)

    frout = tk.Frame(master=egg, bd=5, bg='white')
    frout.grid(row=2, column=0)
    bfall = tk.Button(frout, text='Fit All', command=fefall,
                      width=30, height=1, font=('Arial', 14, "bold"), bg='white')
    bfall.grid(row=0, column=0)
    flermv = -1
    bend = tk.Button(frout, text='Finish', command=feend, width=30,
                     height=1, font=('Arial', 16, "bold"), bg='white')
    bend.grid(row=1, column=0)

    if eprfit == 1:
        fefall()
    else:
        efitplot()
    tt = threading.Thread(target=testate)
    tt.daemon = True
    tt.start()
    egg.update_idletasks()
    screen_width = egg.winfo_reqwidth()
    screen_height = egg.winfo_reqheight()
    egg.geometry(f"{screen_width}x{screen_height}+0+0")
    egg.update()

def fmcgl2():
    global mbcgl2, kmin, kmax, flmcgl2, micgl2, mfp, mbcomp1, mbcomp2, flmcomp1, flmcomp2
    msave_state()
    mbcomp1.config(state='active')
    mbcomp2.config(state='active')
    flmcomp1, flmcomp2 = -1, -1
    i = mfiti.get()
    flmcgl2 *= -1
    if flmcgl2 == 1:
        micgl2 = i
        mbcgl2.config(text='End Add 2 Peaks', bg='red')
    else:
        ti = sorted([i, micgl2])
        for i in np.linspace(ti[0], ti[1], ti[1]-ti[0]+1, dtype=int):
            mfp[i] = 2
            if i not in mfi_x:
                mfi_x.append(i)
            if i in mfi:
                mfi.remove(i)
            if i in mfi_err:
                mfi_err.remove(i)
        mbcgl2.config(text='Add 2 Peaks', bg='white')
        mfitplot()

def pack_fitpar(mresult):
    if len(smresult) > 1:
        o=smresult
        for ii,result in enumerate(mresult):
            try:
                s = putfitpar(result)
                for i in range(len(o[ii])):
                    o[ii][i]=""
                for i in s:
                    '''preprocess the string to put values in the labels'''
                    if 'x1*xr1+xr2' in i:
                        if xr2>=0:
                            i = i.replace(' == \'x1*xr1+xr2\'', '='+str(xr1)+'*x1+'+str(xr2))
                        else:
                            i = i.replace(' == \'x1*xr1+xr2\'', '='+str(xr1)+'*x1-'+str(-xr2))
                    if 'x2*xr1+xr2' in i:
                        if xr2>=0:
                            i = i.replace(' == \'x2*xr1+xr2\'', '='+str(xr1)+'*x2+'+str(xr2))
                        else:
                            i = i.replace(' == \'x2*xr1+xr2\'', '='+str(xr1)+'*x2-'+str(-xr2))
                    if "(x2-xr2) / xr1" in i:
                        if xr2>=0:
                            i = i.replace(' == \'(x2-xr2) / xr1\'','=(x2-'+str(xr2) + ')/'+str(xr1))
                        else:
                            i = i.replace(' == \'(x2-xr2) / xr1\'','=(x2+'+str(-xr2) + ')/'+str(xr1))
                    if "(x1-xr2) / xr1" in i:
                        if xr2>=0:
                            i = i.replace(' == \'(x1-xr2) / xr1\'','=(x1-'+str(xr2) + ')/'+str(xr1))
                        else:
                            i = i.replace(' == \'(x1-xr2) / xr1\'','=(x1+'+str(-xr2) + ')/'+str(xr1))
                    if 'w1/wr1*wr2' in i:
                        i = i.replace(' == \'w1/wr1*wr2\'', '=w1/'+str(wr1)+'*'+str(wr2))
                    if 'w2/wr1*wr2' in i:
                        i = i.replace(' == \'w2/wr1*wr2\'', '=w2/'+str(wr1)+'*'+str(wr2))
                        
                    '''assign the values to the labels'''
                    if 'x:' in i:
                        o[ii][0]=i
                    if 'h:' in i:
                        o[ii][1]=i
                    if 'w:' in i:
                        o[ii][2]=i
                    if 'x1:' in i:
                        o[ii][0]=i
                    if 'x2:' in i:
                        o[ii][1]=i
                    if 'h1:' in i:
                        o[ii][2]=i
                    if 'h2:' in i:
                        o[ii][3]=i
                    if 'w1:' in i:
                        o[ii][4]=i
                    if 'w2:' in i:
                        o[ii][5]=i
            except:
                pass
    else:
        o=[[]for i in range(len(mresult))]
        for ii,result in enumerate(mresult):
            try:
                s = putfitpar(result)
            except:
                s=[]
                if mfp[ii]==2:
                    for i in ['x1: nofit','x2: nofit','h1: nofit','h2: nofit','w1: nofit','w2: nofit']:
                        s.append(i)
                elif mfp[ii]==1:
                    for i in ['x: nofit','h: nofit','w: nofit','n1: nofit','n2: nofit','n3: nofit']:
                        s.append(i)
            for i in s:
                if 'nofit' in i:
                    o[ii].append(i)
                else:
                    '''preprocess the string to put values in the labels'''
                    if 'x1*xr1+xr2' in i:
                        if xr2>=0:
                            i = i.replace(' == \'x1*xr1+xr2\'', '='+str(xr1)+'*x1+'+str(xr2))
                        else:
                            i = i.replace(' == \'x1*xr1+xr2\'', '='+str(xr1)+'*x1-'+str(-xr2))
                    if 'x2*xr1+xr2' in i:
                        if xr2>=0:
                            i = i.replace(' == \'x2*xr1+xr2\'', '='+str(xr1)+'*x2+'+str(xr2))
                        else:
                            i = i.replace(' == \'x2*xr1+xr2\'', '='+str(xr1)+'*x2-'+str(-xr2))
                    if "(x2-xr2) / xr1" in i:
                        if xr2>=0:
                            i = i.replace(' == \'(x2-xr2) / xr1\'','=(x2-'+str(xr2) + ')/'+str(xr1))
                        else:
                            i = i.replace(' == \'(x2-xr2) / xr1\'','=(x2+'+str(-xr2) + ')/'+str(xr1))
                    if "(x1-xr2) / xr1" in i:
                        if xr2>=0:
                            i = i.replace(' == \'(x1-xr2) / xr1\'','=(x1-'+str(xr2) + ')/'+str(xr1))
                        else:
                            i = i.replace(' == \'(x1-xr2) / xr1\'','=(x1+'+str(-xr2) + ')/'+str(xr1))
                    if 'w1/wr1*wr2' in i:
                        i = i.replace(' == \'w1/wr1*wr2\'', '=w1/'+str(wr1)+'*'+str(wr2))
                    if 'w2/wr1*wr2' in i:
                        i = i.replace(' == \'w2/wr1*wr2\'', '=w2/'+str(wr1)+'*'+str(wr2))
                        
                    '''assign the values to the labels'''
                    if 'x:' in i:
                        o[ii].append(i)
                    if 'h:' in i:
                        o[ii].append(i)
                    if 'w:' in i:
                        o[ii].append(i)
                        o[ii].append('')
                        o[ii].append('')
                        o[ii].append('')
                    if 'x1:' in i:
                        o[ii].append(i)
                    if 'x2:' in i:
                        o[ii].append(i)
                    if 'h1:' in i:
                        o[ii].append(i)
                    if 'h2:' in i:
                        o[ii].append(i)
                    if 'w1:' in i:
                        o[ii].append(i)
                    if 'w2:' in i:
                        o[ii].append(i)
    return o
def mfitjob():
    global fmxx, fmyy, fmx, fmy, mvv, maa1, maa2, kmin, kmax, mfi, mfi_err, mfi_x, st, mst, result, fa1, fa2, fit_warn, wr1, wr2, mresult, xr1, xr2, smcst
    if len(mfi) < 1:
        mfi, mfi_err, mfi_x = [], [], []
    else:
        mfi, mfi_err, mfi_x = list(mfi), list(mfi_err), list(mfi_x)
    msave_state()
    pbar = tqdm.tqdm(total=len(ev), desc='Fitting MDC', colour='green')
    for i in range(len(ev)):
        mbase[i] = int(base.get())  # 待調整
        # fmxx[i, :] = fmxx[i, :]/fmxx[i, :]*-50
        # fmyy[i, :] = fmyy[i, :]/fmyy[i, :]*-50
        ecut = data.sel(eV=ev[i], method='nearest')
        if npzf:x = phi
        else:x = (2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(phi/180*np.pi)*10**-10/(h/2/np.pi)
        y = ecut.to_numpy().reshape(len(x))
        xx, x_arg = filter(x, kmin[i], kmax[i])
        # tx = x[np.argwhere(x >= kmin[i])].flatten()
        # xx = tx[np.argwhere(tx <= kmax[i])].flatten()
        # ty = y[np.argwhere(x >= kmin[i])].flatten()
        # yy = ty[np.argwhere(tx <= kmax[i])].flatten()
        yy = y[x_arg]
        yy = np.where(yy > mbase[i], yy, mbase[i])
        try:
            # if (kmin[i],kmax[i])==((2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(-0.5/180*np.pi)*10**-10/(h/2/np.pi),(2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(0.5/180*np.pi)*10**-10/(h/2/np.pi)) and i not in mfi:
            # if i not in mfi:
            #     if i not in mfi_x:
            #         mfi_x.append(i)
            #     # if i in mfi:
            #     #     mfi.remove(i)
            #     if i in mfi_err:
            #         mfi_err.remove(i)
            #     a1=[(kmin[i]+kmax[i])/2,(np.max(y)-mbase[i]),5,mbase[i]]
            #     a2=[(kmin[i]+kmax[i])/2,(np.max(y)-mbase[i]),5,mbase[i],(kmin[i]+kmax[i])/2,(np.max(y)-mbase[i]),5,mbase[i]]
            # elif (kmin[i],kmax[i])!=((2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(-0.5/180*np.pi)*10**-10/(h/2/np.pi),(2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(0.5/180*np.pi)*10**-10/(h/2/np.pi)):
            if mfp[i] == 1:
                smcst[i] = [0, 0, 0, 0, 0, 0]
                if i in mfi_err and (kmin[i], kmax[i]) != ((2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(-0.5/180*np.pi)*10**-10/(h/2/np.pi), (2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(0.5/180*np.pi)*10**-10/(h/2/np.pi)):
                    pars = Parameters()
                    pars.add(
                        'x', value=kmin[i]+(kmax[i]-kmin[i])*0.3, min=kmin[i], max=kmax[i])
                    pars.add('h', value=(
                        np.max(y)-mbase[i])+1, min=(np.max(y)-mbase[i])/10, max=np.max(y)-mbase[i]+1)
                    pars.add('w', value=0.1, min=0.01, max=0.2)
                    pars.add('y', value=0, vary=False)
                    fitter = Minimizer(
                        fgl1, pars, fcn_args=(xx, yy-lnr_bg(yy)))
                    result = fitter.minimize()
                    a1 = toa1()
                    checkfit()
                    if fit_warn == 1:
                        t = 5
                        while t > 0 and fit_warn == 1:
                            result = fitter.minimize()
                            a1 = toa1()
                            checkfit()
                            t -= 1
                else:
                    if i in mfi:
                        result = mresult[i]
                    a1 = maa1[i, :]
                    if (kmin[i], kmax[i]) == ((2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(-0.5/180*np.pi)*10**-10/(h/2/np.pi), (2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(0.5/180*np.pi)*10**-10/(h/2/np.pi)):
                        fit_warn = 2
                    elif i not in mfi:
                        pars = Parameters()
                        pars.add(
                            'x', value=kmin[i]+(kmax[i]-kmin[i])*0.3, min=kmin[i], max=kmax[i])
                        pars.add('h', value=(
                            np.max(y)-mbase[i])+1, min=(np.max(y)-mbase[i])/10, max=np.max(y)-mbase[i]+1)
                        pars.add('w', value=0.1, min=0.01, max=0.2)
                        pars.add('y', value=0, vary=False)
                        fitter = Minimizer(
                            fgl1, pars, fcn_args=(xx, yy-lnr_bg(yy)))
                        result = fitter.minimize()
                        a1 = toa1()
                        checkfit()
                        if fit_warn == 1:
                            t = 5
                            while t > 0 and fit_warn == 1:
                                result = fitter.minimize()
                                a1 = toa1()
                                checkfit()
                                t -= 1
                    else:
                        fit_warn = 0
            elif mfp[i] == 2:
                if i in mfi_err and (kmin[i], kmax[i]) != ((2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(-0.5/180*np.pi)*10**-10/(h/2/np.pi), (2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(0.5/180*np.pi)*10**-10/(h/2/np.pi)):
                    pars = Parameters()
                    xr1, xr2 = float(mxf1.get()), float(mxf2.get())
                    wr1, wr2 = float(mwf1.get()), float(mwf2.get())
                    fa1, fa2 = float(maf1.get()), float(maf2.get())
                    smcst[i]=[xr1,xr2,wr1,wr2,fa1,fa2]
                    pars.add(
                        'x1', value=kmin[i]+(kmax[i]-kmin[i])*0.3, min=kmin[i], max=kmax[i])
                    if flmposcst == 1:
                        pars.add('xr1', value=xr1, vary=False)
                        pars.add('xr2', value=xr2, vary=False)
                        pars.add('x2', expr='x1*xr1+xr2')
                    else:
                        pars.add(
                            'x2', value=kmax[i]-(kmax[i]-kmin[i])*0.3, min=kmin[i], max=kmax[i])
                    pars.add('h1', value=(
                        np.max(y)-mbase[i])+1, min=(np.max(y)-mbase[i])/10, max=np.max(y)-mbase[i]+1)
                    pars.add('h2', value=(
                        np.max(y)-mbase[i])+1, min=(np.max(y)-mbase[i])/10, max=np.max(y)-mbase[i]+1)
                    pars.add('w1', value=0.02, min=0, max=0.2)
                    if wr1 != 0 and wr2 != 0:
                        pars.add('wr1', value=wr1, vary=False)
                        pars.add('wr2', value=wr2, vary=False)
                        pars.add('w2', expr='w1/wr1*wr2')
                    else:
                        pars.add('w2', value=0.02, min=0, max=0.2)
                    pars.add('y1', value=0, vary=False)
                    pars.add('y2', value=0, vary=False)
                    if fa1 != 0 and fa2 != 0:
                        fitter = Minimizer(
                            fgl2_a, pars, fcn_args=(xx, yy-lnr_bg(yy)))
                        result = fitter.minimize()
                    else:
                        fitter = Minimizer(
                            fgl2, pars, fcn_args=(xx, yy-lnr_bg(yy)))
                        result = fitter.minimize()
                    a2 = toa2(xx)
                    checkfit()
                    if fit_warn == 1:
                        t = 5
                        while t > 0 and fit_warn == 1:
                            result = fitter.minimize()
                            a2 = toa2(xx)
                            checkfit()
                            t -= 1
                else:
                    if i in mfi:
                        result = mresult[i]
                    a2 = maa2[i, :]
                    if (kmin[i], kmax[i]) == ((2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(-0.5/180*np.pi)*10**-10/(h/2/np.pi), (2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(0.5/180*np.pi)*10**-10/(h/2/np.pi)):
                        fit_warn = 2
                    elif i not in mfi:
                        pars = Parameters()
                        xr1, xr2 = float(mxf1.get()), float(mxf2.get())
                        wr1, wr2 = float(mwf1.get()), float(mwf2.get())
                        fa1, fa2 = float(maf1.get()), float(maf2.get())
                        smcst[i]=[xr1,xr2,wr1,wr2,fa1,fa2]
                        pars.add(
                            'x1', value=kmin[i]+(kmax[i]-kmin[i])*0.3, min=kmin[i], max=kmax[i])
                        if flmposcst == 1:
                            pars.add('xr1', value=xr1, vary=False)
                            pars.add('xr2', value=xr2, vary=False)
                            pars.add('x2', expr='x1*xr1+xr2')
                        else:
                            pars.add(
                                'x2', value=kmax[i]-(kmax[i]-kmin[i])*0.3, min=kmin[i], max=kmax[i])
                        pars.add('h1', value=(
                            np.max(y)-mbase[i])+1, min=(np.max(y)-mbase[i])/10, max=np.max(y)-mbase[i]+1)
                        pars.add('h2', value=(
                            np.max(y)-mbase[i])+1, min=(np.max(y)-mbase[i])/10, max=np.max(y)-mbase[i]+1)
                        pars.add('w1', value=0.02, min=0.01, max=0.2)
                        if wr1 != 0 and wr2 != 0:
                            pars.add('wr1', value=wr1, vary=False)
                            pars.add('wr2', value=wr2, vary=False)
                            pars.add('w2', expr='w1/wr1*wr2')
                        else:
                            pars.add('w2', value=0.02, min=0.01, max=0.2)
                        pars.add('y1', value=0, vary=False)
                        pars.add('y2', value=0, vary=False)
                        if fa1 != 0 and fa2 != 0:
                            fitter = Minimizer(
                                fgl2_a, pars, fcn_args=(xx, yy-lnr_bg(yy)))
                            result = fitter.minimize()
                        else:
                            fitter = Minimizer(
                                fgl2, pars, fcn_args=(xx, yy-lnr_bg(yy)))
                            result = fitter.minimize()
                        a2 = toa2(xx)
                        checkfit()
                        if fit_warn == 1:
                            t = 5
                            while t > 0 and fit_warn == 1:
                                result = fitter.minimize()
                                a2 = toa2(xx)
                                checkfit()
                                t -= 1
                    else:
                        fit_warn = 0
            try:
                '''using lmfit'''
                result=swapc1c2()
                mresult[i] = result
                result = []
            except:
                '''Casa Result'''
                pass
            if fit_warn == 0:
                if i not in mfi:
                    mfi.append(i)
                if i in mfi_x:
                    mfi_x.remove(i)
                if i in mfi_err:
                    mfi_err.remove(i)
            elif fit_warn == 2:
                if i not in mfi_x:
                    mfi_x.append(i)
                if i in mfi:
                    mfi.remove(i)
                if i in mfi_err:
                    mfi_err.remove(i)
            else:
                if i not in mfi_err:
                    mfi_err.append(i)
                if i in mfi_x:
                    mfi_x.remove(i)
                if i in mfi:
                    mfi.remove(i)
        except RuntimeError:
            print('runtime error')
            if i not in mfi_err:
                mfi_err.append(i)
            if i in mfi_x:
                mfi_x.remove(i)
            if i in mfi:
                mfi.remove(i)
            a1 = [(kmin[i]+kmax[i])/2, (np.max(y)-mbase[i]), 5, mbase[i]]
            a2 = [(kmin[i]+kmax[i])/2, (np.max(y)-mbase[i]), 5, mbase[i],
                  (kmin[i]+kmax[i])/2, (np.max(y)-mbase[i]), 5, mbase[i]]
        # fmxx[i, :len(xx)] = xx
        # fmyy[i, :len(yy)] = yy
        fmx[i, :] = x
        fmy[i, :] = y
        mvv[i] = ev[i]
        if mfp[i] == 1:
            maa1[i, :] = a1
        elif mfp[i] == 2:
            maa2[i, :] = a2
        pbar.update(1)
        # print('Fitting MDC '+str(round((i+1)/len(ev)*100))+'%'+' ('+str(len(ev))+')')
        st.put('Fitting MDC '+str(round((i+1)/len(ev)*100)) +
               '%'+' ('+str(len(ev))+')')
        mst.put('Fitting MDC '+str(round((i+1)/len(ev)*100)) +
                '%'+' ('+str(len(ev))+')')
    pbar.close()
    mfitplot()


def mfit():
    global fmxx, fmyy, fmx, fmy, mvv, maa1, maa2, kmin, kmax, mfi, mfi_err, mfi_x, result, fa1, fa2, fit_warn, wr1, wr2, flmcomp1, flmcomp2, mbcomp1, mbcomp2, mresult, xr1, xr2, smcst
    mbcomp1.config(bg='white')
    mbcomp2.config(bg='white')
    mfi, mfi_err, mfi_x = list(mfi), list(mfi_err), list(mfi_x)
    msave_state()
    i = mfiti.get()
    mbase[i] = int(base.get())  # 待調整
    # fmxx[i, :] = fmxx[i, :]/fmxx[i, :]*-50
    # fmyy[i, :] = fmyy[i, :]/fmyy[i, :]*-50
    ecut = data.sel(eV=ev[i], method='nearest')
    if npzf:x = phi
    else:x = (2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(phi/180*np.pi)*10**-10/(h/2/np.pi)
    y = ecut.to_numpy().reshape(len(x))
    xx, x_arg = filter(x, kmin[i], kmax[i])
    # tx = x[np.argwhere(x >= kmin[i])].flatten()
    # xx = tx[np.argwhere(tx <= kmax[i])].flatten()
    # ty = y[np.argwhere(x >= kmin[i])].flatten()
    # yy = ty[np.argwhere(tx <= kmax[i])].flatten()
    yy = y[x_arg]
    yy = np.where(yy > mbase[i], yy, mbase[i])
    try:
        if mfp[i] == 1:
            smcst[i] = [0, 0, 0, 0, 0, 0]
            pars = Parameters()
            pars.add('x', value=kmin[i]+(kmax[i]-kmin[i])
                     * 0.2, min=kmin[i], max=kmax[i])
            pars.add('h', value=(
                np.max(y)-mbase[i])+1, min=(np.max(y)-mbase[i])/10, max=np.max(y)-mbase[i]+1)
            pars.add('w', value=0.1, min=0.01, max=0.2)
            pars.add('y', value=0, vary=False)
            fitter = Minimizer(fgl1, pars, fcn_args=(xx, yy-lnr_bg(yy)))
            result = fitter.minimize()
            a1 = toa1()
            checkfit()
            if fit_warn == 1:
                t = 5
                while t > 0 and fit_warn == 1:
                    result = fitter.minimize()
                    a1 = toa1()
                    checkfit()
                    t -= 1
        elif mfp[i] == 2:
            pars = Parameters()
            xr1, xr2 = float(mxf1.get()), float(mxf2.get())
            wr1, wr2 = float(mwf1.get()), float(mwf2.get())
            fa1, fa2 = float(maf1.get()), float(maf2.get())
            smcst[i] = [xr1, xr2, wr1, wr2, fa1, fa2]
            if flmcomp == 1:
                if flmcomp1 == 1:
                    flmcomp1 = -1
                    pars.add('x1', value=maa2[i, 0], min=kmin[i], max=kmax[i])
                    if flmposcst == 1:
                        pars.add('xr1', value=xr1, vary=False)
                        pars.add('xr2', value=xr2, vary=False)
                        pars.add('x2', expr='x1*xr1+xr2')
                    else:
                        pars.add('x2', value=maa2[i, 4], min=kmin[i], max=kmax[i])
                elif flmcomp2 == 1:
                    flmcomp2 = -1
                    pars.add('x2', value=maa2[i, 4], min=kmin[i], max=kmax[i])
                    if flmposcst == 1:
                        pars.add('xr1', value=xr1, vary=False)
                        pars.add('xr2', value=xr2, vary=False)
                        pars.add('x1', expr="(x2-xr2) / xr1")
                    else:
                        pars.add('x1', value=maa2[i, 0], min=kmin[i], max=kmax[i])
                        
                
                pars.add('h1', value=maa2[i, 1], min=(
                    np.max(y)-mbase[i])/10, max=np.max(y)-mbase[i]+1)
                pars.add('h2', value=maa2[i, 5], min=(
                    np.max(y)-mbase[i])/10, max=np.max(y)-mbase[i]+1)
                pars.add('w1', value=maa2[i, 2], min=0.01, max=0.2)
                if wr1 != 0 and wr2 != 0:
                    pars.add('wr1', value=wr1, vary=False)
                    pars.add('wr2', value=wr2, vary=False)
                    pars.add('w2', expr='w1/wr1*wr2')
                else:
                    pars.add('w2', value=maa2[i, 6], min=0.01, max=0.2)
            else:
                pars.add('x1', value=kmin[i]+(kmax[i] -
                         kmin[i])*0.3, min=kmin[i], max=kmax[i])
                if flmposcst == 1:
                    pars.add('xr1', value=xr1, vary=False)
                    pars.add('xr2', value=xr2, vary=False)
                    pars.add('x2', expr='x1*xr1+xr2')
                else:
                    pars.add(
                        'x2', value=kmax[i]-(kmax[i]-kmin[i])*0.3, min=kmin[i], max=kmax[i])
                pars.add('h1', value=(
                    np.max(y)-mbase[i])+1, min=(np.max(y)-mbase[i])/10, max=np.max(y)-mbase[i]+1)
                pars.add('h2', value=(
                    np.max(y)-mbase[i])+1, min=(np.max(y)-mbase[i])/10, max=np.max(y)-mbase[i]+1)
                pars.add('w1', value=0.02, min=0.01, max=0.2)
                if wr1 != 0 and wr2 != 0:
                    pars.add('wr1', value=wr1, vary=False)
                    pars.add('wr2', value=wr2, vary=False)
                    pars.add('w2', expr='w1/wr1*wr2')
                else:
                    pars.add('w2', value=0.02, min=0.01, max=0.2)

            pars.add('y1', value=0, vary=False)
            pars.add('y2', value=0, vary=False)
            if fa1 != 0 and fa2 != 0:
                fitter = Minimizer(fgl2_a, pars, fcn_args=(xx, yy-lnr_bg(yy)))
                result = fitter.minimize()
            else:
                fitter = Minimizer(fgl2, pars, fcn_args=(xx, yy-lnr_bg(yy)))
                result = fitter.minimize()
            a2 = toa2(xx)
            checkfit()
            if fit_warn == 1:
                t = 5
                while t > 0 and fit_warn == 1:
                    result = fitter.minimize()
                    a2 = toa2(xx)
                    checkfit()
                    t -= 1
        report_fit(result)
        result=swapc1c2()
        mresult[i] = result

        if (kmin[i], kmax[i]) == ((2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(-0.5/180*np.pi)*10**-10/(h/2/np.pi), (2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(0.5/180*np.pi)*10**-10/(h/2/np.pi)):
            if i not in mfi_x:
                mfi_x.append(i)
            if i in mfi:
                mfi.remove(i)
            if i in mfi_err:
                mfi_err.remove(i)
        elif (kmin[i], kmax[i]) != ((2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(-0.5/180*np.pi)*10**-10/(h/2/np.pi), (2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(0.5/180*np.pi)*10**-10/(h/2/np.pi)):
            if fit_warn == 0:
                if i not in mfi:
                    mfi.append(i)
                if i in mfi_x:
                    mfi_x.remove(i)
                if i in mfi_err:
                    mfi_err.remove(i)
            else:
                if i not in mfi_err:
                    mfi_err.append(i)
                if i in mfi_x:
                    mfi_x.remove(i)
                if i in mfi:
                    mfi.remove(i)
    except RuntimeError:
        if i not in mfi_err:
            mfi_err.append(i)
        if i in mfi_x:
            mfi_x.remove(i)
        if i in mfi:
            mfi.remove(i)
        a1 = [(kmin[i]+kmax[i])/2, (np.max(y)-mbase[i]), 0.5, mbase[i]]
        a2 = [(kmin[i]+kmax[i])/2, (np.max(y)-mbase[i]), 0.5, mbase[i],
              (kmin[i]+kmax[i])/2, (np.max(y)-mbase[i]), 0.5, mbase[i]]

    # fmxx[i, :len(xx)] = xx
    # fmyy[i, :len(yy)] = yy
    fmx[i, :] = x
    fmy[i, :] = y
    mvv[i] = ev[i]
    if mfp[i] == 1:
        maa1[i, :] = a1
    elif mfp[i] == 2:
        maa2[i, :] = a2

# 初始化撤銷和重做堆疊
mundo_stack = []
mredo_stack = []

def msave_state():
    # 保存當前狀態到撤銷堆疊，並清空重做堆疊
    smresult = pack_fitpar(mresult)
    state = {
        'mfi': mfi.copy(),
        'mfp': mfp.copy(),
        'kmin': kmin.copy(),
        'kmax': kmax.copy(),
        'maa1': maa1.copy(),
        'maa2': maa2.copy(),
        'smresult': smresult.copy(),
        'smcst': smcst.copy(),
        'mfi_err': mfi_err.copy()
    }
    mundo_stack.append(state)
    mredo_stack.clear()

def mundo():
    if mundo_stack:
        global mfi, mfp, kmin, kmax, maa1, maa2, smresult, smcst, mfi_err, fdo
        # 從撤銷堆疊中彈出上一個狀態並恢復，並將當前狀態推入重做堆疊
        state = mundo_stack.pop()
        smresult = pack_fitpar(mresult)
        mredo_stack.append({
            'mfi': mfi.copy(),
            'mfp': mfp.copy(),
            'kmin': kmin.copy(),
            'kmax': kmax.copy(),
            'maa1': maa1.copy(),
            'maa2': maa2.copy(),
            'smresult': smresult.copy(),
            'smcst': smcst.copy(),
            'mfi_err': mfi_err.copy()
        })
        mfi = state['mfi']
        mfp = state['mfp']
        kmin = state['kmin']
        kmax = state['kmax']
        maa1 = state['maa1']
        maa2 = state['maa2']
        smresult = state['smresult']
        smcst = state['smcst']
        mfi_err = state['mfi_err']
        mst.put("Undo")
        print("Undo")
        fdo=1
        mfitplot()
    else:
        mst.put("No more actions to undo.")
        print("No more actions to undo.")

def mredo():
    if mredo_stack:
        global mfi, mfp, kmin, kmax, maa1, maa2, smresult, smcst, mfi_err, fdo
        # 從重做堆疊中彈出上一個狀態並恢復，並將當前狀態推入撤銷堆疊
        state = mredo_stack.pop()
        smresult = pack_fitpar(mresult)
        mundo_stack.append({
            'mfi': mfi.copy(),
            'mfp': mfp.copy(),
            'kmin': kmin.copy(),
            'kmax': kmax.copy(),
            'maa1': maa1.copy(),
            'maa2': maa2.copy(),
            'smresult': smresult.copy(),
            'smcst': smcst.copy(),
            'mfi_err': mfi_err.copy()
        })
        mfi = state['mfi']
        mfp = state['mfp']
        kmin = state['kmin']
        kmax = state['kmax']
        maa1 = state['maa1']
        maa2 = state['maa2']
        smresult = state['smresult']
        smcst = state['smcst']
        mfi_err = state['mfi_err']
        mst.put("Redo")
        print("Redo")
        fdo=1
        mfitplot()
    else:
        mst.put("No more actions to redo.")
        print("No more actions to redo.")


def fmrmv():
    global mbrmv, flmrmv, mirmv, kmin, kmax, mfi, mfi_err, mfi_x, cki, mfp, mresult, smresult, smcst
    msave_state()
    i = mfiti.get()
    flmrmv *= -1
    if flmrmv == 1:
        mirmv = i
        mbrmv.config(text='End Remove', bg='red')
    else:
        ti = sorted([i, mirmv])
        for i in np.linspace(ti[0], ti[1], ti[1]-ti[0]+1, dtype=int):
            mfp[i] = 1
            kmin[i], kmax[i] = (2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(-0.5/180*np.pi)*10**-10/(
                h/2/np.pi), (2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(0.5/180*np.pi)*10**-10/(h/2/np.pi)
            if i not in mfi_x:
                mfi_x.append(i)
            if i in mfi:
                mfi.remove(i)
            if i in mfi_err:
                mfi_err.remove(i)
            if i in cki:
                cki.remove(i)
            mresult[i] = []
            try:
                for j in range(6):
                    smresult[i][j] = 'nofit'
                    smcst[i][j] = 0
            except:
                pass
        mplfi()
        mbrmv.config(text='Remove', bg='white')
        mfitplot()


def fmedmove(event):
    global medxdata, medydata, medfitout
    if event.xdata != None:
        medfitout.get_tk_widget().config(cursor="crosshair")
        medxdata.config(text='xdata:'+str('%.3f' % event.xdata))
        medydata.config(text='ydata:'+str('%.3f' % event.ydata))
    else:
        medfitout.get_tk_widget().config(cursor="")
        try:
            medxdata.config(text='xdata:')
            medydata.config(text='ydata:')
        except NameError:
            pass


def savemfit():
    global smresult, smcst, fev, fwhm, pos, skmin, skmax, smaa1, smaa2, smfp, smfi
    smresult = pack_fitpar(mresult)
    path = fd.asksaveasfilename(title="Save MDC Fitted Data", initialdir=dpath,
                                initialfile=name+"_mfit", filetype=[("NPZ files", ".npz"),], defaultextension=".npz")
    if len(path) > 2:
        global mendg
        try:
            mgg.focus_set()
            mendg.destroy()
        except:
            pass
        np.savez(path, path=dpath, fev=fev, fwhm=fwhm, pos=pos, skmin=skmin,
                 skmax=skmax, smaa1=smaa1, smaa2=smaa2, smfp=smfp, smfi=smfi, smresult=smresult, smcst=smcst)
    else:
        mgg.focus_set()
        mendg.focus_set()


def fmresidual():
    plt.figure()
    s3,s4=[],[]
    for i in range(len(ev)):
        if i in mfi_err or i in mfi:
            # x = fmxx[i, np.argwhere(fmxx[i, :] >= -20)].flatten()
            # y = fmyy[i, np.argwhere(fmxx[i, :] >= -20)].flatten()
            # lbg=lnr_bg(fmyy[i, :len(x)])
            x, x_arg = filter(fmx[i, :], kmin[i], kmax[i])
            y = fmy[i, x_arg]
            lbg = lnr_bg(y)
            s3.append(np.std(gl2(x, *maa2[i, :])+lbg-y))  # STD
            s4.append(np.sqrt(np.mean((gl2(x, *maa2[i, :])+lbg-y)**2)))  # RMS
        else:
            s3.append(0)
            s4.append(0)
    plt.plot(ev,s3,label='STD',c='r')
    plt.plot(ev,s4,label='RMS',c='b')
    plt.title('Residual')
    plt.xlabel('Kinetic Energy (eV)')
    plt.ylabel('Intensity (Counts)')
    plt.legend()
    plt.show()
def fmarea():
    plt.figure()
    s1,s2=[],[]
    for i in range(len(ev)):
        if i in mfi_err or i in mfi:
            # x = fmxx[i, np.argwhere(fmxx[i, :] >= -20)].flatten()
            # y = fmyy[i, np.argwhere(fmxx[i, :] >= -20)].flatten()
            x, x_arg = filter(fmx[i, :], kmin[i], kmax[i])
            ty = gl1(x, *maa2[i, :4])
            s1.append(np.sum(np.array([((ty[i]+ty[i+1])/2)for i in range(len(x)-1)])
                        # Area 1
                        * np.array(([(x[i+1]-x[i])for i in range(len(x)-1)]))))
            ty = gl1(x, *maa2[i, -4:])
            s2.append(np.sum(np.array([((ty[i]+ty[i+1])/2)for i in range(len(x)-1)])
                        # Area 2
                        * np.array(([(x[i+1]-x[i])for i in range(len(x)-1)]))))
        else:
            s1.append(0)
            s2.append(0)
    plt.plot(ev,s1,label='Area 1',c='r')
    plt.plot(ev,s2,label='Area 2',c='b')
    plt.title('Area')
    plt.xlabel('Kinetic Energy (eV)')
    plt.ylabel('Intensity (Counts)')
    plt.legend()
    plt.show()
def fmfwhm():
    global pos, fwhm, fev, rpos, ophi
    fev, pos, fwhm = [], [], []
    f=plt.figure()
    a1=f.add_subplot(311)
    a2=f.add_subplot(312)
    a3=f.add_subplot(313)
    x1=[]
    x2=[]
    y1=[]
    y2=[]
    for i, v in enumerate(mfi):
        if mfp[v] == 1:
            fev.append(ev[v])
            pos.append(maa1[v, 0])
            fwhm.append(maa1[v, 2])
            x1.append(ev[v])
            y1.append(maa1[v, 2])
        elif mfp[v] == 2:
            x1.append(ev[v])
            x2.append(ev[v])
            y1.append(maa2[v, 2])
            y2.append(maa2[v, 6])
            
            fev.append(ev[v])
            fev.append(ev[v])
            pos.append(maa2[v, 0])
            pos.append(maa2[v, 4])
            fwhm.append(maa2[v, 2])
            fwhm.append(maa2[v, 6])
    fev = np.float64(fev)
    rpos = np.float64(pos)
    
    ophi = np.arcsin(rpos/(2*m*fev*1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
    pos = (2*m*fev*1.602176634*10**-19)**0.5 * np.sin((np.float64(k_offset.get())+ophi)/180*np.pi)*10**-10/(h/2/np.pi)

    rpos = res(fev, rpos)
    ophi = res(fev, ophi)
    fwhm = res(fev, fwhm)
    pos = res(fev, pos)
    fev = res(fev, fev)
    
    ha=a1.scatter(x1,y1,c='r')
    a1.set_title('FWHM')
    a1.set_ylabel(r'FWHM ($\frac{2\pi}{\AA}$)')
    a1.legend([ha],['Comp 1'])
    hb=a2.scatter(x2,y2,c='b')
    a2.set_ylabel(r'FWHM ($\frac{2\pi}{\AA}$)')
    a2.legend([hb],['Comp 2'])
    h2=a3.scatter(x2,y2,c='b')
    h1=a3.scatter(x1,y1,c='r')
    a3.set_xlabel('Kinetic Energy (eV)')
    a3.set_ylabel(r'FWHM ($\frac{2\pi}{\AA}$)')
    a3.legend([h1,h2],['Comp 1','Comp 2'])
    plt.tight_layout()
    plt.show()

def fmimse():
    global pos, fwhm, fev, rpos, ophi
    fev, pos, fwhm = [], [], []
    f=plt.figure()
    a1=f.add_subplot(221)
    a2=f.add_subplot(222)
    a3=f.add_subplot(223)
    a4=f.add_subplot(224)
    y=[]
    pos1=[]
    pos2=[]
    fwhm1=[]
    fwhm2=[]
    for i, v in enumerate(mfi):
        if mfp[v] == 1:
            fev.append(ev[v])
            pos.append(maa1[v, 0])
            fwhm.append(maa1[v, 2])
        elif mfp[v] == 2:
            y.append(ev[v])
            pos1.append(maa2[v, 0])
            pos2.append(maa2[v, 4])
            fwhm1.append(maa2[v, 2])
            fwhm2.append(maa2[v, 6])
            
            fev.append(ev[v])
            fev.append(ev[v])
            pos.append(maa2[v, 0])
            pos.append(maa2[v, 4])
            fwhm.append(maa2[v, 2])
            fwhm.append(maa2[v, 6])
    y = np.float64(y)
    fev = np.float64(fev)
    rpos = np.float64(pos)
    
    ophi = np.arcsin(rpos/(2*m*fev*1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
    pos = (2*m*fev*1.602176634*10**-19)**0.5 * np.sin((np.float64(k_offset.get())+ophi)/180*np.pi)*10**-10/(h/2/np.pi)
    
    rpos = res(fev, rpos)
    ophi = res(fev, ophi)
    fwhm = res(fev, fwhm)
    pos = res(fev, pos)
    fev = res(fev, fev)
    
    pos1 = res(y, pos1)
    pos2 = res(y, pos2)
    fwhm1 = res(y, fwhm1)
    fwhm2 = res(y, fwhm2)
    y = res(y, y)
    
    xx = np.diff(y)
    yy1 = np.diff(pos1)
    yy2 = np.diff(pos2)
    
    # eliminate infinite vf
    for i in range(len(yy1)):
        if xx[i]/yy1[i] > 20000:
            yy1[i] = 0
    for i in range(len(yy2)):
        if xx[i]/yy2[i] > 20000:
            yy2[i] = 0
    
    v1 = xx/yy1
    v2 = xx/yy2
    yy1 = v1*fwhm1[1::]/2
    yy2 = v2*fwhm2[1::]/2
    xx/=2
    print(len(y))
    print(len(xx))
    x = ((y[-1:0:-1]+xx[::-1])-vfe)*1000
    print(len(x))
    ha=a1.scatter(x,v1,c='r')
    hb=a2.scatter(x,v2,c='b')
    h1=a3.scatter(x,yy1*1000,c='r')
    h2=a4.scatter(x,yy2*1000,c='b')
    a1.set_title('Group Velocity')
    a1.set_xlabel('Binding Energy (meV)', font='Arial', fontsize=14)
    a1.set_ylabel(r'v ($eV\AA$)', font='Arial', fontsize=14)
    a1.legend([ha],['Comp 1'])
    a2.set_title('Group Velocity')
    a2.set_xlabel('Binding Energy (meV)', font='Arial', fontsize=14)
    a2.set_ylabel(r'v ($eV\AA$)', font='Arial', fontsize=14)
    a2.legend([hb],['Comp 2'])
    a3.set_title('Imaginary Part')
    a3.set_xlabel('Binding Energy (meV)', font='Arial', fontsize=14)
    a3.set_ylabel(r'Im $\Sigma$ (meV)', font='Arial', fontsize=14)
    a3.legend([h1],['Comp 1'])
    a4.set_title('Imaginary Part')
    a4.set_xlabel('Binding Energy (meV)', font='Arial', fontsize=14)
    a4.set_ylabel(r'Im $\Sigma$ (meV)', font='Arial', fontsize=14)
    a4.legend([h2],['Comp 2'])
    plt.tight_layout()
    plt.show()
    
def fmpreview():
    mprvg = tk.Toplevel(g)
    mprvg.geometry('300x320')
    mprvg.title(' Preview MDC Result')
    bmresidual = tk.Button(mprvg, text='Residual', command=fmresidual, width=30, height=2, font=('Arial', 16, "bold"), bg='white', bd=10)
    bmresidual.pack()
    bmarea = tk.Button(mprvg, text='Area', command=fmarea, width=30, height=2, font=('Arial', 16, "bold"), bg='white', bd=10)
    bmarea.pack()
    bmfwhm = tk.Button(mprvg, text='FWHM', command=fmfwhm, width=30, height=2, font=('Arial', 16, "bold"), bg='white', bd=10)
    bmfwhm.pack()
    bmimse = tk.Button(mprvg, text='Imaginary Part', command=fmimse, width=30, height=2, font=('Arial', 16, "bold"), bg='white', bd=10)
    bmimse.pack()
    mprvg.update()
    
scki = []

def mprend(p=0):
    global rpos, pos, fwhm, fev, medxdata, medydata, medfitout, skmin, skmax, smaa1, smaa2, smfp, smfi, fpr, scki
    fev, pos, fwhm = [], [], []
    skmin, skmax, smaa1, smaa2 = kmin, kmax, maa1, maa2
    smfp = mfp
    smfi = mfi
    for i, v in enumerate(mfi):
        if mfp[v] == 1:
            fev.append(ev[v])
            pos.append(maa1[v, 0])
            fwhm.append(maa1[v, 2])
        elif mfp[v] == 2:
            if p == 1:
                fev.append(ev[v])
                pos.append(maa2[v, 0])
                fwhm.append(maa2[v, 2])
            elif p == 2:
                fev.append(ev[v])
                pos.append(maa2[v, 4])
                fwhm.append(maa2[v, 6])
            else:
                fev.append(ev[v])
                fev.append(ev[v])
                pos.append(maa2[v, 0])
                pos.append(maa2[v, 4])
                fwhm.append(maa2[v, 2])
                fwhm.append(maa2[v, 6])
            
    fwhm = res(fev, fwhm)
    pos = res(fev, pos)
    # skmin = res(smfi, skmin)
    # skmax = res(smfi, skmax)
    # smfp = res(smfi, smfp)
    fev = res(fev, fev)
    smfi = res(smfi, smfi)
            
    rpos, fev, pos, fwhm = np.float64(pos), np.float64(
        fev), np.float64(pos), np.float64(fwhm)

def fmend():
    global rpos, pos, fwhm, fev, medxdata, medydata, medfitout, skmin, skmax, smaa1, smaa2, smfp, smfi, fpr, scki, mendg
    mprend()
    scki = cki
    fpr = 1
    try:
        mendg.destroy()
    except:
        pass
    mendg = tk.Toplevel(g)
    mendg.title('MDC Lorentz Fit Result')
    fr = tk.Frame(master=mendg, bd=5)
    fr.grid(row=0, column=0)
    mfitfig = Figure(figsize=(8, 6), layout='constrained')
    medfitout = FigureCanvasTkAgg(mfitfig, master=fr)
    medfitout.get_tk_widget().grid(row=0, column=0)
    medfitout.mpl_connect('motion_notify_event', fmedmove)

    a = mfitfig.subplots()
    a.scatter(pos+fwhm/2, fev, c='r', s=10)
    a.scatter(pos-fwhm/2, fev, c='r', s=10)
    a.scatter(pos, fev, c='k', s=10)
    a.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=14)
    a.set_ylabel('Kinetic Energy (eV)', font='Arial', fontsize=14)
    medfitout.draw()
    xydata = tk.Frame(master=fr, bd=5)
    xydata.grid(row=1, column=0)

    medxdata = tk.Label(xydata, text='xdata:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=10, bg='white')
    medxdata.grid(row=0, column=0)
    medydata = tk.Label(xydata, text='ydata:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=10, bg='white')
    medydata.grid(row=0, column=1)

    bsave = tk.Button(master=mendg, text='Save Fitted Data', command=savemfit,
                      width=30, height=2, font=('Arial', 14, "bold"), bg='white', bd=10)
    bsave.grid(row=1, column=0)
    
    mendg.update()


def fmend1():
    global rpos, pos, fwhm, fev, medxdata, medydata, medfitout, skmin, skmax, smaa1, smaa2, smfp, smfi, fpr, scki, mendg
    mprend(p=1)
    scki = cki
    fpr = 1
    try:
        mendg.destroy()
    except:
        pass
    mendg = tk.Toplevel(g)
    mendg.title('MDC Lorentz Fit Result')
    fr = tk.Frame(master=mendg, bd=5)
    fr.grid(row=0, column=0)
    mfitfig = Figure(figsize=(8, 6), layout='constrained')
    medfitout = FigureCanvasTkAgg(mfitfig, master=fr)
    medfitout.get_tk_widget().grid(row=0, column=0)
    medfitout.mpl_connect('motion_notify_event', fmedmove)

    a = mfitfig.subplots()
    a.scatter(pos+fwhm/2, fev, c='r', s=10)
    a.scatter(pos-fwhm/2, fev, c='r', s=10)
    a.scatter(pos, fev, c='k', s=10)
    a.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=14)
    a.set_ylabel('Kinetic Energy (eV)', font='Arial', fontsize=14)
    medfitout.draw()
    xydata = tk.Frame(master=fr, bd=5)
    xydata.grid(row=1, column=0)

    medxdata = tk.Label(xydata, text='xdata:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=10, bg='white')
    medxdata.grid(row=0, column=0)
    medydata = tk.Label(xydata, text='ydata:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=10, bg='white')
    medydata.grid(row=0, column=1)

    bsave = tk.Button(master=mendg, text='Save Fitted Data', command=savemfit,
                      width=30, height=2, font=('Arial', 14, "bold"), bg='white', bd=10)
    bsave.grid(row=1, column=0)
    
    mendg.update()

def fmend2():
    global rpos, pos, fwhm, fev, medxdata, medydata, medfitout, skmin, skmax, smaa1, smaa2, smfp, smfi, fpr, scki, mendg
    mprend(p=2)
    scki = cki
    fpr = 1
    try:
        mendg.destroy()
    except:
        pass
    mendg = tk.Toplevel(g)
    mendg.title('MDC Lorentz Fit Result')
    fr = tk.Frame(master=mendg, bd=5)
    fr.grid(row=0, column=0)
    mfitfig = Figure(figsize=(8, 6), layout='constrained')
    medfitout = FigureCanvasTkAgg(mfitfig, master=fr)
    medfitout.get_tk_widget().grid(row=0, column=0)
    medfitout.mpl_connect('motion_notify_event', fmedmove)

    a = mfitfig.subplots()
    a.scatter(pos+fwhm/2, fev, c='r', s=10)
    a.scatter(pos-fwhm/2, fev, c='r', s=10)
    a.scatter(pos, fev, c='k', s=10)
    a.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=14)
    a.set_ylabel('Kinetic Energy (eV)', font='Arial', fontsize=14)
    medfitout.draw()
    xydata = tk.Frame(master=fr, bd=5)
    xydata.grid(row=1, column=0)

    medxdata = tk.Label(xydata, text='xdata:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=10, bg='white')
    medxdata.grid(row=0, column=0)
    medydata = tk.Label(xydata, text='ydata:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=10, bg='white')
    medydata.grid(row=0, column=1)

    bsave = tk.Button(master=mendg, text='Save Fitted Data', command=savemfit,
                      width=30, height=2, font=('Arial', 14, "bold"), bg='white', bd=10)
    bsave.grid(row=1, column=0)
    
    mendg.update()

def fmfall():
    t = threading.Thread(target=mfitjob)
    t.daemon = True
    t.start()


def func_cki():
    global cki, kmin, kmax
    if mfiti.get() not in cki:
        cki.append(mfiti.get())
    if len(cki) >= 2:
        cki.sort()
        for i in range(len(cki)-1):
            kmin[cki[i]:cki[i+1] +
                 1] = np.linspace(kmin[cki[i]], kmin[cki[i+1]], cki[i+1]-cki[i]+1)
            kmax[cki[i]:cki[i+1] +
                 1] = np.linspace(kmax[cki[i]], kmax[cki[i+1]], cki[i+1]-cki[i]+1)


def fchki(*e):
    global mfitout, mdxdata, mdydata, mbcomp1, mbcomp2, mbgv, flmcomp1, flmcomp2
    i = mfiti.get()
    mbgv = 0
    try:
        flmcomp1,flmcomp2 = -1, -1
        mfitout.get_tk_widget().delete('rec')
        mdxdata.config(text='dx:')
        mdydata.config(text='dy:')
        if mfp[i] == 2:
            mbcomp1.config(state='active', bg='white')
            mbcomp2.config(state='active', bg='white')
        else:
            mbcomp1.config(state='disabled', bg='white')
            mbcomp2.config(state='disabled', bg='white')
    except:
        pass
    mfitplot()
    mprplot(mxl)


def mplfi():
    global miout, mifig, mlind, mrind
    i = mfiti.get()
    mifig.clear()
    miax = mifig.add_axes([0, 0, 1, 1])
    miax.scatter(mfi_x, [0 for i in range(len(mfi_x))], marker='|', c='k')
    miax.scatter(mfi, [0 for i in range(len(mfi))], marker='|', c='b')
    miax.scatter(mfi_err, [0 for i in range(len(mfi_err))], marker='|', c='r')
    if i in mfi_x:
        mlind.config(bg='white')
        mrind.config(bg='white')
    if i in mfi:
        mlind.config(bg='blue')
        mrind.config(bg='blue')
    if i in mfi_err:
        mlind.config(bg='red')
        mrind.config(bg='red')
    try:
        miax.set_xlim([np.min([mfi, mfi_x, mfi_err]),
                      np.max([mfi, mfi_x, mfi_err])])
    except ValueError:
        pass
    miax.set_yticks([])
    mprplot(mxl)
    miout.draw()

def mfbgu(event):
    global mbgv
    i=mfiti.get()
    mbase[i] = int(base.get())  # 待調整
    # fmxx[i, :] = fmxx[i, :]/fmxx[i, :]*-50
    # fmyy[i, :] = fmyy[i, :]/fmyy[i, :]*-50
    ecut = data.sel(eV=ev[i], method='nearest')
    if npzf:x = phi
    else:x = (2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(phi/180*np.pi)*10**-10/(h/2/np.pi)
    y = ecut.to_numpy().reshape(len(x))
    xx, x_arg = filter(x, kmin[i], kmax[i])
    # tx = x[np.argwhere(x >= kmin[i])].flatten()
    # xx = tx[np.argwhere(tx <= kmax[i])].flatten()
    # ty = y[np.argwhere(x >= kmin[i])].flatten()
    # yy = ty[np.argwhere(tx <= kmax[i])].flatten()
    yy = y[x_arg]
    yy = np.where(yy > mbase[i], yy, mbase[i])
    d = sorted(abs(np.diff(np.append(yy[0:5],yy[-6:-1]))))
    t=0
    ti=0
    while t==0:
        t=d[ti]
        ti+=1
        if ti==len(d):
            break
    print(t)
    try:
        mbgv+=t/2
        mfit()
        mfitplot()
    except:
        pass

def mfbgd(event):
    global mbgv
    i=mfiti.get()
    mbase[i] = int(base.get())  # 待調整
    # fmxx[i, :] = fmxx[i, :]/fmxx[i, :]*-50
    # fmyy[i, :] = fmyy[i, :]/fmyy[i, :]*-50
    ecut = data.sel(eV=ev[i], method='nearest')
    if npzf:x = phi
    else:x = (2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(phi/180*np.pi)*10**-10/(h/2/np.pi)
    y = ecut.to_numpy().reshape(len(x))
    xx, x_arg = filter(x, kmin[i], kmax[i])
    # tx = x[np.argwhere(x >= kmin[i])].flatten()
    # xx = tx[np.argwhere(tx <= kmax[i])].flatten()
    # ty = y[np.argwhere(x >= kmin[i])].flatten()
    # yy = ty[np.argwhere(tx <= kmax[i])].flatten()
    yy = y[x_arg]
    yy = np.where(yy > mbase[i], yy, mbase[i])
    d = sorted(abs(np.diff(np.append(yy[0:5],yy[-6:-1]))))
    t=0
    ti=0
    while t==0:
        t=d[ti]
        ti+=1
        if ti==len(d):
            break
    print(t)
    try:
        mbgv-=t/2
        mfit()
        mfitplot()
    except:
        pass

def _mpr2draw():
    global mfitprfig2, mfitprout2, mfprb
    i = mfiti.get()
    try:
        mfitprfig2.clear()
        mfprb = mfitprfig2.subplots()
        mfprb.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=12)
        if emf=='KE':
            mfprb.set_ylabel('Kinetic Energy (eV)', font='Arial', fontsize=12)
        else:
            mfprb.set_ylabel('Binding Energy (eV)', font='Arial', fontsize=12)
            mfprb.invert_yaxis()
        mprend()
        if emf == 'KE':
            mfprb.scatter(pos + fwhm / 2, fev, c='r', s=0.5)
            mfprb.scatter(pos - fwhm / 2, fev, c='r', s=0.5)
            mfprb.scatter(pos, fev, c='k', s=0.5)
        else:
            mfprb.scatter(pos + fwhm / 2, vfe - fev, c='r', s=0.5)
            mfprb.scatter(pos - fwhm / 2, vfe - fev, c='r', s=0.5)
            mfprb.scatter(pos, vfe - fev, c='k', s=0.5)

        if emf == 'KE':
            mfprb.plot(mfprb.get_xlim(), [ev[i], ev[i]], 'b-', alpha=0.5)
        else:
            mfprb.plot(mfprb.get_xlim(), [vfe - ev[i], vfe - ev[i]], 'b-', alpha=0.5)
        
        mfitprout2.draw()
    except:
        pass
    
def mpr2draw():
    t = threading.Thread(target=_mpr2draw)
    t.daemon = True
    t.start()
    
def _mpr3draw():
    global mfitprfig3, mfitprout3, mfprc
    i = mfiti.get()
    try:
        mfitprfig3.clear()
        mfprc = mfitprfig3.subplots(2, 1)
        mfprc[1].set_xlabel('Binding Energy (eV)')
        mfprc[0].set_ylabel(r'FWHM ($\frac{2\pi}{\AA}$)')
        mfprc[1].set_ylabel(r'FWHM ($\frac{2\pi}{\AA}$)')
        mfprc[0].set_xticks([])
        mfprc[0].invert_xaxis()
        mfprc[1].invert_xaxis()
        x1=[]
        x2=[]
        y1=[]
        y2=[]
        for j, v in enumerate(mfi):
            if mfp[v] == 1:
                x1.append(vfe-ev[v])
                y1.append(maa1[v, 2])
            elif mfp[v] == 2:
                x1.append(vfe-ev[v])
                x2.append(vfe-ev[v])
                y1.append(maa2[v, 2])
                y2.append(maa2[v, 6])
        y1 = res(x1, y1)
        y2 = res(x2, y2)
        x1 = res(x1, x1)
        x2 = res(x2, x2)
        mfprc[0].plot(x1, y1, c='r', marker='o', markersize=0.5, label='Comp 1')    #plot
        mfprc[1].plot(x2, y2, c='b', marker='o', markersize=0.5, label='Comp 2')    #plot
        # mfprc[0].scatter(x1, y1, c='r', s=0.5, label='Comp 1')    #scatter
        # mfprc[1].scatter(x2, y2, c='b', s=0.5, label='Comp 2')    #scatter
        l1 = mfprc[0].legend()
        l2 = mfprc[1].legend()
        l1.draw_frame(False)
        l2.draw_frame(False)
        mfprc[0].plot([vfe - ev[i], vfe - ev[i]], mfprc[0].get_ylim(), 'b-', alpha=0.5)
        mfprc[1].plot([vfe - ev[i], vfe - ev[i]], mfprc[1].get_ylim(), 'r-', alpha=0.5)
        mfitprout3.draw()
    except:
        pass
    
def mpr3draw():
    t = threading.Thread(target=_mpr3draw)
    t.daemon = True
    t.start()

def _mprplot_job1():
    global mfitprfig1, mfitprout1, mfpra, mfprl1, mfprl2, mfprl3, mfpr
    i = mfiti.get()
    try:
        xl=mprxl
        if mfpr == 0:
            mfpr = 1
            mfitprfig1.clear()
            mfpra = mfitprfig1.subplots()
            mprend()
            if emf == 'KE':
                px, py = np.meshgrid(phi, ev)
                tev = py.copy()
                mfpra.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=8)
                mfpra.set_ylabel('Kinetic Energy (eV)', font='Arial', fontsize=12)
            else:
                px, py = np.meshgrid(phi, vfe - ev)
                tev = vfe - py.copy()
                mfpra.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=8)
                mfpra.set_ylabel('Binding Energy (eV)', font='Arial', fontsize=12)
                mfpra.invert_yaxis()
            if npzf:
                px = phi
            else:
                px = (2 * m * tev * 1.6 * 10 ** -19) ** 0.5 * np.sin(px / 180 * np.pi) * 10 ** -10 / (h / 2 / np.pi)
            pz = data.to_numpy()
            mfpra.pcolormesh(px, py, pz, cmap=value3.get())
            oyl = mfpra.get_ylim()

            if emf == 'KE':
                mfprl1,=mfpra.plot([xl[0], xl[1]], [ev[i], ev[i]], 'r-')
            else:
                mfprl1,=mfpra.plot([xl[0], xl[1]], [vfe - ev[i], vfe - ev[i]], 'r-')

            de = (ev[1] - ev[0]) * 8
            mfprl2,=mfpra.plot([xl[0], xl[0]], [ev[i] - de, ev[i] + de], 'r-')
            mfprl3,=mfpra.plot([xl[1], xl[1]], [ev[i] - de, ev[i] + de], 'r-')
            mfpra.set_ylim(oyl)
        else:
            mprend()
            de = (ev[1] - ev[0]) * 8
            if emf == 'KE':
                mfpra.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=8)
                mfpra.set_ylabel('Kinetic Energy (eV)', font='Arial', fontsize=12)
                mfprl1.set_xdata([xl[0], xl[1]])
                mfprl1.set_ydata([ev[i], ev[i]])
                mfprl2.set_ydata([ev[i] - de, ev[i] + de])
                mfprl3.set_ydata([ev[i] - de, ev[i] + de])
                # mfprl1,=mfpra.plot([xl[0], xl[1]], [ev[i], ev[i]], 'r-')
            else:
                mfpra.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=8)
                mfpra.set_ylabel('Binding Energy (eV)', font='Arial', fontsize=12)
                mfprl1.set_xdata([xl[0], xl[1]])
                mfprl1.set_ydata([vfe - ev[i], vfe - ev[i]])
                mfprl2.set_ydata([vfe - ev[i] - de, vfe - ev[i] + de])
                mfprl3.set_ydata([vfe - ev[i] - de, vfe - ev[i] + de])
                # mfprl1,=mfpra.plot([xl[0], xl[1]], [vfe - ev[i], vfe - ev[i]], 'r-')
            mfprl2.set_xdata([xl[0], xl[0]])
            mfprl3.set_xdata([xl[1], xl[1]])
            # mfprl2,=mfpra.plot([xl[0], xl[0]], [ev[i] - de, ev[i] + de], 'r-')
            # mfprl3,=mfpra.plot([xl[1], xl[1]], [ev[i] - de, ev[i] + de], 'r-')
            
        mfitprout1.draw()
    except:
        pass
    
    
def mprplot_job1():
    t = threading.Thread(target=_mprplot_job1)
    t.daemon = True
    t.start()

def mprplot(xl):
    global mprxl
    if mpr==1:
        mprxl = xl
        mpr2draw()
        mpr3draw()
        mprplot_job1()

def mprbgjob1():
    while True:
        if mpr==1:
            try:
                mfitprout1.draw()
            except:
                pass
def mprbg1():
    t = threading.Thread(target=mprbgjob1)
    t.daemon = True
    t.start()
def mprbgjob2():
    while True:
        if mpr==1:
            try:
                mfitprout2.draw()
            except:
                pass
def mprbg2():
    t = threading.Thread(target=mprbgjob2)
    t.daemon = True
    t.start()
def mprbgjob3():
    while True:
        if mpr==1:
            try:
                mfitprout3.draw()
            except:
                pass
def mprbg3():
    t = threading.Thread(target=mprbgjob3)
    t.daemon = True
    t.start() 

def f_pr():
    global mfpr, mpr, mfitprfig1, mfitprfig2, mfitprfig3, mfitprout1, mfitprout2, mfitprout3
    mfpr=0
    if mpr==1:
        mpr=0
        b_pr.config(text='Real Time Preview OFF', fg='red')
        mfitprfig1.clear()
        mfitprfig2.clear()
        mfitprfig3.clear()
        mfitprout1.draw()
        mfitprout2.draw()
        mfitprout3.draw()
    else:
        mpr=1
        mprplot(mxl)
        b_pr.config(text='Real Time Preview ON', fg='green')

def filter(y, a, b):
    """
    Filters the input array y based on the conditions defined by a and b.
    """
    if a > b:
        a, b = b, a  # Ensure a is less than or equal to b
    return np.array([x for x in y if a <= x <= b]), np.array([i for i, x in enumerate(y) if a <= x <= b])

def mfitplot():  # mfiti Scale
    global mfitax, mxl, myl, klmin, klmax, tmxl, kmin, kmax, maa2, flmcomp, lm1, lm2, lm3, lm4, lm5, lm6, mxf1, mxf2, mwf1, mwf2, maf1, maf2, mt1, mt2, mt3, mt4, mt5, fdo, mf_prswap
    i = mfiti.get()
    mfitfig.clear()
    mfitax = mfitfig.subplots()
    # 'Pos:'+str(round(maa1[i,0],3))+r' $(\frac{2\pi}{\AA})$'+', FWHM:'+str(round(maa1[i,2],3))+r' $(\frac{2\pi}{\AA})$'
    if emf=='KE':
        mfitax.set_title('Kinetic Energy:' + str(round(mvv[i], 3))+' eV, '+str(mfp[i])+' Peak')
    else:
        mfitax.set_title('Binding Energy:' + str(round(vfe-mvv[i], 3))+' eV, '+str(mfp[i])+' Peak')
    mfitax.scatter(fmx[i, :], fmy[i, :], c='k', s=4)
    tyl = mfitax.get_ylim()
    txl = mfitax.get_xlim()
    dy = (tyl[1]-tyl[0])/20
    dx = (txl[1]-txl[0])/50
    tymin = tyl[0]
    tymax = tyl[1]
    txmin = txl[0]
    txmax = txl[1]
    mfitax.axhline(tymax+dy, c='grey')
    # x = fmxx[i, np.argwhere(fmxx[i, :] >= -20)].flatten()
    # y = fmyy[i, np.argwhere(fmxx[i, :] >= -20)].flatten()
    x, x_arg = filter(fmx[i, :], kmin[i], kmax[i])
    y = fmy[i, x_arg]
    lbg = lnr_bg(y)
    if i in mfi_x:
        for l, v in zip([lm1, lm2, lm3, lm4, lm5, lm6], ['', '', '', '', '', '']):
            l.config(text=v)
        try:
            mxf1.set(str(smcst[i][0]))
            mxf2.set(str(smcst[i][1]))
            mwf1.set(str(smcst[i][2]))
            mwf2.set(str(smcst[i][3]))
            maf1.set(str(smcst[i][4]))
            maf2.set(str(smcst[i][5]))
        except:
            pass
    if mfp[i] == 1:
        try:
            mxf1.set(str(smcst[i][0]))
            mxf2.set(str(smcst[i][1]))
            mwf1.set(str(smcst[i][2]))
            mwf2.set(str(smcst[i][3]))
            maf1.set(str(smcst[i][4]))
            maf2.set(str(smcst[i][5]))
        except:
            pass
        if maa1[i, 0] == (kmin[i]+kmax[i])/2 and maa1[i, 2] == 0.5:
            fl, = mfitax.plot(x, gl1(x, *maa1[i, :])+lbg, 'r-', lw=2)
        else:
            gl1_1 = gl1(x, *maa1[i, :])+lbg
            fl, = mfitax.plot(x, gl1(x, *maa1[i, :])+lbg, 'b-', lw=2)
            mfitax.fill_between(x, lbg, gl1_1, facecolor='blue', alpha=0.5)
        if i in mfi_err or i in mfi:
            if i in mfi:
                mfitax.plot(x, gl1(x, *maa1[i, :]) +
                            lbg-y+tymax+dy, color='gray', lw=1)
            else:
                mfitax.plot(x, gl1(x, *maa1[i, :]) +
                            lbg-y+tymax+dy, color='red', lw=1)
            # s=(np.sum((gl1(x,*maa1[i,:])+lbg-y)**2)/(max(x)-min(x)))**0.5
            s = np.std(gl1(x, *maa1[i, :])+lbg-y)  # STD
            mt1=mfitax.text(txmin+dx, tymax-dy, 'Residual STD: '+str(round(s, 2)))
            s = np.sqrt(np.mean((gl1(x, *maa1[i, :])+lbg-y)**2))  # RMS
            mt2=mfitax.text(txmin+dx, tymax-2*dy,
                        'Residual RMS: '+str(round(s, 2)))
            ty = gl1(x, *maa1[i, :])
            s = np.sum(np.array([((ty[i]+ty[i+1])/2)for i in range(len(x)-1)])
                    # Area
                    * np.array(([(x[i+1]-x[i])for i in range(len(x)-1)])))
            mt3=mfitax.text(txmin+dx, tymax-3*dy, 'Area: '+str(round(s, 2)))
            vv = []
            for ii in range(6):
                if ii > 2:
                    vv.append(f"")
                else:
                    vv.append(f"{gformat(maa1[i, ii])}")
            for l, n, v in zip([lm1, lm2, lm3, lm4, lm5, lm6], [f"x: ", f"h: ", f"w: ", f"", f"", f""], vv):
                l.config(text=n+v)
                l.config(anchor='center')
            try:
                vv = smresult[i]
                for l, v in zip([lm1, lm2, lm3, lm4, lm5, lm6], vv):
                    l.config(text=v)
                    l.config(anchor='w')
            except:
                pass
            try:
                fitpar1(mresult[i], lm1, lm2, lm3, lm4, lm5, lm6)
            except:
                pass
    elif mfp[i] == 2:
        flmcomp = 0
        if maa2[i, 0] == (kmin[i]+kmax[i])/2 and maa2[i, 2] == 0.5:
            fl, = mfitax.plot(x, gl2(x, *maa2[i, :])+lbg, 'r-', lw=2)
        else:
            if flmcomp1 == 1:
                maa2[i, :4] = [
                    mcpx1, mcpy1-lbg[np.argwhere(abs(x-mcpx1) < 0.01)].flatten()[0], 0.02, 0]
                flmcomp = 1
            elif flmcomp2 == 1:
                maa2[i, -4:] = [mcpx2, mcpy2 -
                                lbg[np.argwhere(abs(x-mcpx2) < 0.01)].flatten()[0], 0.02, 0]
                flmcomp = 1
            gl2_1 = gl1(x, *maa2[i, :4])+lbg
            gl2_2 = gl1(x, *maa2[i, -4:])+lbg
            fl, = mfitax.plot(x, gl2(x, *maa2[i, :])+lbg, 'b-', lw=2)
            mfitax.fill_between(x, lbg, gl2_1, facecolor='green', alpha=0.5)
            mfitax.fill_between(x, lbg, gl2_2, facecolor='purple', alpha=0.5)
        if i in mfi_err or i in mfi:
            if i in mfi:
                mfitax.plot(x, gl2(x, *maa2[i, :]) +
                            lbg-y+tymax+dy, color='gray', lw=1)
            else:
                mfitax.plot(x, gl2(x, *maa2[i, :]) +
                            lbg-y+tymax+dy, color='red', lw=1)
            # s=(np.sum((gl2(x,*maa2[i,:])+lbg-y)**2)/(max(x)-min(x)))**0.5
            s = np.std(gl2(x, *maa2[i, :])+lbg-y)  # STD
            mt1=mfitax.text(txmin+dx, tymax-dy, 'Residual STD: '+str(round(s, 2)))
            s = np.sqrt(np.mean((gl2(x, *maa2[i, :])+lbg-y)**2))  # RMS
            mt2=mfitax.text(txmin+dx, tymax-2*dy,
                        'Residual RMS: '+str(round(s, 2)))
            ty = gl1(x, *maa2[i, :4])
            s = np.sum(np.array([((ty[i]+ty[i+1])/2)for i in range(len(x)-1)])
                    # Area 1
                    * np.array(([(x[i+1]-x[i])for i in range(len(x)-1)])))
            mt3=mfitax.text(txmin+dx, tymax-3*dy, 'Area 1: '+str(round(s, 2)))
            ty = gl1(x, *maa2[i, -4:])
            s = np.sum(np.array([((ty[i]+ty[i+1])/2)for i in range(len(x)-1)])
                    # Area 2
                    * np.array(([(x[i+1]-x[i])for i in range(len(x)-1)])))
            mt4=mfitax.text(txmin+dx, tymax-4*dy, 'Area 2: '+str(round(s, 2)))
            try:
                if smcst[i][4] != 0 and smcst[i][5] != 0:
                    mt5=mfitax.text(txmin+dx, tymax-5*dy, 'A1:A2='+str(smcst[i][4])+':'+str(smcst[i][5]))
                mxf1.set(str(smcst[i][0]))
                mxf2.set(str(smcst[i][1]))
                mwf1.set(str(smcst[i][2]))
                mwf2.set(str(smcst[i][3]))
                maf1.set(str(smcst[i][4]))
                maf2.set(str(smcst[i][5]))
            except:
                pass
            vv = []
            for ii in range(6):
                if ii < 3:
                    vv.append(f"{gformat(maa2[i, ii])}")
                else:
                    vv.append(f"{gformat(maa2[i, ii+1])}")

            for l, n, v in zip([lm1, lm3, lm5, lm2, lm4, lm6], [f"x1: ", f"h1: ", f"w1: ", f"x2: ", f"h2: ", f"w2: "], vv):
                l.config(text=n+v)
                l.config(anchor='center')
            try:
                vv = smresult[i]
                for l, v in zip([lm1, lm2, lm3, lm4, lm5, lm6], vv):
                    if 'nofit' not in v:
                        l.config(text=v)
                        l.config(anchor='w')
            except:
                pass
            try:
                if fdo==0 or i not in mf_prswap:
                    fitpar2(mresult[i], lm1, lm2, lm3, lm4, lm5, lm6)
                else:
                    mresult[i]=smresult[i]
                    fdo=0
                    try:
                        if mf_prswap:
                            mf_prswap.remove(i)
                    except:
                        pass
            except:
                pass
    # mfitax.plot(fmxx[i, np.argwhere(fmxx[i, :] >= -20)], lbg, 'g--')
    mfitax.plot(x, lbg, 'g--')
    # if bg_warn==1:  #shirley base line warn
    #     mfitax.plot(fmxx[i,np.argwhere(fmxx[i,:]>=-20)],lbg,'r--')
    # else:
    #     mfitax.plot(fmxx[i,np.argwhere(fmxx[i,:]>=-20)],lbg,'g--')

    # mfitax.scatter(fmxx[i, np.argwhere(fmxx[i, :] >= -20)], y, c='g', s=4)
    mfitax.scatter(x, y, c='g', s=4)
    if (kmin[i], kmax[i]) != ((2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(-0.5/180*np.pi)*10**-10/(h/2/np.pi), (2*m*ev[i]*1.602176634*10**-19)**0.5*np.sin(0.5/180*np.pi)*10**-10/(h/2/np.pi)):
        klmin = mfitax.axvline(kmin[i], c='r')
        klmax = mfitax.axvline(kmax[i], c='r')
    else:
        klmin = mfitax.axvline(kmin[i], c='grey')
        klmax = mfitax.axvline(kmax[i], c='grey')
        fl.set_alpha(0.3)
    mfitax.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', fontsize=14)
    mfitax.set_ylabel('Intensity (Counts)', fontsize=14)
    mxl = mfitax.get_xlim()
    myl = mfitax.get_ylim()
    tmxl = np.copy(mxl)
    mfitout.draw()
    mplfi()


def mmove(event):
    global mxdata, mydata, mdxdata, mdydata, x2, y2, mfitax, mfitout, klmin, klmax, kmin, kmax, tpx1, tpx2, tpy1, tpy2, tx2, ty2, mcpx1, mcpy1, mcpx2, mcpy2
    if event.xdata != None:
        if mmof == -1:
            x2, y2 = event.xdata, event.ydata
            px2, py2 = event.x, event.y
            if flmcomp1 == 1:
                mcpx1 = x2
                mcpy1 = y2
                mfitplot()
            elif flmcomp2 == 1:
                mcpx2 = x2
                mcpy2 = y2
                mfitplot()
            elif fklmin == 1 and tkmin+(x2-x1) >= mxl[0] and tkmin+(x2-x1) <= mxl[1]:
                klmin.remove()
                klmin = mfitax.axvline(x2, c='r')
                kmin[mfiti.get()] = x2
                klmax.set_color('r')
                mfitout.draw()
            elif fklmax == 1 and tkmax+(x2-x1) >= mxl[0] and tkmax+(x2-x1) <= mxl[1]:
                klmax.remove()
                klmax = mfitax.axvline(x2, c='r')
                kmax[mfiti.get()] = x2
                klmin.set_color('r')
                mfitout.draw()
            elif fkregion == 1 and tkmin+(x2-x1) >= mxl[0] and tkmax+(x2-x1) <= mxl[1]:
                klmin.remove()
                klmin = mfitax.axvline(tkmin+(x2-x1), c='r')
                kmin[mfiti.get()] = tkmin+(x2-x1)
                klmax.remove()
                klmax = mfitax.axvline(tkmax+(x2-x1), c='r')
                kmax[mfiti.get()] = tkmax+(x2-x1)
                mfitout.draw()
            elif fklmin == 0 and fklmax == 0 and fkregion == 0:
                mfitout.get_tk_widget().delete('rec')
                tpx1, tpy1, tpx2, tpy2 = px1, py1, px2, py2
                mfitout.get_tk_widget().create_rectangle(
                    (px1, 600-py1), (px2, 600-py2), outline='grey', width=2, tag='rec')
                [tpx1, tpx2] = sorted([tpx1, tpx2])
                [tpy1, tpy2] = sorted([tpy1, tpy2])
                tx2, ty2 = x2, y2
                mdxdata.config(text='dx:'+str('%.3f' % abs(x2-x1)))
                mdydata.config(text='dy:'+str('%.3f' % abs(y2-y1)))
        mxdata.config(text='xdata:'+str('%.3f' % event.xdata))
        mydata.config(text='ydata:'+str('%.3f' % event.ydata))
    else:
        mfitout.get_tk_widget().config(cursor="")
        try:
            mxdata.config(text='xdata:')
            mydata.config(text='ydata:')
        except NameError:
            pass

    # print("event.xdata", event.xdata)
    # print("event.ydata", event.ydata)
    # print("event.inaxes", event.inaxes)
    # print("x", event.x)
    # print("y", event.y)
mmof = 1


def mpress(event):
    # event.button 1:left 3:right 2:mid
    # event.dblclick : bool
    # print('%s click: button=%d, x=%d, y=%d, xdata=%f, ydata=%f' %
    #       ('double' if event.dblclick else 'single', event.button,
    #        event.x, event.y, event.xdata, event.ydata))
    global x1, y1, mmof, px1, py1, mfitax, mfitout, klmin, klmax, fklmin, fklmax, cki, mbase, fkregion, tkmin, tkmax, tx1, ty1
    if event.button == 1 and event.inaxes:
        x1, y1 = event.xdata, event.ydata
        px1, py1 = event.x, event.y
        fklmin, fklmax, fkregion = 0, 0, 0
        tkmin, tkmax = kmin[mfiti.get()], kmax[mfiti.get()]
        if flmcomp1 == 1:
            pass
        elif flmcomp2 == 1:
            pass
        elif mfitout.get_tk_widget().find_withtag('rec') != () and px1 > tpx1 and px1 < tpx2 and py1 > tpy1 and py1 < tpy2:
            pass
        elif abs(x1-kmin[mfiti.get()]) < (tmxl[1]-tmxl[0])/80:
            fklmin = 1

        elif abs(x1-kmax[mfiti.get()]) < (tmxl[1]-tmxl[0])/80:
            fklmax = 1

        elif x1 > kmin[mfiti.get()] and x1 < kmax[mfiti.get()]:
            fkregion = 1

        elif mfitout.get_tk_widget().find_withtag('rec') == ():
            tx1, ty1 = x1, y1
        mmof = -1
    elif event.button == 3:
        try:
            mfitout.get_tk_widget().delete('rec')
            mdxdata.config(text='dx:')
            mdydata.config(text='dy:')
            mt1.set_visible(True)
            mt2.set_visible(True)
            mt3.set_visible(True)
            mt4.set_visible(True)
            mt5.set_visible(True)
        except:
            pass
        mfitax.set_xlim(mxl)
        mfitax.set_ylim(myl)
        mprplot(mxl)
        mfitout.draw()
        mmof = 1


def mrelease(event):
    global x1, y1, x2, y2, mmof, mfitout, mfitax, fklmax, fklmin, klmin, klmax, kmin, kmax, fkregion, tmxl, mbgv
    if event.button == 1 and mmof == -1 and event.inaxes:
        x2, y2 = event.xdata, event.ydata
        if kmin[mfiti.get()] > kmax[mfiti.get()]:
            kmin[mfiti.get()], kmax[mfiti.get()
                                    ] = kmax[mfiti.get()], kmin[mfiti.get()]
            klmin, klmax = klmax, klmin
        else:
            kmin[mfiti.get()], kmax[mfiti.get()
                                    ] = kmin[mfiti.get()], kmax[mfiti.get()]
            klmin, klmax = klmin, klmax
        if fklmin == 0 and fklmax == 0 and fkregion == 0 and (x2, y2) == (x1, y1) and px1 > tpx1 and px1 < tpx2 and py1 > tpy1 and py1 < tpy2:
            try:
                mfitout.get_tk_widget().delete('rec')
                mt1.set_visible(False)
                mt2.set_visible(False)
                mt3.set_visible(False)
                mt4.set_visible(False)
                mt5.set_visible(False)
            except:
                pass
            mfitax.set_xlim(sorted([tx1, tx2]))
            mfitax.set_ylim(sorted([ty1, ty2]))
            mprplot(sorted([tx1, tx2]))
            tmxl = sorted([x1, x2])
            mfitout.draw()
        elif fklmin == 1 or fklmax == 1 or fkregion == 1:
            func_cki()
            x1, x2, y1, y2 = [], [], [], []
            mbgv=0
            mfit()
            mfitplot()
        mmof = 1


def tmstate():
    try:
        while True:
            mstate.config(text=str(mst.get()))
    except KeyboardInterrupt:
        pass


def mfli(event):
    global mfiti
    i=mfiti.get()
    if i>0:
        mfiti.set(i-1)
    else:
        mfiti.set(len(ev)-1)
        
def mfri(event):
    global mfiti
    i=mfiti.get()
    if i<len(ev)-1:
        mfiti.set(i+1)
    else:
        mfiti.set(0)

def mflind():
    global mfiti
    ti = mfiti.get()
    if ti in mfi:
        for i in range(ti+1):
            if ti-i not in mfi:
                mfiti.set(ti-i)
                break
    elif ti in mfi_err:
        for i in range(ti+1):
            if ti-i not in mfi_err:
                mfiti.set(ti-i)
                break
    elif ti in mfi_x:
        for i in range(ti+1):
            if ti-i in mfi or ti-i in mfi_err:
                mfiti.set(ti-i)
                break
        if i == ti and ti != 0:
            mfiti.set(ti-1)


def mfrind():
    global mfiti
    ti = mfiti.get()
    if ti in mfi:
        for i in range(len(ev)-ti):
            if ti+i not in mfi:
                mfiti.set(ti+i)
                break
    elif ti in mfi_err:
        for i in range(len(ev)-ti):
            if ti+i not in mfi_err:
                mfiti.set(ti+i)
                break
    elif ti in mfi_x:
        for i in range(len(ev)-ti):
            if ti+i in mfi or ti+i in mfi_err:
                mfiti.set(ti+i)
                break
        if i == len(ev)-ti-1 and ti != len(ev)-1:
            mfiti.set(ti+1)


def mfcomp1():
    global mbcomp1, flmcomp1, mbcomp2, flmcomp2
    if flmcomp2 == -1:
        flmcomp1 *= -1
        if flmcomp1 == 1:
            mbcomp1.config(text='Comp 1', bg='green')
        else:
            mbcomp1.config(text='Comp 1', bg='white')
    else:
        flmcomp2 *= -1
        flmcomp1 *= -1
        mbcomp1.config(text='Comp 1', bg='green')
        mbcomp2.config(text='Comp 2', bg='white')


def mfcomp2():
    global mbcomp1, flmcomp1, mbcomp2, flmcomp2
    if flmcomp1 == -1:
        flmcomp2 *= -1
        if flmcomp2 == 1:
            mbcomp2.config(text='Comp 2', bg='purple')
        else:
            mbcomp2.config(text='Comp 2', bg='white')
    else:
        flmcomp1 *= -1
        flmcomp2 *= -1
        mbcomp2.config(text='Comp 2', bg='purple')
        mbcomp1.config(text='Comp 1', bg='white')


def ffitcp():
    mfit()
    mfitplot()


def fmaccept():
    global mfi, mfi_x, mfi_err
    msave_state()
    i = mfiti.get()
    if i not in mfi:
        mfi.append(i)
    if i in mfi_x:
        mfi_x.remove(i)
    if i in mfi_err:
        mfi_err.remove(i)
    mfitplot()


def fmreject():
    global mfi, mfi_x, mfi_err, mbreject, flmreject, mirej
    msave_state()
    i = mfiti.get()
    flmreject *= -1
    if flmreject == 1:
        mirej = i
        mbreject.config(text='End Reject', bg='red')
    else:
        ti = sorted([i, mirej])
        for i in np.linspace(ti[0], ti[1], ti[1]-ti[0]+1, dtype=int):
            if i not in mfi_x:
                mfi_x.append(i)
            if i in mfi:
                mfi.remove(i)
            if i in mfi_err:
                mfi_err.remove(i)
        mbreject.config(text='Reject', bg='white')
        mfitplot()
    


def o_fmwf1(*e):
    global mwf1
    if '' == mwf1.get():
        mwf1.set('0')
        min_w1.select_range(0, 1)


def fmwf1(*e):
    t = threading.Thread(target=o_fmwf1)
    t.daemon = True
    t.start()


def o_fmwf2(*e):
    global mwf2
    if '' == mwf2.get():
        mwf2.set('0')
        min_w2.select_range(0, 1)


def fmwf2(*e):
    t = threading.Thread(target=o_fmwf2)
    t.daemon = True
    t.start()


def o_fmaf1(*e):
    global maf1
    if '' == maf1.get():
        maf1.set('0')
        min_a1.select_range(0, 1)


def fmaf1(*e):
    t = threading.Thread(target=o_fmaf1)
    t.daemon = True
    t.start()


def o_fmaf2(*e):
    global maf2
    if '' == maf2.get():
        maf2.set('0')
        min_a2.select_range(0, 1)


def fmaf2(*e):
    t = threading.Thread(target=o_fmaf2)
    t.daemon = True
    t.start()


def o_fmxf1(*e):
    global mxf1
    if '' == mxf1.get():
        mxf1.set('1')
        min_x1.select_range(0, 1)


def fmxf1(*e):
    t = threading.Thread(target=o_fmxf1)
    t.daemon = True
    t.start()


def o_fmxf2(*e):
    global mxf2
    if '' == mxf2.get():
        mxf2.set('0')
        min_x2.select_range(0, 1)


def fmxf2(*e):
    t = threading.Thread(target=o_fmxf2)
    t.daemon = True
    t.start()


def fmposcst():
    global mbposcst, flmposcst, min_x1, min_x2
    flmposcst *= -1
    if flmposcst == 1:
        min_x1.config(state='normal')
        min_x2.config(state='normal')
        mbposcst.config(bg='purple')
    else:
        min_x1.config(state='disabled')
        min_x2.config(state='disabled')
        mbposcst.config(bg='white')


def mjob():     # MDC Fitting GUI
    global g, mfiti, mfitfig, mfitout, mgg, mxdata, mydata, mdxdata, mdydata, miout, mifig, mfi, mfi_err, mfi_x, mbrmv, flmrmv, mbcgl2, mfp, flmcgl2, fpr, mst, mstate, mwf1, mwf2, maf1, maf2, mxf1, mxf2, mlind, mrind, mbcomp1, flmcomp1, mbcomp2, flmcomp2, min_w1, min_w2, min_a1, min_a2, min_x1, min_x2, lm1, lm2, lm3, lm4, lm5, lm6, mresult, smresult, mbposcst, flmposcst, smcst, mbreject, flmreject, mfitprfig1, mfitprout1, mfitprfig2, mfitprout2, mfitprfig3, mfitprout3, mfpr, mprf, mpr, b_pr, mbgv, fdo
    mgg = tk.Toplevel(g, bg='white')
    mgg.geometry(f"1900x1000+0+0")
    mgg.title('MDC Lorentz Fit')
    fdo=0
    mpr=0   #button flag 1:ON 0:OFF initial 0:OFF
    # b_pr = tk.Button(mgg, text='Real Time Preview ON', command=f_pr, width=20, height=2, font=('Arial', 12, "bold"), bg='white')
    # b_pr.grid(row=0, column=0)
    
    mfpr = 0    #preview plot pcolormesh flag 1:setdata 0:pcolormesh
    fr_pr1 = tk.Frame(master=mgg, bg='white')
    fr_pr1.grid(row=1, column=0)
    b_pr = tk.Button(fr_pr1, text='Real Time Preview OFF', command=f_pr, width=20, height=2, font=('Arial', 12, "bold"), bg='white',fg='red')
    b_pr.grid(row=0, column=0)
    mfitprfig2 = Figure(figsize=(3, 3), layout='constrained')
    mfitprout2 = FigureCanvasTkAgg(mfitprfig2, master=fr_pr1)
    mfitprout2.get_tk_widget().grid(row=1, column=0)
    mfitprfig3 = Figure(figsize=(3, 3), layout='constrained')
    mfitprout3 = FigureCanvasTkAgg(mfitprfig3, master=fr_pr1)
    mfitprout3.get_tk_widget().grid(row=2, column=0)
    
    fr_pr2 = tk.Frame(master=mgg, bg='white')
    fr_pr2.grid(row=2, column=0)
    mfitprfig1 = Figure(figsize=(3, 2), layout='constrained')
    mfitprout1 = FigureCanvasTkAgg(mfitprfig1, master=fr_pr2)
    mfitprout1.get_tk_widget().grid(row=0, column=0)
    mst = queue.Queue(maxsize=0)
    mstate = tk.Label(mgg, text='', font=(
        "Arial", 14, "bold"), bg="white", fg="black")
    mstate.grid(row=0, column=1)
    fr = tk.Frame(master=mgg, bg='white')
    fr.grid(row=1, column=1)
    frind = tk.Frame(master=fr, bg='white')
    frind.grid(row=0, column=0)
    mlind = tk.Button(frind, text='<<', command=mflind, width=10,
                      height=2, font=('Arial', 14, "bold"), bg='white')
    mlind.grid(row=0, column=0)
    mrind = tk.Button(frind, text='>>', command=mfrind, width=10,
                      height=2, font=('Arial', 14, "bold"), bg='white')
    mrind.grid(row=0, column=2)

    mfiti = tk.IntVar()
    mfiti.set(0)
    mfiti.trace_add('write', fchki)
    chi = tk.Scale(frind, label='Index', from_=0, to=len(ev)-1, orient='horizontal',
                   variable=mfiti, state='active', bg='white', fg='black', length=580, width=30, resolution=1)
    chi.grid(row=0, column=1)

    mfi, mfi_err, mfi_x = [], [], [i for i in range(len(ev))]
    mifig = Figure(figsize=(6, 0.2), layout='tight')
    miout = FigureCanvasTkAgg(mifig, master=frind)
    miout.get_tk_widget().grid(row=1, column=1)

    mfitfig = Figure(figsize=(8, 6), layout='constrained')
    mfitout = FigureCanvasTkAgg(mfitfig, master=fr)
    mfitout.get_tk_widget().grid(row=1, column=0)
    mfitout.mpl_connect('motion_notify_event', mmove)
    mfitout.mpl_connect('button_press_event', mpress)
    mfitout.mpl_connect('button_release_event', mrelease)

    xydata = tk.Frame(master=fr, bd=5, bg='white')
    xydata.grid(row=2, column=0)

    mxdata = tk.Label(xydata, text='xdata:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=5, bg='white')
    mxdata.grid(row=0, column=0)
    mydata = tk.Label(xydata, text='ydata:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=5, bg='white')
    mydata.grid(row=0, column=1)
    mdxdata = tk.Label(xydata, text='dx:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=5, bg='white')
    mdxdata.grid(row=0, column=2)
    mdydata = tk.Label(xydata, text='dy:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=5, bg='white')
    mdydata.grid(row=0, column=3)

    # bstop=tk.Button(gg,command=stop,text='Stop',font=('Arial',20),bd=5)
    # bstop.grid(row=1,column=0)

    frpara = tk.Frame(master=mgg, bd=5, bg='white')
    frpara.grid(row=1, column=2)
    
    mfp = [1 for i in range(len(ev))]
    try:
        if fpr == 1:
            mfp = list(smfp)
            mfi = list(smfi)
    except:
        pass
    flmcgl2 = -1
    frre = tk.Frame(master=frpara, bd=5, bg='white')
    frre.grid(row=0, column=0)
    b_mundo = tk.Button(frre, text='Undo', command=mundo,width=25, height=1, font=('Arial', 14, "bold"), bg='white')
    b_mundo.grid(row=0, column=0)
    b_mredo = tk.Button(frre, text='Redo', command=mredo,width=25, height=1, font=('Arial', 14, "bold"), bg='white')
    b_mredo.grid(row=0, column=1)
    frpara00 = tk.Frame(master=frpara, bd=5, bg='white')
    frpara00.grid(row=1, column=0)

    frfitpar = tk.Frame(master=frpara00, bd=5, bg='white')
    frfitpar.grid(row=0, column=0)
    lm1 = tk.Label(frfitpar, anchor='w', text='', font=(
        "Arial", 16, "bold"), width='50', height='1', bd=5, bg='white')
    lm1.grid(row=0, column=0)
    lm2 = tk.Label(frfitpar, anchor='w', text='', font=(
        "Arial", 16, "bold"), width='50', height='1', bd=5, bg='white')
    lm2.grid(row=1, column=0)
    lm3 = tk.Label(frfitpar, anchor='w', text='', font=(
        "Arial", 16, "bold"), width='50', height='1', bd=5, bg='white')
    lm3.grid(row=2, column=0)
    lm4 = tk.Label(frfitpar, anchor='w', text='', font=(
        "Arial", 16, "bold"), width='50', height='1', bd=5, bg='white')
    lm4.grid(row=3, column=0)
    lm5 = tk.Label(frfitpar, anchor='w', text='', font=(
        "Arial", 16, "bold"), width='50', height='1', bd=5, bg='white')
    lm5.grid(row=4, column=0)
    lm6 = tk.Label(frfitpar, anchor='w', text='', font=(
        "Arial", 16, "bold"), width='50', height='1', bd=5, bg='white')
    lm6.grid(row=5, column=0)

    frYN = tk.Frame(master=frfitpar, bd=5, bg='white')
    frYN.grid(row=6, column=0)
    mbaccept = tk.Button(frYN, text='Accept', command=fmaccept,
                         width=25, height=1, font=('Arial', 14, "bold"), bg='white')
    mbaccept.grid(row=0, column=0)
    mbreject = tk.Button(frYN, text='Reject', command=fmreject,
                         width=25, height=1, font=('Arial', 14, "bold"), bg='white')
    mbreject.grid(row=0, column=1)

    l1 = tk.Label(frpara00, text='Index Operation', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=5, bg='white')
    l1.grid(row=1, column=0)
    froperind = tk.Frame(master=frpara00, bd=5, bg='white')
    froperind.grid(row=2, column=0)
    mbcgl2 = tk.Button(froperind, text='Add 2 Peaks', command=fmcgl2,
                       width=25, height=1, font=('Arial', 14, "bold"), bg='white')
    mbcgl2.grid(row=0, column=0)
    mbrmv = tk.Button(froperind, text='Remove', command=fmrmv,
                      width=25, height=1, font=('Arial', 14, "bold"), bg='white')
    mbrmv.grid(row=0, column=1)
    mbcomp1 = tk.Button(froperind, text='Comp 1', command=mfcomp1,
                        width=14, height=1, font=('Arial', 14, "bold"), bg='white')
    mbcomp1.grid(row=1, column=0)
    mbcomp2 = tk.Button(froperind, text='Comp 2', command=mfcomp2,
                        width=14, height=1, font=('Arial', 14, "bold"), bg='white')
    mbcomp2.grid(row=1, column=1)

    mbfitcp = tk.Button(master=frpara00, text='Fit Components', command=ffitcp,
                        width=40, height=1, font=('Arial', 14, "bold"), bg='white')
    mbfitcp.grid(row=3, column=0)

    frwr = tk.Frame(master=frpara00, bd=5, bg='white')
    frwr.grid(row=4, column=0)
    l2 = tk.Label(frwr, text='FWHM Ratio', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=5, bg='white')
    l2.grid(row=0, column=1)
    l3 = tk.Label(frwr, text=':', font=("Arial", 12, "bold"),
                  width='15', height='1', bd=5, bg='white')
    l3.grid(row=1, column=1)
    mwf1 = tk.StringVar()
    mwf1.set('0')
    mwf1.trace_add('write', fmwf1)
    min_w1 = tk.Entry(frwr, font=("Arial", 12, "bold"),
                      width=7, textvariable=mwf1, bd=5)
    min_w1.grid(row=1, column=0)
    mwf2 = tk.StringVar()
    mwf2.set('0')
    mwf2.trace_add('write', fmwf2)
    min_w2 = tk.Entry(frwr, font=("Arial", 12, "bold"),
                      width=7, textvariable=mwf2, bd=5)
    min_w2.grid(row=1, column=2)

    frar = tk.Frame(master=frpara00, bd=5, bg='white')
    frar.grid(row=5, column=0)
    l2 = tk.Label(frar, text='Area Ratio', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=5, bg='white')
    l2.grid(row=0, column=1)
    l3 = tk.Label(frar, text=':', font=("Arial", 12, "bold"),
                  width='15', height='1', bd=5, bg='white')
    l3.grid(row=1, column=1)
    maf1 = tk.StringVar()
    maf1.set('0')
    maf1.trace_add('write', fmaf1)
    min_a1 = tk.Entry(frar, font=("Arial", 12, "bold"),
                      width=7, textvariable=maf1, bd=5)
    min_a1.grid(row=1, column=0)
    maf2 = tk.StringVar()
    maf2.set('0')
    maf2.trace_add('write', fmaf2)
    min_a2 = tk.Entry(frar, font=("Arial", 12, "bold"),
                      width=7, textvariable=maf2, bd=5)
    min_a2.grid(row=1, column=2)

    mbposcst = tk.Button(frpara00, text='Position constraint', command=fmposcst,
                         width=25, height=1, font=('Arial', 14, "bold"), bg='white')
    mbposcst.grid(row=6, column=0)

    frxr = tk.Frame(master=frpara00, bd=5, bg='white', padx=30)
    frxr.grid(row=7, column=0)
    l3 = tk.Label(frxr, text='x2 =', font=("Arial", 12, "bold"),
                  width='5', height='1', bd=5, bg='white')
    l3.grid(row=0, column=0)
    mxf1 = tk.StringVar()
    mxf1.set('1')
    mxf1.trace_add('write', fmxf1)
    min_x1 = tk.Entry(frxr, font=("Arial", 12, "bold"), width=7,
                      textvariable=mxf1, bd=5, state='disabled')
    min_x1.grid(row=0, column=1)
    l3 = tk.Label(frxr, text='* x1 +', font=("Arial", 12, "bold"),
                  width='5', height='1', bd=5, bg='white')
    l3.grid(row=0, column=2)
    mxf2 = tk.StringVar()
    mxf2.set('0')
    mxf2.trace_add('write', fmxf2)
    min_x2 = tk.Entry(frxr, font=("Arial", 12, "bold"), width=7,
                      textvariable=mxf2, bd=5, state='disabled')
    min_x2.grid(row=0, column=3)

    frout = tk.Frame(master=mgg, bd=5, bg='white')
    frout.grid(row=2, column=1)
    bfall = tk.Button(frout, text='Fit All', command=fmfall,
                      width=25, height=1, font=('Arial', 14, "bold"), bg='white')
    bfall.grid(row=0, column=0)

    flmreject = -1
    flmposcst = -1
    flmrmv = -1
    flmcomp1 = -1
    flmcomp2 = -1

    bprv = tk.Button(frout, text='Preview', command=fmpreview, width=25,
                     height=1, font=('Arial', 14, "bold"), bg='white')
    bprv.grid(row=1, column=0)
    
    bend = tk.Button(frout, text='Export All', command=fmend, width=25,
                     height=1, font=('Arial', 14, "bold"), bg='white')
    bend.grid(row=2, column=0)

    frexp = tk.Frame(frout, bd=5, bg='white')
    frexp.grid(row=3, column=0)

    bend1 = tk.Button(frexp, text='Export Comp 1', command=fmend1, width=25,
                      height=1, font=('Arial', 14, "bold"), bg='white')
    bend1.grid(row=0, column=0)
    
    bend2 = tk.Button(frexp, text='Export Comp 2', command=fmend2, width=25,
                      height=1, font=('Arial', 14, "bold"), bg='white')
    bend2 .grid(row=0, column=1)
    
    mbgv=0
    mgg.bind("<Up>",mfbgu)
    mgg.bind("<Down>",mfbgd)
    mgg.bind("<Left>",mfli)
    mgg.bind("<Right>",mfri)
    
    ##### test ##### 
    # mprbg1()
    # mprbg2()
    # mprbg3()
    
    mresult = [[]for i in range(len(ev))]
    try:
        flsmresult = smresult
        flsmcst = smcst
    except:
        smcst=np.zeros(len(ev)*6).reshape(len(ev),6)
        smresult = [1]
    if mprfit == 1:
        fmfall()
    else:
        mfitplot()
    tt = threading.Thread(target=tmstate)
    tt.daemon = True
    tt.start()
    mgg.update_idletasks()
    screen_width = mgg.winfo_reqwidth()
    screen_height = mgg.winfo_reqheight()
    mgg.geometry(f"{screen_width}x{screen_height}+0+0")
    mgg.update()


#################################### prefit ######################################################
mprfit = 0


def fitm():
    global ev, phi, data, mvv, maa1, maa2, fmxx, fmyy, fmx, fmy, kmin, kmax, cki, mbase, mprfit, mf_prswap, smresult
    mprfit = 0
    cki = []
    mbase = [0 for i in range(len(ev))]
    mf_prswap = []

    if fpr == 1:
        try:
            kmin, kmax = skmin, skmax
        except NameError:
            kmin, kmax = np.float64((2*m*ev*1.602176634*10**-19)**0.5*np.sin(-0.5/180*np.pi)*10**-10/(
                h/2/np.pi)), np.float64((2*m*ev*1.602176634*10**-19)**0.5*np.sin(0.5/180*np.pi)*10**-10/(h/2/np.pi))
        if len(scki) >= 2:
            cki = scki
    else:
        kmin, kmax = np.float64((2*m*ev*1.602176634*10**-19)**0.5*np.sin(-0.5/180*np.pi)*10**-10/(
            h/2/np.pi)), np.float64((2*m*ev*1.602176634*10**-19)**0.5*np.sin(0.5/180*np.pi)*10**-10/(h/2/np.pi))
    # fmxx = np.float64((np.ones(len(phi)*len(ev))).reshape(len(ev), len(phi)))
    # fmyy = np.float64((np.ones(len(phi)*len(ev))).reshape(len(ev), len(phi)))
    # fmxx *= -50
    # fmyy *= -50
    fmx = np.float64(np.arange(len(phi)*len(ev)).reshape(len(ev), len(phi)))
    fmy = np.float64(np.arange(len(phi)*len(ev)).reshape(len(ev), len(phi)))
    mvv = np.float64(np.arange(len(ev)))
    maa1 = np.float64(np.arange(4*len(ev)).reshape(len(ev), 4))
    maa2 = np.float64(np.arange(8*len(ev)).reshape(len(ev), 8))
    pbar = tqdm.tqdm(total=len(ev), desc='MDC', colour='green')
    for i, v in enumerate(ev):
        ecut = data.sel(eV=v, method='nearest')
        if npzf:x = phi
        else:x = np.float64((2*m*v*1.602176634*10**-19)**0.5*np.sin(phi/180*np.pi)*10**-10/(h/2/np.pi))
        y = ecut.to_numpy().reshape(len(x))
        xx, x_arg = filter(x, kmin[i], kmax[i])
        # tx = x[np.argwhere(x >= kmin[i])].flatten()
        # xx = tx[np.argwhere(tx <= kmax[i])].flatten()
        # ty = y[np.argwhere(x >= kmin[i])].flatten()
        # yy = ty[np.argwhere(tx <= kmax[i])].flatten()
        yy = y[x_arg]
        yy = np.where(yy > int(base.get()), yy, int(base.get()))
        try:
            if i in smfi and fpr == 1:
                a1 = smaa1[i, :]
                a2 = smaa2[i, :]
                smrx1 = smresult[i, 0]
                smrx2 = smresult[i, 1]
                smrh1 = smresult[i, 2]
                smrh2 = smresult[i, 3]
                smrw1 = smresult[i, 4]
                smrw2 = smresult[i, 5]
                if smaa1[i, 1] == 10 or smaa2[i, 1] == 10:
                    mprfit = 1
                else:
                    # fmxx[i, :len(xx)] = xx
                    # tx = fmxx[i, np.argwhere(fmxx[i, :] >= -20)].flatten()
                    tx = xx
                    ty = gl1(tx, *a2[:4])
                    s1 = np.sum(np.array([((ty[i]+ty[i+1])/2)for i in range(len(tx)-1)])
                            # Area 1
                            * np.array(([(tx[i+1]-tx[i])for i in range(len(tx)-1)])))
                    ty = gl1(tx, *a2[-4:])
                    s2 = np.sum(np.array([((ty[i]+ty[i+1])/2)for i in range(len(tx)-1)])
                            # Area 2
                            * np.array(([(tx[i+1]-tx[i])for i in range(len(tx)-1)])))
                    if s1 < s2:
                        t1, t2 = a2[:4], a2[-4:]
                        a2 = np.array([t2, t1]).flatten()
                        mf_prswap.append(i)
                        smrx1 = smrx1.replace('x2', 'x1').replace('x1:', 'x2:')
                        smrx2 = smrx2.replace('x1', 'x2').replace('x2:', 'x1:')
                        smrh1 = smrh1.replace('h1:', 'h2:')
                        smrh2 = smrh2.replace('h2:', 'h1:')
                        smrw1 = smrw1.replace('w1:', 'w2:').replace('w2', 'w1')
                        smrw2 = smrw2.replace('w2:', 'w1:').replace('w1', 'w2')
                        smr = np.array([smrx2,smrx1,smrh2,smrh1,smrw2,smrw1]).flatten()
                    else:
                        smr = np.array([smrx1,smrx2,smrh1,smrh2,smrw1,smrw2]).flatten()
            else:
                a1 = [(kmin[i]+kmax[i])/2, (np.max(y) -
                                            int(base.get())), 0.5, int(base.get())]
                a2 = [(kmin[i]+kmax[i])/2, (np.max(y)-int(base.get())), 0.5, int(base.get()),
                      (kmin[i]+kmax[i])/2, (np.max(y)-int(base.get())), 5, int(base.get())]
                smr = ['' for i in range(6)]
        except:
            a1 = [(kmin[i]+kmax[i])/2, (np.max(y) -
                                        int(base.get())), 0.5, int(base.get())]
            a2 = [(kmin[i]+kmax[i])/2, (np.max(y)-int(base.get())), 0.5, int(base.get()),
                  (kmin[i]+kmax[i])/2, (np.max(y)-int(base.get())), 0.5, int(base.get())]
            smr = ['' for i in range(6)]

        # fmxx[i, :len(xx)] = xx
        # fmyy[i, :len(yy)] = yy
        fmxx, fmyy = 1, 1 # 未使用 暫時保留
        
        fmx[i, :] = x
        fmy[i, :] = y
        mvv[i] = v
        maa1[i, :] = a1
        maa2[i, :] = a2
        try:
            smresult[i, :]=smr
        except:
            pass
        pbar.update(1)
    pbar.close()
    global mgg
    try:
        mgg.destroy()
    except:
        pass
    tt1 = threading.Thread(target=mjob)
    tt1.daemon = True
    tt1.start()


eprfit = 0


def fite():
    global ev, phi, data, evv, eaa1, eaa2, fexx, feyy, fex, fey, emin, emax, cei, ebase, eprfit
    cei = []
    ebase = [0 for i in range(len(phi))]
    if fpr == 1:
        try:
            emin, emax = semin, semax
        except NameError:
            emin = np.float64([np.min(ev) for i in range(len(phi))])
            emax = np.float64([np.max(ev) for i in range(len(phi))])
        if len(scei) >= 2:
            cei = scei
    else:
        emin = np.float64([np.min(ev) for i in range(len(phi))])
        emax = np.float64([np.max(ev) for i in range(len(phi))])
    fexx = np.float64((np.ones(len(ev)*len(phi))).reshape(len(phi), len(ev)))
    feyy = np.float64((np.ones(len(ev)*len(phi))).reshape(len(phi), len(ev)))
    fexx *= -50
    feyy *= -50
    fex = np.float64(np.arange(len(ev)*len(phi)).reshape(len(phi), len(ev)))
    fey = np.float64(np.arange(len(ev)*len(phi)).reshape(len(phi), len(ev)))
    evv = np.float64(np.arange(len(phi)))
    eaa1 = np.float64(np.arange(4*len(phi)).reshape(len(phi), 4))
    eaa2 = np.float64(np.arange(8*len(phi)).reshape(len(phi), 8))
    pbar = tqdm.tqdm(total=len(phi), desc='EDC', colour='blue')
    for i, v in enumerate(phi):
        angcut = data.sel(phi=v, method='nearest')
        x = np.float64(ev)
        y = angcut.to_numpy().reshape(len(x))
        tx = x[np.argwhere(x >= emin[i])].flatten()
        xx = tx[np.argwhere(tx <= emax[i])].flatten()
        ty = y[np.argwhere(x >= emin[i])].flatten()
        yy = ty[np.argwhere(tx <= emax[i])].flatten()
        yy = np.where(yy > int(base.get()), yy, int(base.get()))
        try:
            if i in sefi and fpr == 1:
                a1 = seaa1[i, :]
                a2 = seaa2[i, :]
                if seaa1[i, 1] == 10 or seaa2[i, 1] == 10:
                    eprfit = 1
            else:
                a1 = [(emin[i]+emax[i])/2, (np.max(y) -
                                            int(base.get())), 5, int(base.get())]
                a2 = [(emin[i]+emax[i])/2, (np.max(y)-int(base.get())), 5, int(base.get()),
                      (emin[i]+emax[i])/2, (np.max(y)-int(base.get())), 5, int(base.get())]
        except:
            a1 = [(emin[i]+emax[i])/2, (np.max(y) -
                                        int(base.get())), 5, int(base.get())]
            a2 = [(emin[i]+emax[i])/2, (np.max(y)-int(base.get())), 5, int(base.get()),
                  (emin[i]+emax[i])/2, (np.max(y)-int(base.get())), 5, int(base.get())]

        fexx[i, :len(xx)] = xx
        feyy[i, :len(yy)] = yy
        fex[i, :] = x
        fey[i, :] = y
        evv[i] = v
        eaa1[i, :] = a1
        eaa2[i, :] = a2
        pbar.update(1)
    pbar.close()
    global egg
    try:
        egg.destroy()
    except:
        pass
    tt2 = threading.Thread(target=ejob)
    tt2.daemon = True
    tt2.start()


def cmfit():
    t1 = threading.Thread(target=fitm)
    t1.start()


def cefit():
    t1 = threading.Thread(target=fite)
    t1.start()

############################################################
############################################################
############################################################
############################################################


def o_fitgl():
    try:
        # global pos,fwhm,epos,efwhm,base,k_offset,st,evv,eaa,fexx,feyy,fex,fey,mvv,maa,fmxx,fmyy,fmx,fmy
        global st
        print('fitting')
        st.put('fitting')
        t1 = threading.Thread(target=fitm)
        t2 = threading.Thread(target=fite)
        t1.start()
        t2.start()
        t1.join()
        t2.join()
        print('Done')
        st.put('Done')
    except:
        pass


def clmfit():
    global rpos, pos, fwhm, fev, ophi
    rpos = []
    pos = []
    fwhm = []
    fev = []
    ophi = []


def clefit():
    global fphi, epos, ffphi, efwhm, fk
    fphi = []
    epos = []
    ffphi = []
    efwhm = []
    fk = []


def cminrange(*e):
    if vcmax.get()-vcmin.get() < 1:
        try:
            vcmax.set(vcmin.get())
        except:
            pass
    try:
        h0.set_clim([vcmin.get(), vcmax.get()])
        out.draw()
    except:
        pass


def cmaxrange(*e):
    if vcmax.get()-vcmin.get() < 1:
        try:
            vcmin.set(vcmax.get())
        except:
            pass
    try:
        h0.set_clim([vcmin.get(), vcmax.get()])
        out.draw()
    except:
        pass


def o_fbb_offset(*e):
    global bb_offset
    if '' == bb_offset.get():
        bb_offset.set('0')
        bboffset.select_range(0, 1)
    os.chdir(cdir)
    np.savez('bb', path=bpath, be=be, k=k, bbo=float(bb_offset.get()), bbk=float(bbk_offset.get()))


def fbb_offset(*e):
    t = threading.Thread(target=o_fbb_offset)
    t.daemon = True
    t.start()


def o_fbbk_offset(*e):
    global bbk_offset
    if '' == bbk_offset.get():
        bbk_offset.set('1')
        bbkoffset.select_range(0, 1)
    os.chdir(cdir)
    np.savez('bb', path=bpath, be=be, k=k, bbo=float(bb_offset.get()), bbk=float(bbk_offset.get()))


def fbbk_offset(*e):
    t = threading.Thread(target=o_fbbk_offset)
    t.daemon = True
    t.start()


def o_fbase(*e):
    global base
    if '' == base.get():
        base.set('0')
        in_fit.select_range(0, 1)


def fbase(*e):
    t = threading.Thread(target=o_fbase)
    t.daemon = True
    t.start()


def o_flowlim(*e):
    global lowlim
    if '' == lowlim.get():
        lowlim.set('0')
        in_lowlim.select_range(0, 1)


def flowlim(*e):
    t = threading.Thread(target=o_flowlim)
    t.daemon = True
    t.start()


def o_reload(*e):
    global k_offset, fev, ophi, rpos, pos, ffphi, fwhm, fk, st, kmin, kmax, smresult, smcst, smaa1, smaa2, smfp, smfi, skmin, skmax, epos, efwhm, ffphi, fk, emin, emax, seaa1, seaa2, sefp, sefi, semin, semax
    if '' == k_offset.get():
        k_offset.set('0')
        koffset.select_range(0, 1)
    ophi = np.arcsin(rpos/(2*m*fev*1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
    pos = (2*m*fev*1.602176634*10**-19)**0.5*np.sin((np.float64(k_offset.get())+ophi)/180*np.pi)*10**-10/(h/2/np.pi)
    ophimin = np.arcsin((rpos-fwhm/2)/(2*m*fev*1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
    ophimax = np.arcsin((rpos+fwhm/2)/(2*m*fev*1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
    kmin = (2*m*fev*1.602176634*10**-19)**0.5*np.sin((np.float64(k_offset.get())+ophimin)/180*np.pi)*10**-10/(h/2/np.pi)
    kmax = (2*m*fev*1.602176634*10**-19)**0.5*np.sin((np.float64(k_offset.get())+ophimax)/180*np.pi)*10**-10/(h/2/np.pi)
    # okmphi = np.arcsin(kmin/(2*m*fev*1.602176634*10**-19)**0.5 /
    #                    10**-10*(h/2/np.pi))*180/np.pi
    # kmin = (2*m*fev*1.602176634*10**-19)**0.5 * \
    #     np.sin((np.float64(k_offset.get())+okmphi) /
    #            180*np.pi)*10**-10/(h/2/np.pi)
    # okMphi = np.arcsin(kmax/(2*m*fev*1.602176634*10**-19)**0.5 /
    #                    10**-10*(h/2/np.pi))*180/np.pi
    # kmax = (2*m*fev*1.602176634*10**-19)**0.5 * \
    #     np.sin((np.float64(k_offset.get())+okMphi) /
    #            180*np.pi)*10**-10/(h/2/np.pi)
    os.chdir(cdir)
    try:
        np.savez('mfit', ko=k_offset.get(), fev=fev, rpos=rpos, ophi=ophi, fwhm=fwhm, pos=pos, kmin=kmin,
                 kmax=kmax, skmin=skmin, skmax=skmax, smaa1=smaa1, smaa2=smaa2, smfp=smfp, smfi=smfi)
        np.savez('mfit', ko=k_offset.get(), fev=fev, rpos=rpos, ophi=ophi, fwhm=fwhm, pos=pos, kmin=kmin,
                 kmax=kmax, skmin=skmin, skmax=skmax, smaa1=smaa1, smaa2=smaa2, smfp=smfp, smfi=smfi, smresult=smresult, smcst=smcst)
    except:
        try:
            ffphi = np.float64(k_offset.get())+fphi
            fk = (2*m*epos*1.602176634*10**-19)**0.5 * \
                np.sin(ffphi/180*np.pi)*10**-10/(h/2/np.pi)
            np.savez('efit', ko=k_offset.get(), fphi=fphi, epos=epos, ffphi=ffphi, efwhm=efwhm, fk=fk,
                 emin=emin, emax=emax, semin=semin, semax=semax, seaa1=seaa1, seaa2=seaa2, sefp=sefp, sefi=sefi)
        except:
            pass
        pass

    print('k_offset changed')
    st.put('k_offset changed')


def climon():
    cm.set(h0.get_clim()[0])
    cM.set(h0.get_clim()[1])
    lcmax.config(fg='black')
    lcmin.config(fg='black')
    Cmax.config(from_=cm.get(), to=cM.get(), state='active', fg='black')
    Cmin.config(from_=cm.get(), to=cM.get(), state='active', fg='black')
    vcmin.set(cm.get())
    vcmax.set(cM.get())


def climoff():
    cm.set(-10000)
    cM.set(10000)
    lcmax.config(fg='white')
    lcmin.config(fg='white')
    Cmax.config(from_=cm.get(), to=cM.get(), state='disabled', fg='white')
    Cmin.config(from_=cm.get(), to=cM.get(), state='disabled', fg='white')
    vcmin.set(cm.get())
    vcmax.set(cM.get())


def chcmp(*e):
    norm = mpl.colors.Normalize(vmin=-1, vmax=1)
    a = lcmpd.subplots()
    h = lcmpd.colorbar(mpl.cm.ScalarMappable(
        norm=norm, cmap=value3.get()), cax=a, orientation='vertical', label='')
    h.set_ticks(h.get_ticks())
    h.set_ticklabels(h.get_ticks(), font='Arial')
    cmpg.draw()


def Chcmp(*e):
    global st, f, out, h0, h1, h2, f0
    limg.config(image=img[np.random.randint(len(img))])
    try:
        if value.get() == 'MDC Normalized':
            plot1()
            print('Colormap changed')
            st.put('Colormap changed')
        else:
            h0.set_cmap(value3.get())
            h0.set_clim([vcmin.get(), vcmax.get()])
            try:
                h1.set_cmap(value3.get())
                h1.set_clim([vcmin.get(), vcmax.get()])
                h2.set_cmap(value3.get())
                h2.set_clim([vcmin.get(), vcmax.get()])
                f.canvas.draw_idle()
                f0.canvas.draw_idle()
            except:
                pass
            out.draw()
            print('Colormap changed')
            st.put('Colormap changed')
    except:
        print('Fail to execute')
        st.put('Fail to execute')


def o_exptm():
    global name, pos, fwhm, fev, st
    print('Processing...')
    st.put('Processing...')
    # os.chdir(rdd.removesuffix(rdd.split('/')[-1]))
    os.chdir(os.path.dirname(rdd))
    print('export to ',os.path.dirname(rdd))
    ff = open(name+'_mdc_fitted_data.txt', 'w',
              encoding='utf-8')  # tab 必須使用 '\t' 不可"\t"
    ff.write('K.E. (eV)'+'\t'+'FWHM (k)'+'\t'+'Position (k)'+'\n')
    for i in range(len(fev)):
        ff.write(str(fev[i])+'\t'+str(fwhm[i])+'\t'+str(pos[i])+'\n')
    ff.close()
    print('Done')
    st.put('Done')


def o_expte():
    global name, epos, efwhm, ffphi, st
    print('Processing...')
    st.put('Processing...')
    # os.chdir(rdd.removesuffix(rdd.split('/')[-1]))
    os.chdir(os.path.dirname(rdd))
    print('export to ',os.path.dirname(rdd))
    ff = open(name+'_edc_fitted_data.txt', 'w',
              encoding='utf-8')  # tab 必須使用 '\t' 不可"\t"
    if npzf:ff.write('k (2pi/A)'+'\t'+'FWHM (eV)'+'\t'+'Position (eV)'+'\n')
    else:ff.write('Angle (deg)'+'\t'+'FWHM (eV)'+'\t'+'Position (eV)'+'\n')
    for i in range(len(ffphi)):
        ff.write(str(ffphi[i])+'\t'+str(efwhm[i])+'\t'+str(epos[i])+'\n')
    ff.close()
    print('Done')
    st.put('Done')


def interp(x: float, xp: float, fp: float) -> np.ndarray:
    """
    Interpolates a 1-D function.
    Given the data points (xp, fp), this function returns the interpolated values at the points x.
    If the values in x are outside the range of xp, linear extrapolation is used.
    A more general version of np.interp, which can handle decreasing x-coordinates.
    
    Args
    ----------
        x (float): The x-coordinates at which to evaluate the interpolated values.
        xp (float): The x-coordinates of the data points.
        fp (float): The y-coordinates of the data points.

    Returns
    ----------
        np.ndarray: The interpolated values, same shape as x.
    
    Example
    ----------
        >>> interp(1.5, [1, 2], [2, 3])
        2.5
        >>> interp([1.5, 2.5], [1, 2], [2, 3])
        array([2.5, 3.5])
    """
    if xp[1] >= xp[0]:
        y=np.interp(x,xp,fp)
        try:
            if len(np.array(x))>1:
                for i,v in enumerate(x):
                    if v < xp[0]:
                        y[i]=(v-xp[0])/(xp[1]-xp[0])*(fp[1]-fp[0])+fp[0]
                    elif v > xp[-1]:
                        y[i]=(v-xp[-1])/(xp[-2]-xp[-1])*(fp[-2]-fp[-1])+fp[-1]
        except:
            v=x
            if v < xp[0]:
                y=(v-xp[0])/(xp[1]-xp[0])*(fp[1]-fp[0])+fp[0]
            elif v > xp[-1]:
                y=(v-xp[-1])/(xp[-2]-xp[-1])*(fp[-2]-fp[-1])+fp[-1]
    else:
        xp,fp=xp[::-1],fp[::-1]
        y=np.interp(x,xp,fp)
        try:
            if len(np.array(x))>1:
                for i,v in enumerate(x):
                    if v < xp[0]:
                        y[i]=(v-xp[0])/(xp[1]-xp[0])*(fp[1]-fp[0])+fp[0]
                    elif v > xp[-1]:
                        y[i]=(v-xp[-1])/(xp[-2]-xp[-1])*(fp[-2]-fp[-1])+fp[-1]
        except:
            v=x
            if v < xp[0]:
                y=(v-xp[0])/(xp[1]-xp[0])*(fp[1]-fp[0])+fp[0]
            elif v > xp[-1]:
                y=(v-xp[-1])/(xp[-2]-xp[-1])*(fp[-2]-fp[-1])+fp[-1]
    return y


def o_bareband():
    file = fd.askopenfilename(title="Select TXT file",
                              filetypes=(("TXT files", "*.txt"),))
    # global be,k,rx,ry,ix,iy,limg,img
    global be, k, limg, img, st, bpath
    if len(file) > 0:
        bpath = file
        print('Loading...')
        st.put('Loading...')
        # t_k = []
        # t_ke = []
        # with open(file) as f:
        #     for i, line in enumerate(f):
        #         if i != 0:  # ignore 1st row data (index = 0)
        #             t_k.append(line.split('\t')[0])
        #             t_ke.append(line.split('\t')[1].replace('\n', ''))
        try:
            d=np.loadtxt(file,delimiter='\t',encoding='utf-8',dtype=float,skiprows=1,usecols=(0,1))
        except UnicodeError:
            d=np.loadtxt(file,delimiter='\t',encoding='utf-16',dtype=float,skiprows=1,usecols=(0,1))
        t_k = d[:,0]
        t_ke = d[:,1]
        # [::-1] inverse the order for np.interp (xp values should be increasing)
        be = np.float64(t_ke)*1000
        # [::-1] inverse the order for np.interp (xp values should be increasing)
        k = np.float64(t_k)
        os.chdir(cdir)
        np.savez('bb', path=bpath, be=be, k=k, bbo=float(bb_offset.get()), bbk=float(bbk_offset.get()))
        limg.config(image=img[np.random.randint(len(img))])
        print('Done')
        st.put('Done')
    else:
        limg.config(image=img[np.random.randint(len(img))])
        print('No file selected')
        st.put('No file selected')
        
def im_smooth(data, kernel_size=17):
    return cv2.GaussianBlur(data, (kernel_size, kernel_size), 0)

def laplacian_operation(data):
    return -cv2.Laplacian(data, cv2.CV_64F)

def laplacian_filter(data, kernel_size=17):
    im=im_smooth(data, kernel_size)
    laplacian=laplacian_operation(im)
    return laplacian

def sdgd_filter(data, phi, ev):
    # not used
    
    # 計算數據的梯度
    grad_phi = np.diff(smooth(data))/np.diff(phi)
    grad_ev = np.diff(smooth(data.transpose(),l=40))/np.diff(ev)
    grad_ev = grad_ev.transpose()

    # 計算梯度方向
    # magnitude = np.sqrt(grad_phi**2 + grad_ev**2)
    # direction = np.arctan2(grad_ev, grad_phi)

    # 計算梯度方向上的二階導數
    grad_phi_phi = np.diff(smooth(grad_phi))/np.diff(phi[0:-1])
    grad_ev_ev = np.diff(smooth(grad_ev.transpose(),l=40))/np.diff(ev[0:-1])
    grad_ev_ev = grad_ev_ev.transpose()
    grad_phi_ev = np.diff(smooth(grad_phi.transpose(),l=40))/np.diff(ev)
    grad_phi_ev = grad_phi_ev.transpose()
    a=grad_phi_phi[0:-2,:]*grad_phi[0:-2,0:-1]**2
    b=2*grad_phi_ev[0:-1,0:-1]*grad_phi[0:-2,0:-1]*grad_ev[0:-1,0:-2]
    c=grad_ev_ev[:,0:-2]*grad_ev[0:-1,0:-2]**2
    # 計算 SDGD
    sdgd = -(a + b + c)/(grad_phi[0:-2,0:-1]**2 + grad_ev[0:-1,0:-2]**2)
    # sdgd = grad_phi_phi[0:-2,:]
    # sdgd = -grad_ev_ev[:,0:-2]
    return sdgd

def o_plot1(*e):
    global value, value1, value2, data, ev, phi, mfpath, fig, out, pflag, k_offset, value3, limg, img, optionList, h0, ao, xl, yl, st
    if value.get() in optionList:
        try:
            b_sw.grid_remove()
        except:
            pass
        limg.config(image=img[np.random.randint(len(img))])
        print('Plotting...')
        st.put('Plotting...')
        pflag = 1
        value1.set('---Plot2---')
        value2.set('---Plot3---')
        fig.clear()
        try:
            ev
        except:
            print('Please load Raw Data')
            st.put('Please load Raw Data')
        if value.get() == 'Raw Data':
            rplot(fig, out)
        else:
            if value.get() == 'First Derivative':   #axis: phi
                ao = fig.subplots()
                pz = np.diff(smooth(data.to_numpy()))/np.diff(phi)
                if emf=='KE':
                    px, py = np.meshgrid(phi[0:-1]+np.diff(phi)/2, ev)
                    tev = py.copy()
                else:
                    px, py = np.meshgrid(phi[0:-1]+np.diff(phi)/2, vfe-ev)
                    tev = vfe-py.copy()
                if npzf:
                    px = phi[0:-1]+np.diff(phi)/2
                else:
                    px = (2*m*tev*1.602176634*10**-19)**0.5*np.sin((np.float64(k_offset.get())+px+np.diff(phi)/2)/180*np.pi)*10**-10/(h/2/np.pi)
                h0 = ao.pcolormesh(px, py, pz, cmap=value3.get())
                cb = fig.colorbar(h0)
                cb.set_ticklabels(cb.get_ticks(), font='Arial')
                
            # if value.get() == 'First Derivative':    #axis: eV
            #     ao = fig.subplots()
            #     pz = np.diff(smooth(data.to_numpy().transpose()))/np.diff(ev)
            #     pz = pz.transpose()
            #     if emf=='KE':
            #         px, py = np.meshgrid(phi, ev[0:-1]+np.diff(ev)/2)
            #         tev = py.copy()
            #     else:
            #         px, py = np.meshgrid(phi, vfe-ev[0:-1]-np.diff(ev)/2)
            #         tev = vfe-py.copy()
            #     px = (2*m*tev*1.602176634*10**-19)**0.5*np.sin((np.float64(k_offset.get())+px)/180*np.pi)*10**-10/(h/2/np.pi)
            #     h0 = ao.pcolormesh(px, py, pz, cmap=value3.get())
            #     cb = fig.colorbar(h0)
            #     cb.set_ticklabels(cb.get_ticks(), font='Arial')
            
            elif value.get() == 'Second Derivative':    #axis: phi, eV
                ao = fig.subplots()
                # pz = np.diff(smooth(data.to_numpy()))/np.diff(phi)
                # pz = np.diff(smooth(pz.transpose()))/np.diff(ev)
                # pz = sdgd_filter(data.to_numpy(), phi, ev)
                # if emf=='KE':
                #     px, py = np.meshgrid(phi[0:-2], ev[0:-2])
                # else:
                #     px, py = np.meshgrid(phi[0:-2], vfe-ev[0:-2])
                # px = (2*m*np.full_like(np.zeros([len(phi[0:-2]), len(ev[0:-2])], dtype=float), ev[0:-2]+np.diff(ev[0:-1])/2*2)*1.602176634*10**-19).transpose(
                # )**0.5*np.sin((np.float64(k_offset.get())+px+np.diff(phi[0:-1])/2*2)/180*np.pi)*10**-10/(h/2/np.pi)
                
                pz = laplacian_filter(data.to_numpy(), im_kernel)
                if emf=='KE':
                    px, py = np.meshgrid(phi, ev)
                    tev = py.copy()
                else:
                    px, py = np.meshgrid(phi, vfe-ev)
                    tev = vfe-py.copy()
                if npzf:
                    px = phi
                else:
                    px = (2*m*tev*1.602176634*10**-19)**0.5*np.sin((np.float64(k_offset.get())+px)/180*np.pi)*10**-10/(h/2/np.pi)
                
                h0 = ao.pcolormesh(px, py, pz, cmap=value3.get())
                cb = fig.colorbar(h0)
                cb.set_ticklabels(cb.get_ticks(), font='Arial')
                
            # elif value.get() == 'Second Derivative':    #axis: phi
            #     ao = fig.subplots()
            #     pz = np.diff(smooth(data.to_numpy()))/np.diff(phi)
            #     pz = -np.diff(smooth(pz))/np.diff(phi[0:-1])
                # if emf=='KE':
                #     px, py = np.meshgrid(phi[0:-2], ev)
                # else:
                #     px, py = np.meshgrid(phi[0:-2], vfe-ev)
                # px = (2*m*np.full_like(np.zeros([len(phi[0:-2]), len(ev)], dtype=float), ev)*1.602176634*10**-19).transpose(
                # )**0.5*np.sin((np.float64(k_offset.get())+px+np.diff(phi[0:-1])/2*2)/180*np.pi)*10**-10/(h/2/np.pi)
            #     h0 = ao.pcolormesh(px, py, pz, cmap=value3.get())
            #     cb = fig.colorbar(h0)
            #     cb.set_ticklabels(cb.get_ticks(), font='Arial')
                
            # elif value.get() == 'Second Derivative':    #axis: eV
            #     ao = fig.subplots()
            #     pz = np.diff(smooth(data.to_numpy().transpose()))/np.diff(ev)
            #     pz = -np.diff(smooth(pz))/np.diff(ev[0:-1])
            #     pz = pz.transpose()
                # if emf=='KE':
                #     px, py = np.meshgrid(phi, ev[0:-2])
                # else:
                #     px, py = np.meshgrid(phi, vfe-ev[0:-2])
                # px = (2*m*np.full_like(np.zeros([len(phi), len(ev[0:-2])], dtype=float), ev[0:-2]+np.diff(ev[0:-1])/2*2)*1.602176634*10**-19).transpose(
                # )**0.5*np.sin((np.float64(k_offset.get())+px)/180*np.pi)*10**-10/(h/2/np.pi)
            #     h0 = ao.pcolormesh(px, py, pz, cmap=value3.get())
            #     cb = fig.colorbar(h0)
            #     cb.set_ticklabels(cb.get_ticks(), font='Arial')
                
            else:
                if 'MDC Curves' not in value.get():
                    fig.clear()
                    ao = fig.subplots()
                elif value.get() == 'MDC Curves':
                    fig.clear()
                    ao = fig.add_axes([0.2, 0.13, 0.5, 0.8])
                else:
                    fig.clear()
                    at = fig.add_axes([0.25, 0.13, 0.5, 0.8])
                    at.set_xticks([])
                    at.set_yticks([])
                    ao = fig.add_axes([0.1, 0.13, 0.4, 0.8])
                    ao1 = fig.add_axes([0.5, 0.13, 0.4, 0.8])
                if value.get() == 'E-K Diagram':
                    # h1=a.scatter(mx,my,c=mz,marker='o',s=0.9,cmap=value3.get());
                    if emf=='KE':
                        px, py = np.meshgrid(phi, ev)
                        tev = py.copy()
                    else:
                        px, py = np.meshgrid(phi, vfe-ev)
                        tev = vfe-py.copy()
                    if npzf:
                        px = phi
                    else:
                        px = (2*m*tev*1.602176634*10**-19)**0.5*np.sin((np.float64(k_offset.get())+px)/180*np.pi)*10**-10/(h/2/np.pi)
                    pz = data.to_numpy()
                    h0 = ao.pcolormesh(px, py, pz, cmap=value3.get())
                    cb = fig.colorbar(h0)
                    cb.set_ticklabels(cb.get_ticks(), font='Arial')
                    
                elif value.get() == 'MDC Normalized':
                    pbar = tqdm.tqdm(
                        total=len(ev)-1, desc='MDC Normalized', colour='red')
                    for n in range(len(ev)-1):
                        ecut = data.sel(eV=ev[n], method='nearest')
                        if npzf:
                            x = phi
                        else:
                            x = (2*m*ev[n]*1.602176634*10**-19)**0.5*np.sin(
                            (np.float64(k_offset.get())+phi)/180*np.pi)*10**-10/(h/2/np.pi)
                        y = ecut.to_numpy().reshape(len(ecut))
                        # mz[len(phi)*n:len(phi)*(n+1)]=np.array(y,dtype=float)
                        # mx[len(phi)*n:len(phi)*(n+1)]=x
                        # ty=np.arange(len(x), dtype=float)
                        # my[len(phi)*n:len(phi)*(n+1)]=np.full_like(ty, ev[n])
                        # a.scatter(x,np.full_like(ty, ev[n]),c=np.array(y,dtype=int),marker='o',s=0.9,cmap=value3.get());
                        if emf=='KE':
                            px, py = np.meshgrid(x, ev[n:(n+2)])
                        else:
                            px, py = np.meshgrid(x, vfe-ev[n:(n+2)])
                        ao.pcolormesh(px, py, np.full_like(
                            np.zeros([2, len(phi)], dtype=float), y), cmap=value3.get())
                        pbar.update(1)
                        # print(str(round((n+1)/(len(ev)-1)*100))+'%'+' ('+str(len(ev)-1)+')')
                        st.put(str(round((n+1)/(len(ev)-1)*100)) +
                               '%'+' ('+str(len(ev)-1)+')')
                    pbar.close()
                elif value.get() == 'MDC Curves':
                    pbar = tqdm.tqdm(
                        total=len(ev)//d, desc='MDC', colour='red')
                    y = np.zeros([len(ev),len(phi)],dtype=float)
                    for n in range(len(ev)):
                        ecut = data.sel(eV=ev[n], method='nearest')
                        if npzf:
                            x = phi
                        else:
                            x = (2*m*ev[n]*1.602176634*10**-19)**0.5*np.sin(
                            (np.float64(k_offset.get())+phi)/180*np.pi)*10**-10/(h/2/np.pi)
                        y[n][:] = ecut.to_numpy().reshape(len(ecut))
                    for n in range(len(ev)//d):
                        yy=y[n*d][:]+n*np.max(y)/d
                        yy=smooth(yy,l,p)
                        ao.plot(x, yy, c='black')
                        pbar.update(1)
                        # print(str(round((n+1)/(len(ev))*100))+'%'+' ('+str(len(ev))+')')
                        st.put(str(round((n+1)/(len(ev)//d)*100)) +
                               '%'+' ('+str(len(ev)//d)+')')
                    pbar.close()
                elif value.get() == 'E-K with MDC Curves':
                    pbar = tqdm.tqdm(
                        total=len(ev)//d, desc='MDC', colour='red')
                    y = np.zeros([len(ev),len(phi)],dtype=float)
                    for n in range(len(ev)):
                        ecut = data.sel(eV=ev[n], method='nearest')
                        if npzf:
                            x = phi
                        else:
                            x = (2*m*ev[n]*1.602176634*10**-19)**0.5*np.sin(
                            (np.float64(k_offset.get())+phi)/180*np.pi)*10**-10/(h/2/np.pi)
                        y[n][:] = ecut.to_numpy().reshape(len(ecut))
                    for n in range(len(ev)//d):
                        yy=y[n*d][:]+n*np.max(y)/d
                        yy=smooth(yy,l,p)
                        ao1.plot(x, yy, c='black')
                        pbar.update(1)
                        # print(str(round((n+1)/(len(ev))*100))+'%'+' ('+str(len(ev))+')')
                        st.put(str(round((n+1)/(len(ev)//d)*100)) +
                               '%'+' ('+str(len(ev)//d)+')')
                    pbar.close()
                    if emf=='KE':
                        px, py = np.meshgrid(phi, ev)
                        tev = py.copy()
                    else:
                        px, py = np.meshgrid(phi, vfe-ev)
                        tev = vfe-py.copy()
                    if npzf:
                        px = phi
                    else:
                        px = (2*m*tev*1.602176634*10**-19)**0.5*np.sin((np.float64(k_offset.get())+px)/180*np.pi)*10**-10/(h/2/np.pi)
                    pz = data.to_numpy()
                    h0 = ao.pcolormesh(px, py, pz, cmap=value3.get())
                    ylb=ao1.twinx()
                    ylb.set_ylabel('Intensity (a.u.)', font='Arial', fontsize=14)
                    ylb.set_yticklabels([])
                    # cb = fig.colorbar(h0, ax=ao1)
                    # cb.set_ticklabels(cb.get_ticks(), font='Arial')
            if 'E-K with' not in value.get():
                ao.set_title(value.get(), font='Arial', fontsize=16)
            else:
                at.set_title(value.get(), font='Arial', fontsize=16)
            ao.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=14)
            if 'MDC Curves' not in value.get():
                if emf=='KE':
                    ao.set_ylabel('Kinetic Energy (eV)', font='Arial', fontsize=14)
                else:
                    ao.set_ylabel('Binding Energy (eV)', font='Arial', fontsize=14)
                    ao.invert_yaxis()
            else:
                if 'E-K with' in value.get():
                    if emf=='KE':
                        ao.set_ylabel('Kinetic Energy (eV)', font='Arial', fontsize=14)
                        ao.set_ylim([ev[0], ev[n*d]])
                    else:
                        ao.set_ylabel('Binding Energy (eV)', font='Arial', fontsize=14)
                        ao.invert_yaxis()
                        ao.set_ylim([vfe-ev[0], vfe-ev[n*d]])
                    ao1.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=14)
                    ao1.set_yticklabels([])
                    ao1.set_xlim([min(x), max(x)])
                    ao1.set_ylim([0, np.max(n*np.max(y)/d)])
                else:
                    ylr=ao.twinx()
                    ao.set_yticklabels([])
                    ao.set_ylabel('Intensity (a.u.)', font='Arial', fontsize=14)
                    ylr.set_ylabel(r'$\longleftarrow$ Binding Energy', font='Arial', fontsize=14)
                    ylr.set_yticklabels([])
                    ao.set_xlim([min(x), max(x)])
                    ao.set_ylim([0, np.max(n*np.max(y)/d)])
                
            xl = ao.get_xlim()
            yl = ao.get_ylim()
        try:
            if value.get() != 'MDC Normalized' and value.get() != 'MDC Curves':
                climon()
                out.draw()
            else:
                climoff()
                out.draw()
        except:
            pass
        print('Done')
        st.put('Done')


def o_plot2(*e):
    global fig, out, fwhm, fev, pos, value, value1, value2, k, be, rx, ry, ix, iy, pflag, limg, img, bb_offset, bbk_offset, optionList1, st
    if value1.get() in optionList1:
        try:
            b_sw.grid_remove()
        except:
            pass
        limg.config(image=img[np.random.randint(len(img))])
        print('Plotting...')
        st.put('Plotting...')
        pflag = 2
        value.set('---Plot1---')
        value2.set('---Plot3---')
        fig.clear()
        climoff()
        if value1.get() == 'MDC fitted Data':
            try:
                x = (vfe-fev)*1000
                # y = (fwhm*6.626*10**-34/2/3.1415926/(10**-10))**2/2/(9.11*10**-31)/(1.602176634*10**-19)*1000
            except:
                print(r'Please Load MDC fitted file')
                st.put(r'Please Load MDC fitted file')
            try:
                a = fig.subplots(2, 1)
                a[0].set_title('MDC Fitting Result', font='Arial', fontsize=18)
                a[0].set_xlabel('Binding Energy (meV)',
                                font='Arial', fontsize=14)
                a[0].set_ylabel(
                    r'Position ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=14)
                a[0].tick_params(direction='in')
                a[0].scatter(x, pos, c='black', s=5)

                a[1].set_xlabel('Binding Energy (meV)',
                                font='Arial', fontsize=14)
                a[1].set_ylabel(
                    r'FWHM ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=14)
                a[1].tick_params(direction='in')
                a[1].scatter(x, fwhm, c='black', s=5)
                
                a[0].invert_xaxis()
                a[1].invert_xaxis()
            except:
                print('Please load MDC fitted file')
                st.put('Please load MDC fitted file')
        elif value1.get() == 'EDC fitted Data':
            try:
                x = fk
            except:
                print(r'Please Load EDC fitted file')
                st.put(r'Please Load EDC fitted file')
            try:
                a = fig.subplots(2, 1)
                a[0].set_title('EDC Fitting Result', font='Arial', fontsize=18)
                a[0].set_xlabel(
                    r'Position ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=14)
                a[0].set_ylabel('Binding Energy (meV)',
                                font='Arial', fontsize=14)
                a[0].tick_params(direction='in')
                a[0].scatter(x, (vfe-epos)*1000, c='black', s=5)

                a[1].set_xlabel(
                    r'Position ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=14)
                a[1].set_ylabel('FWHM (meV)', font='Arial', fontsize=14)
                a[1].tick_params(direction='in')
                a[1].scatter(x, efwhm*1000, c='black', s=5)
                
                a[0].invert_yaxis()
            except:
                print('Please load EDC fitted file')
                st.put('Please load EDC fitted file')
        elif value1.get() == 'Real Part':
            try:
                x = (vfe-fev)*1000
                y = pos
            except:
                print('Please load MDC fitted file')
                st.put('Please load MDC fitted file')
            try:
                yy = interp(y, k*np.float64(bbk_offset.get()), be -
                            # interp x into be,k set
                            np.float64(bb_offset.get()))
            except:
                print('Please load Bare Band file')
                st.put('Please load Bare Band file')
            a = fig.subplots(2, 1)
            a[0].set_title('Real Part', font='Arial', fontsize=18)
            a[0].plot(x, -(x+yy), c='black', linestyle='-', marker='.')

            rx = x
            ry = -(x+yy)
            a[0].tick_params(direction='in')
            a[0].set_xlabel('Binding Energy (meV)', font='Arial', fontsize=14)
            a[0].set_ylabel(r'Re $\Sigma$ (meV)', font='Arial', fontsize=14)

            h1 = a[1].scatter(y, x, c='black', s=5)
            h2 = a[1].scatter(k*np.float64(bbk_offset.get()),
                              -be+np.float64(bb_offset.get()), c='red', s=5)

            a[1].legend([h1, h2], ['fitted data', 'bare band'])
            a[1].tick_params(direction='in')
            a[1].set_ylabel('Binding Energy (meV)', font='Arial', fontsize=14)
            a[1].set_xlabel(
                r'Pos ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=14)
            
            a[0].invert_xaxis()
            a[1].invert_yaxis()

            # a[0].set_xlim([-1000,50])
            # a[0].set_ylim([-100,500])
            # a[1].set_ylim([-600,200])
            # a[1].set_xlim([-0.05,0.05])
        elif value1.get() == 'Imaginary Part':
            try:
                tbe = (vfe-fev)*1000
            except:
                print(r'Please Load MDC fitted file')
                st.put(r'Please Load MDC fitted file')
            try:
                x = interp(tbe, -be+np.float64(bb_offset.get()),
                           k*np.float64(bbk_offset.get()))
                y = interp(x, k*np.float64(bbk_offset.get()),
                           -be+np.float64(bb_offset.get()))
            except:
                print('Please load Bare Band file')
                st.put('Please load Bare Band file')
            xx = np.diff(x)
            yy = np.diff(y)

            # eliminate vf in gap
            for i in range(len(yy)):
                if yy[i]/xx[i] > 20000:
                    yy[i] = 0
            v = yy/xx
            # v = np.append(v, v[-1])  # fermi velocity
            try:
                v=interp(pos,x[0:-1]+xx/2,v)
                yy = np.abs(v*fwhm/2)
            except:
                print('Please load MDC fitted file')
                st.put('Please load MDC fitted file')
            xx = tbe
            ax = fig.subplots(2, 1)
            a = ax[0]
            b = ax[1]
            a.set_title('Imaginary Part', font='Arial', fontsize=18)
            a.plot(xx, yy, c='black', linestyle='-', marker='.')

            ix = xx
            iy = yy
            a.tick_params(direction='in')
            a.set_xlabel('Binding Energy (eV)', font='Arial', fontsize=14)
            a.set_ylabel(r'Im $\Sigma$ (meV)', font='Arial', fontsize=14)

            x = (vfe-fev)*1000
            y = fwhm
            b.plot(x, y, c='black', linestyle='-', marker='.')
            b.tick_params(direction='in')
            b.set_xlabel('Binding Energy (eV)', font='Arial', fontsize=14)
            b.set_ylabel(r'FWHM ($\frac{2\pi}{\AA}$)',
                         font='Arial', fontsize=14)
            
            a.invert_xaxis()
            b.invert_xaxis()
        out.draw()
        print('Done')
        st.put('Done')


def o_plot3(*e):
    global fig, out, rx, ry, ix, iy, fwhm, pos, value, value1, value2, pflag, k, be, k_offset, value3, limg, img, bb_offset, bbk_offset, optionList2, h0, bo, xl, yl, posmin, posmax, eposmin, eposmax, tb0, tb0_, tb1, tb1_, tb2, st, dl, b_sw
    if value2.get() in optionList2:
        limg.config(image=img[np.random.randint(len(img))])
        print('Plotting...')
        st.put('Plotting...')
        pflag = 3
        value.set('---Plot1---')
        value1.set('---Plot2---')
        fig.clear()
        ophi = np.arcsin(rpos/(2*m*fev*1.602176634*10**-19)**0.5 /
                        10**-10*(h/2/np.pi))*180/np.pi
        pos = (2*m*fev*1.602176634*10**-19)**0.5 * \
            np.sin((np.float64(k_offset.get())+ophi)/180*np.pi)*10**-10/(h/2/np.pi)
        try:
            x = (vfe-fev)*1000
            y = pos
        except:
            print('Please load MDC fitted file')
            st.put('Please load MDC fitted file')
        if 'Data Plot with Pos' in value2.get():
            try:
                b_sw.grid_remove()
            except:
                pass
        else:
            try:
                b_sw.grid(row=0, column=3)
            except:
                pass    
        if value2.get() != 'Data Plot with Pos':
            try:
                yy = interp(y, k*np.float64(bbk_offset.get()), be -
                            # interp x into be,k set
                            np.float64(bb_offset.get()))
                rx = x
                ry = -(x+yy)
                tbe = (vfe-fev)*1000
                x = interp(tbe, -be+np.float64(bb_offset.get()),
                           k*np.float64(bbk_offset.get()))
                y = interp(x, k*np.float64(bbk_offset.get()),
                           -be+np.float64(bb_offset.get()))
                xx = np.diff(x)
                yy = np.diff(y)

                # eliminate vf in gap
                for i in range(len(yy)):
                    if yy[i]/xx[i] > 20000:
                        yy[i] = 0
                v = yy/xx
                # v = np.append(v, v[-1])  # fermi velocity
                v=interp(pos,x[0:-1]+xx/2,v)
                yy = np.abs(v*fwhm/2)
                xx = tbe
                ix = xx
                iy = yy
            except:
                print('Please load Bare Band file')
                st.put('Please load Bare Band file')
        if value2.get() == 'Real & Imaginary':
            a = fig.subplots(2, 1)
            a[0].set_title(r'Self Energy $\Sigma$', font='Arial', fontsize=18)
            if dl==0:
                a[0].scatter(rx, ry, edgecolors='black', c='w')
            elif dl==1:
                a[0].plot(rx, ry, c='black')
            elif dl==2:
                a[0].plot(rx, ry, c='black', linestyle='-', marker='.')
            a[0].tick_params(direction='in')
            a[0].set_xlabel('Binding Energy (meV)', font='Arial', fontsize=14)
            a[0].set_ylabel(r'Re $\Sigma$ (meV)', font='Arial', fontsize=14)
            if dl==0:
                a[1].scatter(ix, iy, edgecolors='black', c='w')
            elif dl==1:
                a[1].plot(ix, iy, c='black')
            elif dl==2:
                a[1].plot(ix, iy, c='black', linestyle='-', marker='.')
            a[1].tick_params(direction='in')
            a[1].set_xlabel('Binding Energy (meV)', font='Arial', fontsize=14)
            a[1].set_ylabel(r'Im $\Sigma$ (meV)', font='Arial', fontsize=14)
            a[0].invert_xaxis()
            a[1].invert_xaxis()
        elif 'KK Transform' in value2.get():
            ################################################################################## Hilbert Transform
            ##################################################################################
            tbe = (vfe-fev)*1000
            ###################################################插入KK缺失值 棄用
            # de = np.diff(tbe)
            # de = np.append(de, de[-1])
            # rm=mode(de)
            # rm=rm.mode
            # otbe=tbe
            # for i,v in enumerate(de):
            #     if abs(v-rm)>abs(rm/2):
            #         print(v,rm)
            #         ap_tbe = tbe[i]+rm
            #         de = np.append(de[0:i+1],np.append([rm],de[i+1::]))
            #         tbe = np.append(tbe[0:i+1],np.append([interp(ap_tbe,otbe,otbe)],tbe[i+1::]))
            #         ry = np.append(ry[0:i+1],np.append([interp(ap_tbe,otbe,ry)],ry[i+1::]))
            #         iy = np.append(iy[0:i+1],np.append([interp(ap_tbe,otbe,iy)],iy[i+1::]))
            ###################################################插入KK缺失值 棄用
            
            ix=(tbe-tbe[-1])*-1
            cix=np.append(ix+ix[0],ix)
            tix=cix[0:len(cix)-1]*-1
            # kx=ix
            kx = np.append(cix,tix[::-1])
            ky = np.linspace(0, 1, len(kx))
            ciy=np.append(iy*0+np.mean(iy),iy)
            tiy=ciy[0:len(ciy)-1]
            ciy = np.append(ciy,tiy[::-1])

            #for imaginary part
            ix=(tbe-tbe[-1])*-1
            cix=np.append(ix+ix[0],ix)
            tix=cix[0:len(cix)-1]*-1
            kx = np.append(cix,tix[::-1])
            ky = np.linspace(0, 1, len(kx))
            cry=np.append(ry*0,ry)
            tcry=cry[0:len(cry)-1]*-1
            cry = np.append(cry,tcry[::-1])

            # Hilbert transform
            analytic_signal_r = hilbert(cry)
            amplitude_envelope_r = np.abs(analytic_signal_r)
            instantaneous_phase_r = np.unwrap(np.angle(analytic_signal_r))
            instantaneous_frequency_r = np.diff(instantaneous_phase_r) / (2.0 * np.pi)

            analytic_signal_i = hilbert(ciy)
            amplitude_envelope_i = np.abs(analytic_signal_i)
            instantaneous_phase_i = np.unwrap(np.angle(analytic_signal_i))
            instantaneous_frequency_i = np.diff(instantaneous_phase_i) / (2.0 * np.pi)

            # Reconstructed real and imaginary parts
            reconstructed_real = np.imag(analytic_signal_i)
            reconstructed_imag = -np.imag(analytic_signal_r)
            ################################################################################## # Export data points as txt files
            ##################################################################################
            
            # np.savetxt('re_sigma.txt', np.column_stack((tbe, ry)), delimiter='\t', header='Binding Energy (meV)\tRe Sigma (meV)', comments='')
            # np.savetxt('kk_re_sigma.txt', np.column_stack((tbe, reconstructed_real[len(ix):2*len(ix)])), delimiter='\t', header='Binding Energy (meV)\tRe Sigma KK (meV)', comments='')
            # np.savetxt('im_sigma.txt', np.column_stack((tbe, iy)), delimiter='\t', header='Binding Energy (meV)\tIm Sigma (meV)', comments='')
            # np.savetxt('kk_im_sigma.txt', np.column_stack((tbe, reconstructed_imag[len(ix):2*len(ix)])), delimiter='\t', header='Binding Energy (meV)\tIm Sigma KK (meV)', comments='')
            
            ##################################################################################
            ################################################################################## # Export data points as txt files
                # Plot
            if 'Real Part' not in value2.get() and 'Imaginary Part' not in value2.get():
                ax = fig.subplots(2, 1)
                a = ax[0]
                b = ax[1]
                # Plot imaginary data and its Hilbert transformation
                a.set_title(r'Self Energy $\Sigma$', font='Arial', fontsize=18)
                if dl==0:
                    a.scatter(tbe, ry, edgecolors='black', c='w', label=r'Re $\Sigma$')
                    a.scatter(tbe, reconstructed_real[len(ix):2*len(ix)]+(ry-np.mean(reconstructed_real[len(ix):2*len(ix)])), edgecolors='red', c='w', label=r'Re $\Sigma_{KK}$=KK(Im $\Sigma$)')
                elif dl==1:
                    a.plot(tbe, ry, c='black', label=r'Re $\Sigma$')
                    a.plot(tbe, reconstructed_real[len(ix):2*len(ix)]+(ry-np.mean(reconstructed_real[len(ix):2*len(ix)])), c='red', label=r'Re $\Sigma_{KK}$=KK(Im $\Sigma$)')
                elif dl==2:
                    a.plot(tbe, ry, c='black', linestyle='-', marker='.', label=r'Re $\Sigma$')
                    a.plot(tbe, reconstructed_real[len(ix):2*len(ix)]+(ry-np.mean(reconstructed_real[len(ix):2*len(ix)])), c='red', linestyle='-', marker='.', label=r'Re $\Sigma_{KK}$=KK(Im $\Sigma$)')
                a.set_xlabel('Binding Energy (eV)', font='Arial', fontsize=14)
                a.set_ylabel(r'Re $\Sigma$ (meV)', font='Arial', fontsize=14)
                a.legend()
                if dl==0:
                    b.scatter(tbe, iy, edgecolors='black', c='w', label=r'Im $\Sigma$')
                    b.scatter(tbe, reconstructed_imag[len(ix):2*len(ix)]+(iy-np.mean(reconstructed_imag[len(ix):2*len(ix)])), edgecolors='red', c='w', label=r'Im $\Sigma_{KK}$=KK(Re $\Sigma$)')
                elif dl==1:
                    b.plot(tbe, iy, c='black', label=r'Im $\Sigma$')
                    b.plot(tbe, reconstructed_imag[len(ix):2*len(ix)]+(iy-np.mean(reconstructed_imag[len(ix):2*len(ix)])), c='red', label=r'Im $\Sigma_{KK}$=KK(Re $\Sigma$)')
                elif dl==2:
                    b.plot(tbe, iy, c='black', linestyle='-', marker='.', label=r'Im $\Sigma$')
                    b.plot(tbe, reconstructed_imag[len(ix):2*len(ix)]+(iy-np.mean(reconstructed_imag[len(ix):2*len(ix)])), c='red', linestyle='-', marker='.', label=r'Im $\Sigma_{KK}$=KK(Re $\Sigma$)')
                b.set_xlabel('Binding Energy (meV)', font='Arial', fontsize=14)
                b.set_ylabel(r'Im $\Sigma$ (meV)', font='Arial', fontsize=14)
                b.legend()
                a.invert_xaxis()
                b.invert_xaxis()
            elif 'Real Part' in value2.get():
                ax = fig.subplots()
                ttbe=tbe/1000
                if 'nd' in value2.get():
                    ax.set_title(r'Self Energy $\Sigma$ Real Part', font='Arial', fontsize=20)
                    ty=np.diff(smooth(ry,20,3))/np.diff(ttbe)
                    np.save(name+'_re_sigma.npy', np.column_stack((ttbe[0:-1], ty)))
                    if dl==0:
                        ax.scatter(ttbe[0:-1], ty, edgecolors='black', c='w', label=r'Re $\Sigma$')
                    elif dl==1:
                        ax.plot(ttbe[0:-1], ty, c='black', label=r'Re $\Sigma$')
                    elif dl==2:
                        ax.plot(ttbe[0:-1], ty, c='black', linestyle='-', marker='.', label=r'Re $\Sigma$')
                    ax.set_xlabel('Binding Energy (eV)', font='Arial', fontsize=18)
                    ax.set_ylabel(r'$2^{nd} der. Re \Sigma$', font='Arial', fontsize=18)
                    ax.set_xticklabels(ax.get_xticklabels(),fontsize=16)
                    ax.set_yticks([0])
                    ax.set_yticklabels(ax.get_yticklabels(),fontsize=16)
                else:
                    ax.set_title(r'Self Energy $\Sigma$ Real Part', font='Arial', fontsize=20)
                    if dl==0:
                        ax.scatter(ttbe, ry, edgecolors='black', c='w', label=r'Re $\Sigma$')
                        ax.scatter(ttbe, reconstructed_real[len(ix):2*len(ix)]+(ry-np.mean(reconstructed_real[len(ix):2*len(ix)])), edgecolors='red', c='w', label=r'Re $\Sigma_{KK}$=KK(Im $\Sigma$)')
                    elif dl==1:
                        ax.plot(ttbe, ry, c='black', label=r'Re $\Sigma$')
                        ax.plot(ttbe, reconstructed_real[len(ix):2*len(ix)]+(ry-np.mean(reconstructed_real[len(ix):2*len(ix)])), c='red', label=r'Re $\Sigma_{KK}$=KK(Im $\Sigma$)')
                    elif dl==2:
                        ax.plot(ttbe, ry, c='black', linestyle='-', marker='.', label=r'Re $\Sigma$')
                        ax.plot(ttbe, reconstructed_real[len(ix):2*len(ix)]+(ry-np.mean(reconstructed_real[len(ix):2*len(ix)])), c='red', linestyle='-', marker='.', label=r'Re $\Sigma_{KK}$=KK(Im $\Sigma$)')
                    ax.set_xlabel('Binding Energy (eV)', font='Arial', fontsize=18)
                    ax.set_ylabel(r'Re $\Sigma$ (meV)', font='Arial', fontsize=18)
                    ax.set_xticklabels(ax.get_xticklabels(),fontsize=16)
                    ax.set_yticklabels(ax.get_yticklabels(),fontsize=16)
                    l=ax.legend(fontsize=16)
                    l.draw_frame(False)
                ax.invert_xaxis()
            elif 'Imaginary Part' in value2.get():
                ax = fig.subplots()
                ttbe=tbe/1000
                if 'st' in value2.get():
                    ax.set_title(r'Self Energy $\Sigma$ Imaginary Part', font='Arial', fontsize=20)
                    ty=np.diff(smooth(iy,20,3))/np.diff(ttbe)
                    np.save(name+'_im_sigma.npy', np.column_stack((ttbe[0:-1], ty)))
                    if dl==0:
                        ax.scatter(ttbe[0:-1], ty, edgecolors='black', c='w', label=r'Im $\Sigma$')
                    elif dl==1:
                        ax.plot(ttbe[0:-1], ty, c='black', label=r'Im $\Sigma$')
                    elif dl==2:
                        ax.plot(ttbe[0:-1], ty, c='black', linestyle='-', marker='.', label=r'Im $\Sigma$')
                    ax.set_xlabel('Binding Energy (eV)', font='Arial', fontsize=18)
                    ax.set_ylabel(r'$1^{st} der. Im \Sigma$', font='Arial', fontsize=18)
                    ax.set_xticklabels(ax.get_xticklabels(),fontsize=16)
                    ax.set_yticks([0])
                    ax.set_yticklabels(ax.get_yticklabels(),fontsize=16)
                else:
                    ax.set_title(r'Self Energy $\Sigma$ Imaginary Part', font='Arial', fontsize=20)
                    if dl==0:
                        ax.scatter(ttbe, iy, edgecolors='black', c='w', label=r'Im $\Sigma$')
                        ax.scatter(ttbe, reconstructed_imag[len(ix):2*len(ix)]+(iy-np.mean(reconstructed_imag[len(ix):2*len(ix)])), edgecolors='red', c='w', label=r'Im $\Sigma_{KK}$=KK(Re $\Sigma$)')
                    elif dl==1:
                        ax.plot(ttbe, iy, c='black', label=r'Im $\Sigma$')
                        ax.plot(ttbe, reconstructed_imag[len(ix):2*len(ix)]+(iy-np.mean(reconstructed_imag[len(ix):2*len(ix)])), c='red', label=r'Im $\Sigma_{KK}$=KK(Re $\Sigma$)')
                    elif dl==2:
                        ax.plot(ttbe, iy, c='black', linestyle='-', marker='.', label=r'Im $\Sigma$')
                        ax.plot(ttbe, reconstructed_imag[len(ix):2*len(ix)]+(iy-np.mean(reconstructed_imag[len(ix):2*len(ix)])), c='red', linestyle='-', marker='.', label=r'Im $\Sigma_{KK}$=KK(Re $\Sigma$)')
                    ax.set_xlabel('Binding Energy (eV)', font='Arial', fontsize=18)
                    ax.set_ylabel(r'Im $\Sigma$ (meV)', font='Arial', fontsize=18)
                    ax.set_xticklabels(ax.get_xticklabels(),fontsize=16)
                    ax.set_yticklabels(ax.get_yticklabels(),fontsize=16)
                    l=ax.legend(fontsize=16)
                    l.draw_frame(False)
                ax.invert_xaxis()
            ##################################################################################
            ################################################################################## Hilbert Transform
            
            
            
            ################################################################################## KK definition
            ##################################################################################
            # ax = fig.subplots(2, 1)
            # a = ax[0]
            # b = ax[1]
            # a.set_title('Self Energy', font='Arial', fontsize=18)
            # a.plot(rx, ry, c='black', linestyle='-',
            #        marker='.', label=r'Re $\Sigma$')
            # a.tick_params(direction='in')
            # a.set_xlabel('Binding Energy (eV)', font='Arial', fontsize=14)
            # a.set_ylabel(r'Re $\Sigma$ (meV)', font='Arial', fontsize=14)

            
            # ix=(tbe-tbe[-1])*-1
            # cix=np.append(ix+ix[0],ix)
            # tix=cix[0:len(cix)-1]*-1
            # # kx=ix
            # kx = np.append(cix,tix[::-1])
            # ky = np.linspace(0, 1, len(kx))
            # ciy=np.append(iy*0,iy)
            # tiy=ciy[0:len(ciy)-1]
            # ciy = np.append(ciy,tiy[::-1])
            # # de=np.linspace(0,1,len(kx))
            # # de[0:-1]=np.diff(kx)
            # # de[-1]=de[-2]
            # de = np.diff(kx)
            # de = np.append(de, de[-1])

            # for i in range(len(kx)):
            #     # ky[i]=np.trapz(y=iy/(iy-kx[i]),x=iy,dx=de)
            #     intg = 0
            #     for j in range(len(kx)):
            #         if i != j:
            #             tval = ciy[j]/(kx[j]-kx[i])*de[j]
            #             if str(ciy[j]) == 'nan':
            #                 tval = 0
            #             intg += tval
            #     ky[i] = -1/np.pi*intg/2
            # a.plot(tbe, ky[len(ix):2*len(ix)], c='red', linestyle='-', marker='.', label=r'Re $\Sigma_{KK}$=KK(Im $\Sigma$)')
            # # a.plot(tbe, ky, c='red', linestyle='-', marker='.', label=r'Re $\Sigma_{KK}$=KK(Im $\Sigma$)')
            # handles, labels = a.get_legend_handles_labels()
            # a.legend(handles, labels)
            # # a.legend([h1,h2],['measured data','KK transform'])

            # #   KK Re
            # b.plot(tbe, ciy[len(ix):2*len(ix)], c='black', linestyle='-', marker='.', label=r'Im $\Sigma$')
            # # b.plot(tbe, iy, c='black', linestyle='-', marker='.', label=r'Im $\Sigma$')
            # b.tick_params(direction='in')
            # b.set_xlabel('Binding Energy (meV)', font='Arial', fontsize=14)
            # b.set_ylabel(r'Im $\Sigma$ (meV)', font='Arial', fontsize=14)
            
            
            # ix=(tbe-tbe[-1])*-1
            # cix=np.append(ix+ix[0],ix)
            # tix=cix[0:len(cix)-1]*-1
            # kx = np.append(cix,tix[::-1])
            # ky = np.linspace(0, 1, len(kx))
            # ciy=np.append(ry*0,ry)
            # tiy=ciy[0:len(ciy)-1]*-1
            # ciy = np.append(ciy,tiy[::-1])
            
            # # kx = rx
            # ky = np.linspace(0, 1, len(kx))
            # # de=np.linspace(0,1,len(kx))
            # # de[0:-1]=np.diff(kx)
            # # de[-1]=de[-2]
            # de = np.diff(kx)
            # de = np.append(de, de[-1])

            # for i in range(len(kx)):
            #     # ky[i]=np.trapz(y=iy/(iy-kx[i]),x=iy,dx=de)
            #     intg = 0
            #     for j in range(len(kx)):
            #         if i != j:
            #             tval = ciy[j]/(kx[j]-kx[i])*de[j]
            #             if str(ciy[j]) == 'nan':
            #                 tval = 0
            #             intg += tval
            #     ky[i] = 1/np.pi*intg
            # b.plot(tbe, ky[len(ix):2*len(ix)], c='red', linestyle='-', marker='.',
            #        label=r'Im $\Sigma_{KK}$=KK(Re $\Sigma$)')
            # handles, labels = b.get_legend_handles_labels()
            # b.legend(handles, labels)
            # a.invert_xaxis()
            # b.invert_xaxis()
            
            
            ##################################################################################
            ################################################################################## KK definition
            
            
        elif value2.get() == 'Data Plot with Pos' or value2.get() == 'Data Plot with Pos and Bare Band':
            bo = fig.subplots()
            if emf=='KE':
                px, py = np.meshgrid(phi, ev)
                tev = py.copy()
            else:
                px, py =np.meshgrid(phi, vfe-ev)
                tev = vfe-py.copy()
            if npzf:
                px = phi
            else:
                px = (2*m*tev*1.602176634*10**-19)**0.5*np.sin((np.float64(k_offset.get())+px)/180*np.pi)*10**-10/(h/2/np.pi)
            pz = data.to_numpy()
            h0 = bo.pcolormesh(px, py, pz, cmap=value3.get())
            txl = bo.get_xlim()
            tyl = bo.get_ylim()
            cb = fig.colorbar(h0)
            # cb.set_ticklabels(cb.get_ticks(), font='Arial', fontsize=14, minor=False)
            cb.set_ticklabels(cb.get_ticks(), font='Arial')
            
            #   MDC Norm
            # for i in range(len(ev)):
            #     b.scatter(mx[len(phi)*i:len(phi)*(i+1)],my[len(phi)*i:len(phi)*(i+1)],c=mz[len(phi)*i:len(phi)*(i+1)],marker='o',s=0.9,cmap='viridis',alpha=0.3)
            # a.set_title('MDC Normalized')
            bo.set_title(value2.get(), font='Arial', fontsize=18)
            # a.set_xlabel(r'k ($\frac{2\pi}{\AA}$)',fontsize=14)
            # a.set_ylabel('Kinetic Energy (eV)',fontsize=14)
            bo.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=16)
            if emf=='KE':
                bo.set_ylabel('Kinetic Energy (eV)', font='Arial', fontsize=16)
            else:
                bo.set_ylabel('Binding Energy (eV)', font='Arial', fontsize=16)
            # b.set_xticklabels(labels=b.get_xticklabels(),fontsize=14)
            # b.set_yticklabels(labels=b.get_yticklabels(),fontsize=14)
            try:
                if mp == 1:
                    if emf=='KE':
                        tb0 = bo.scatter(pos, fev, marker='.', s=0.3, c='black')
                    else:
                        tb0 = bo.scatter(pos, vfe-fev, marker='.', s=0.3, c='black')
                if mf == 1:
                    ophimin = np.arcsin(
                        (rpos-fwhm/2)/(2*m*fev*1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
                    ophimax = np.arcsin(
                        (rpos+fwhm/2)/(2*m*fev*1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
                    posmin = (2*m*fev*1.602176634*10**-19)**0.5*np.sin(
                        (np.float64(k_offset.get())+ophimin)/180*np.pi)*10**-10/(h/2/np.pi)
                    posmax = (2*m*fev*1.602176634*10**-19)**0.5*np.sin(
                        (np.float64(k_offset.get())+ophimax)/180*np.pi)*10**-10/(h/2/np.pi)
                    if emf=='KE':
                        tb0_ = bo.scatter([posmin, posmax], [
                                        fev, fev], marker='|', c='grey', s=10, alpha=0.8)
                    else:
                        tb0_ = bo.scatter([posmin, posmax], [vfe-fev, vfe-fev], marker='|', c='grey', s=10, alpha=0.8)    
            except:
                pass
            try:
                if ep == 1:
                    if emf=='KE':
                        tb1 = bo.scatter(fk, epos, marker='.', s=0.3, c='black')
                    else:
                        tb1 = bo.scatter(fk, vfe-epos, marker='.', s=0.3, c='black')
                if ef == 1:
                    eposmin = epos-efwhm/2
                    eposmax = epos+efwhm/2
                    if emf=='KE':
                        tb1_ = bo.scatter(
                            [fk, fk], [eposmin, eposmax], marker='_', c='grey', s=10, alpha=0.8)
                    else:
                        tb1_ = bo.scatter(
                            [fk, fk], [vfe-eposmin, vfe-eposmax], marker='_', c='grey', s=10, alpha=0.8)
                    
            except:
                pass
            try:
                if value2.get() == 'Data Plot with Pos and Bare Band':
                    if emf=='KE':
                        tb2, = bo.plot(k*np.float64(bbk_offset.get()), (be -
                                    np.float64(bb_offset.get()))/1000+vfe, linewidth=0.3, c='red', linestyle='--')
                    else:
                        tb2, = bo.plot(k*np.float64(bbk_offset.get()), (-be +
                                np.float64(bb_offset.get()))/1000, linewidth=0.3, c='red', linestyle='--')
                    bo.set_xlim(txl)
                    bo.set_ylim(tyl)
            except:
                bo.set_title('Data Plot with Pos w/o Bare Band',
                             font='Arial', fontsize=18)
                print('Please load Bare Band file')
                st.put('Please load Bare Band file')
            if emf=='BE':
                bo.invert_yaxis()
        try:
            if value2.get() != 'Real & Imaginary' and 'KK Transform' not in value2.get():
                xl = bo.get_xlim()
                yl = bo.get_ylim()
                climon()
                out.draw()
            else:
                climoff()
                out.draw()
        except:
            pass
        print('Done')
        st.put('Done')


props = dict(facecolor='green', alpha=0.3)


def select_callback(eclick, erelease):
    global ta0, ta0_, ta1, ta1_, ta2, a, f
    """
    Callback for line selection.

    *eclick* and *erelease* are the press and release events.
    """
    x1, y1 = eclick.xdata, eclick.ydata
    x2, y2 = erelease.xdata, erelease.ydata
    if eclick.button == 1:
        a.set_xlim(sorted([x1, x2]))
        if emf=='KE':
            a.set_ylim(sorted([y1, y2]))
        else:
            a.set_ylim(sorted([y1, y2], reverse=True))
        f.show()
        if abs(x1-x2) < (xl[1]-xl[0])/3*2 or abs(y1-y2) < (yl[1]-yl[0])/3*2:
            try:
                if mp == 1:
                    ta0.remove()
                if mf == 1:
                    ta0_.remove()
            except:
                pass
            try:
                if ep == 1:
                    ta1.remove()
                if ef == 1:
                    ta1_.remove()
            except:
                pass
            try:
                ta2.remove()
            except:
                pass
            if value2.get() == 'Data Plot with Pos and Bare Band' or value2.get() == 'Data Plot with Pos':
                try:
                    if mp == 1:
                        if emf=='KE':
                            ta0 = a.scatter(pos, fev, marker='.', s=30, c='black')
                        else:
                            ta0 = a.scatter(pos, vfe-fev, marker='.', s=30, c='black')
                    if mf == 1:
                        if emf=='KE':
                            ta0_ = a.scatter([posmin, posmax], [
                                         fev, fev], marker='|', c='grey', s=50, alpha=0.8)
                        else:
                            ta0_ = a.scatter([posmin, posmax], [vfe-fev, vfe-fev], marker='|', c='grey', s=50, alpha=0.8)
                except:
                    pass
                try:
                    if ep == 1:
                        if emf=='KE':
                            ta1 = a.scatter(fk, epos, marker='.', s=30, c='black')
                        else:
                            ta1 = a.scatter(fk, vfe-epos, marker='.', s=30, c='black')
                            
                    if ef == 1:
                        if emf=='KE':
                            ta1_ = a.scatter(
                                [fk, fk], [eposmin, eposmax], marker='_', c='grey', s=50, alpha=0.8)
                        else:
                            ta1_ = a.scatter(
                                [fk, fk], [vfe-eposmin, vfe-eposmax], marker='_', c='grey', s=50, alpha=0.8)
                except:
                    pass

                if value2.get() == 'Data Plot with Pos and Bare Band':
                    if emf=='KE':
                        ta2, = a.plot(k*np.float64(bbk_offset.get()), (be -
                                    np.float64(bb_offset.get()))/1000+vfe, linewidth=2, c='red', linestyle='--')
                    else:
                        ta2, = a.plot(k*np.float64(bbk_offset.get()), (-be +
                                    np.float64(bb_offset.get()))/1000, linewidth=2, c='red', linestyle='--')
            f.show()
        else:
            try:
                if mp == 1:
                    ta0.remove()
                    if emf=='KE':
                        ta0 = a.scatter(pos, fev, marker='.', s=0.3, c='black')
                    else:
                        ta0 = a.scatter(pos, vfe-fev, marker='.', s=0.3, c='black')
                        
                if mf == 1:
                    ta0_.remove()
                    if emf=='KE':
                        ta0_ = a.scatter([posmin, posmax], [fev, fev],
                                        marker='|', c='grey', s=10, alpha=0.8)
                    else:
                        ta0_ = a.scatter([posmin, posmax], [vfe-fev, vfe-fev],
                                        marker='|', c='grey', s=10, alpha=0.8)
            except:
                pass
            try:
                if ep == 1:
                    ta1.remove()
                    if emf=='KE':
                        ta1 = a.scatter(fk, epos, marker='.', s=0.3, c='black')
                    else:
                        ta1 = a.scatter(fk, vfe-epos, marker='.', s=0.3, c='black')
                        
                if ef == 1:
                    ta1_.remove()
                    if emf=='KE':
                        ta1_ = a.scatter([fk, fk], [eposmin, eposmax],
                                     marker='_', c='grey', s=10, alpha=0.8)
                    else:
                        ta1_ = a.scatter([fk, fk], [vfe-eposmin, vfe-eposmax],
                                     marker='_', c='grey', s=10, alpha=0.8)
            except:
                pass
            try:
                if value2.get() == 'Data Plot with Pos and Bare Band':
                    ta2.remove()
                    if emf =='KE':
                        ta2, = a.plot(k*np.float64(bbk_offset.get()), (be -
                                  np.float64(bb_offset.get()))/1000+vfe, linewidth=0.3, c='red', linestyle='--')
                    else:
                        ta2, = a.plot(k*np.float64(bbk_offset.get()), (-be +
                                  np.float64(bb_offset.get()))/1000, linewidth=0.3, c='red', linestyle='--')
            except:
                pass
            f.show()
    else:
        a.set_xlim(xl)
        a.set_ylim(yl)
        try:
            if mp == 1:
                ta0.remove()
                if emf=='KE':
                    ta0 = a.scatter(pos, fev, marker='.', s=0.3, c='black')
                else:
                    ta0 = a.scatter(pos, vfe-fev, marker='.', s=0.3, c='black')
                    
            if mf == 1:
                ta0_.remove()
                if emf=='KE':
                    ta0_ = a.scatter([posmin, posmax], [fev, fev],
                                 marker='|', c='grey', s=10, alpha=0.8)
                else:
                    ta0_ = a.scatter([posmin, posmax], [vfe-fev, vfe-fev],
                                 marker='|', c='grey', s=10, alpha=0.8)
        except:
            pass
        try:
            if ep == 1:
                ta1.remove()
                if emf=='KE':
                    ta1 = a.scatter(fk, epos, marker='.', s=0.3, c='black')
                else:
                    ta1 = a.scatter(fk, vfe-epos, marker='.', s=0.3, c='black')
                    
            if ef == 1:
                ta1_.remove()
                if emf=='KE':
                    ta1_ = a.scatter([fk, fk], [eposmin, eposmax],
                                 marker='_', c='grey', s=10, alpha=0.8)
                else:
                    ta1_ = a.scatter([fk, fk], [vfe-eposmin, vfe-eposmax],
                                 marker='_', c='grey', s=10, alpha=0.8)
        except:
            pass
        try:
            if value2.get() == 'Data Plot with Pos and Bare Band':
                ta2.remove()
                if emf=='KE':
                    ta2, = a.plot(k*np.float64(bbk_offset.get()), (be -
                                np.float64(bb_offset.get()))/1000+vfe, linewidth=0.3, c='red', linestyle='--')
                else:
                    ta2, = a.plot(k*np.float64(bbk_offset.get()), (-be +
                              np.float64(bb_offset.get()))/1000, linewidth=0.3, c='red', linestyle='--')
        except:
            pass
        f.show()
    # print(f"({x1:3.2f}, {y1:3.2f}) --> ({x2:3.2f}, {y2:3.2f})")
    # print(f"The buttons you used were: {eclick.button} {erelease.button}")
# def toggle_selector(event):
#     print('Key pressed.')
#     if event.key == 't':
#         for selector in selectors:
#             name = type(selector).__name__
#             if selector.active:
#                 print(f'{name} deactivated.')
#                 selector.set_active(False)
#             else:
#                 print(f'{name} activated.')
#                 selector.set_active(True)


def onselect(xmin, xmax):
    global f, f0, h1, h2
    if xmin > xmax:
        xmin, xmax = xmax, xmin
    # vcmin.set(xmin)
    # vcmax.set(xmax)
    h2.set_clim(xmin, xmax)
    # f0.canvas.draw_idle()
    f0.show()
    h1.set_clim(xmin, xmax)
    # f.canvas.draw_idle()
    f.show()


def onmove_callback(xmin, xmax):
    global f, f0, h1, h2
    if xmin > xmax:
        xmin, xmax = xmax, xmin
    # vcmin.set(xmin)
    # vcmax.set(xmax)
    h2.set_clim(xmin, xmax)
    # f0.canvas.draw_idle()
    f0.show()
    h1.set_clim(xmin, xmax)
    # f.canvas.draw_idle()
    f.show()


cf = True


def cut_move(event):
    global cxdata, cydata, acx, acy, a, f, xx ,yy
    # ,x,y
    f.canvas.get_tk_widget().config(cursor="")
    if event.inaxes:
        cxdata = event.xdata
        cydata = event.ydata
        xf = (cxdata >= a.get_xlim()[0] and cxdata <= a.get_xlim()[1])
        if emf=='KE':
            yf = (cydata >= a.get_ylim()[0] and cydata <= a.get_ylim()[1])
        else:
            yf = (cydata <= a.get_ylim()[0] and cydata >= a.get_ylim()[1])
        if xf and yf:
            f.canvas.get_tk_widget().config(cursor="crosshair")
            try:
                xx.remove()
                yy.remove()
            except:
                pass
            xx=a.axvline(cxdata,color='r')
            yy=a.axhline(cydata,color='r')
            if cf:
                if emf=='KE':
                    dx = data.sel(
                        eV=cydata, method='nearest').to_numpy().reshape(len(phi))
                else:
                    dx = data.sel(eV=vfe-cydata, method='nearest').to_numpy().reshape(len(phi))
                dy = data.sel(
                    phi=cxdata, method='nearest').to_numpy().reshape(len(ev))
                acx.clear()
                acy.clear()
                acx.set_title('                Raw Data', font='Arial', fontsize=18)
                acx.plot(phi, dx, c='black')
                if emf=='KE':
                    acy.plot(dy, ev, c='black')
                else:
                    acy.plot(dy, vfe-ev, c='black')
                acx.set_xticks([])
                acy.set_yticks([])
                acx.set_xlim(a.get_xlim())
                acy.set_ylim(a.get_ylim())
                # f.canvas.draw_idle()
    else:
        try:
            if cf:
                acx.clear()
                acy.clear()
                acx.set_title('                Raw Data', font='Arial', fontsize=18)
                acx.set_xticks([])
                acx.set_yticks([])
                acy.set_xticks([])
                acy.set_yticks([])
            xx.remove()
            yy.remove()
        except:
            pass
    f.show()


def cut_select(event):
    global cf, a, f, x, y, acx, acy
    if event.button == 1 and cf:
        cf = False
        x = a.axvline(event.xdata, color='red')
        y = a.axhline(event.ydata, color='red')
    elif event.button == 1 and not cf:
        x.remove()
        y.remove()
        x = a.axvline(event.xdata, color='red')
        y = a.axhline(event.ydata, color='red')
        if emf=='KE':
            dx = data.sel(eV=event.ydata,
                        method='nearest').to_numpy().reshape(len(phi))
        else:
            dx = data.sel(eV=vfe-event.ydata,
                        method='nearest').to_numpy().reshape(len(phi))
        dy = data.sel(phi=event.xdata,
                      method='nearest').to_numpy().reshape(len(ev))
        acx.clear()
        acy.clear()
        acx.set_title('                Raw Data', font='Arial', fontsize=18)
        acx.plot(phi, dx, c='black')
        if emf=='KE':
            acy.plot(dy, ev, c='black')
        else:
            acy.plot(dy, vfe-ev, c='black')
        acx.set_xticks([])
        acy.set_yticks([])
        acx.set_xlim(a.get_xlim())
        acy.set_ylim(a.get_ylim())

    elif event.button == 3:
        cf = True
        x.remove()
        y.remove()
    # f.canvas.draw_idle()
    copy_to_clipboard(ff=f)
    f.show()

# def cut_click(event):
#     if event.button is MouseButton.LEFT:
#         print('disconnecting callback')
# def o_exp():


def exp(*e):
    global value, value1, value2, value3, data, ev, phi, mx, my, mz, mfpath, fev, fwhm, pos, k, be, rx, ry, ix, iy, pflag, k_offset, limg, img, bb_offset, bbk_offset, h1, h2, a0, a, b, f0, f, selectors, acx, acy, posmin, posmax, eposmin, eposmax
    limg.config(image=img[np.random.randint(len(img))])
    selectors = []
    cursor = []
    h1 = []
    h2 = []
    f = []
    f0 = []
    if pflag == 1:
        if 'MDC Curves' not in value.get():
            mz = data.to_numpy()
            f0 = plt.figure(figsize=(8, 7), layout='constrained')
            a0 = plt.axes([0.13, 0.45, 0.8, 0.5])
            a1 = plt.axes([0.13, 0.08, 0.8, 0.2])
            a0.set_title('Drag to select specific region', font='Arial', fontsize=18)
            selectors.append(RectangleSelector(
                a0, select_callback,
                useblit=True,
                button=[1, 3],  # disable middle button
                minspanx=5, minspany=5,
                spancoords='pixels',
                interactive=True,
                props=props))
            # f0.canvas.mpl_connect('key_press_event',toggle_selector)
        if value.get() != 'Raw Data' and 'MDC Curves' not in value.get():
            f, a = plt.subplots(dpi=150)
        elif value.get() == 'MDC Curves':
            f=plt.figure(figsize=(4,6),dpi=150)
            a = f.subplots()
        elif value.get() == 'E-K with MDC Curves':
            f = plt.figure(figsize=(9, 7), layout='constrained')
            at_ = plt.axes([0.28, 0.15, 0.5, 0.75])
            at_.set_xticks([])
            at_.set_yticks([])
            a = plt.axes([0.13, 0.15, 0.4, 0.75])
            a1_ = plt.axes([0.53, 0.15, 0.4, 0.75])
        if value.get() == 'Raw Data':
            f = plt.figure(figsize=(9, 7), layout='constrained')
            a = plt.axes([0.13, 0.1, 0.55, 0.6])
            acx = plt.axes([0.13, 0.73, 0.55, 0.18])
            acy = plt.axes([0.7, 0.1, 0.15, 0.6])
            eacb = plt.axes([0.87, 0.1, 0.02, 0.6])
            plt.connect('motion_notify_event', cut_move)
            plt.connect('button_press_event', cut_select)
            if emf=='KE':
                mx, my = np.meshgrid(phi, ev)
            else:
                mx, my = np.meshgrid(phi, vfe-ev)
            # h1 = a.scatter(mx,my,c=mz,marker='o',s=0.9,cmap=value3.get());
            h1 = a.pcolormesh(mx, my, mz, cmap=value3.get())
            if emf=='KE':
                yl = a.get_ylim()
            else:
                yl = sorted(a.get_ylim(), reverse=True)
            cb = f.colorbar(h1, cax=eacb, orientation='vertical')
            cb.set_ticklabels(cb.get_ticks(), font='Arial', fontsize=20)
            
            h2 = a0.pcolormesh(mx, my, mz, cmap=value3.get())
            cb1 = f0.colorbar(h2)
            cb1.set_ticklabels(cb.get_ticks(), font='Arial', fontsize=14)

            acx.set_xticks([])
            acx.set_yticks([])
            acy.set_xticks([])
            acy.set_yticks([])
            
            n = a1.hist(mz.flatten(), bins=np.linspace(
                min(mz.flatten()), max(mz.flatten()), 50), color='green')
            a1.set_xlabel('Intensity')
            a1.set_ylabel('Counts')
            a1.set_title('Drag to Select the range of Intensity ')
            selectors.append(SpanSelector(
                a1,
                onselect,
                "horizontal",
                useblit=True,
                props=dict(alpha=0.3, facecolor="tab:blue"),
                onmove_callback=onmove_callback,
                interactive=True,
                drag_from_anywhere=True,
                snap_values=n[1]
            ))
        elif value.get() == 'First Derivative':
            pz = np.diff(smooth(data.to_numpy()))/np.diff(phi)
            if emf=='KE':
                px, py = np.meshgrid(phi[0:-1], ev)
                tev = py.copy()
            else:
                px, py = np.meshgrid(phi[0:-1], vfe-ev)
                tev = vfe-py.copy()
            if npzf:
                px = phi[0:-1]+np.diff(phi)/2
            else:
                px = (2*m*tev*1.602176634*10**-19)**0.5*np.sin((np.float64(k_offset.get())+px+np.diff(phi)/2)/180*np.pi)*10**-10/(h/2/np.pi)
            h1 = a.pcolormesh(px, py, pz, cmap=value3.get())
            if emf=='KE':
                yl = a.get_ylim()
            else:
                yl = sorted(a.get_ylim(), reverse=True)
            h2 = a0.pcolormesh(px, py, pz, cmap=value3.get())
            cb = f.colorbar(h1)
            cb.set_ticklabels(cb.get_ticks(), font='Arial', fontsize=20)
            
            cb1 = f0.colorbar(h2)
            cb1.set_ticklabels(cb1.get_ticks(), font='Arial', fontsize=14)

            n = a1.hist(pz.flatten(), bins=np.linspace(
                min(pz.flatten()), max(pz.flatten()), 50), color='green')
            a1.set_xlabel('Intensity')
            a1.set_ylabel('Counts')
            a1.set_title('Drag to Select the range of Intensity ')
            selectors.append(SpanSelector(
                a1,
                onselect,
                "horizontal",
                useblit=True,
                props=dict(alpha=0.3, facecolor="tab:blue"),
                onmove_callback=onmove_callback,
                interactive=True,
                drag_from_anywhere=True,
                snap_values=n[1]
            ))
        elif value.get() == 'Second Derivative':
            # pz = np.diff(smooth(data.to_numpy()))/np.diff(phi)
            # pz = -np.diff(smooth(pz))/np.diff(phi[0:-1])
            # if emf=='KE':
            #     px, py = np.meshgrid(phi[0:-2], ev)
            # else:
            #     px, py = np.meshgrid(phi[0:-2], vfe-ev)
            # px = (2*m*np.full_like(np.zeros([len(phi[0:-2]), len(ev)], dtype=float), ev)*1.602176634*10**-19).transpose(
            # )**0.5*np.sin((np.float64(k_offset.get())+px+np.diff(phi[0:-1])/2*2)/180*np.pi)*10**-10/(h/2/np.pi)
            
            pz = laplacian_filter(data.to_numpy(), im_kernel)
            if emf=='KE':
                px, py = np.meshgrid(phi, ev)
                tev = py.copy()
            else:
                px, py = np.meshgrid(phi, vfe-ev)
                tev = vfe-py.copy()
            if npzf:
                px = phi
            else:
                px = (2*m*tev*1.602176634*10**-19)**0.5*np.sin((np.float64(k_offset.get())+px)/180*np.pi)*10**-10/(h/2/np.pi)
            
            h1 = a.pcolormesh(px, py, pz, cmap=value3.get())
            if emf=='KE':
                yl = a.get_ylim()
            else:
                yl = sorted(a.get_ylim(), reverse=True)
            h2 = a0.pcolormesh(px, py, pz, cmap=value3.get())
            cb = f.colorbar(h1)
            cb.set_ticklabels(cb.get_ticks(), font='Arial', fontsize=20)
            
            cb1 = f0.colorbar(h2)
            cb1.set_ticklabels(cb1.get_ticks(), font='Arial', fontsize=14)

            n = a1.hist(pz.flatten(), bins=np.linspace(
                min(pz.flatten()), max(pz.flatten()), 50), color='green')
            a1.set_xlabel('Intensity')
            a1.set_ylabel('Counts')
            a1.set_title('Drag to Select the range of Intensity ')
            selectors.append(SpanSelector(
                a1,
                onselect,
                "horizontal",
                useblit=True,
                props=dict(alpha=0.3, facecolor="tab:blue"),
                onmove_callback=onmove_callback,
                interactive=True,
                drag_from_anywhere=True,
                snap_values=n[1]
            ))
        else:
            if value.get() == 'E-K Diagram':
                # h1=a.scatter(mx,my,c=mz,marker='o',s=0.9,cmap=value3.get());
                if emf=='KE':
                    px, py = np.meshgrid(phi, ev)
                    tev = py.copy()
                else:
                    px, py = np.meshgrid(phi, vfe-ev)
                    tev = vfe-py.copy()
                if npzf:
                    px = phi
                else:
                    px = (2*m*tev*1.602176634*10**-19)**0.5*np.sin((np.float64(k_offset.get())+px)/180*np.pi)*10**-10/(h/2/np.pi)
                pz = data.to_numpy()
                h1 = a.pcolormesh(px, py, pz, cmap=value3.get())
                if emf=='KE':
                    yl = a.get_ylim()
                else:
                    yl = sorted(a.get_ylim(), reverse=True)
                h2 = a0.pcolormesh(px, py, pz, cmap=value3.get())
                cb = f.colorbar(h1)
                cb.set_ticklabels(cb.get_ticks(), font='Arial', fontsize=20)
                
                cb1 = f0.colorbar(h2)
                cb1.set_ticklabels(cb1.get_ticks(), font='Arial', fontsize=14)
                

                n = a1.hist(pz.flatten(), bins=np.linspace(
                    min(pz.flatten()), max(pz.flatten()), 50), color='green')
                a1.set_xlabel('Intensity')
                a1.set_ylabel('Counts')
                a1.set_title('Drag to Select the range of Intensity ')
                selectors.append(SpanSelector(
                    a1,
                    onselect,
                    "horizontal",
                    useblit=True,
                    props=dict(alpha=0.3, facecolor="tab:blue"),
                    onmove_callback=onmove_callback,
                    interactive=True,
                    drag_from_anywhere=True,
                    snap_values=n[1]
                ))
            elif value.get() == 'MDC Normalized':
                for n in range(len(ev)-1):
                    ecut = data.sel(eV=ev[n], method='nearest')
                    if npzf:
                        x = phi
                    else:
                        x = (2*m*ev[n]*1.602176634*10**-19)**0.5*np.sin(
                        (np.float64(k_offset.get())+phi)/180*np.pi)*10**-10/(h/2/np.pi)
                    y = ecut.to_numpy().reshape(len(ecut))
                    # mz[len(phi)*n:len(phi)*(n+1)]=np.array(y,dtype=float)
                    # mx[len(phi)*n:len(phi)*(n+1)]=x
                    # ty=np.arange(len(x), dtype=float)
                    # my[len(phi)*n:len(phi)*(n+1)]=np.full_like(ty, ev[n])
                    # a.scatter(x,np.full_like(ty, ev[n]),c=np.array(y,dtype=int),marker='o',s=0.9,cmap=value3.get());
                    if emf=='KE':
                        px, py = np.meshgrid(x, ev[n:n+2])
                    else:
                        px, py = np.meshgrid(x, vfe-ev[n:n+2])
                    a.pcolormesh(px, py, np.full_like(
                        np.zeros([2, len(phi)], dtype=float), y), cmap=value3.get())
                    if emf=='KE':
                        yl = a.get_ylim()
                    else:
                        yl = sorted(a.get_ylim(), reverse=True)
                    a0.pcolormesh(px, py, np.full_like(
                        np.zeros([2, len(phi)], dtype=float), y), cmap=value3.get())
            elif value.get() == 'MDC Curves':
                y = np.zeros([len(ev),len(phi)],dtype=float)
                for n in range(len(ev)):
                    ecut = data.sel(eV=ev[n], method='nearest')
                    if npzf:
                        x = phi
                    else:
                        x = (2*m*ev[n]*1.602176634*10**-19)**0.5*np.sin(
                        (np.float64(k_offset.get())+phi)/180*np.pi)*10**-10/(h/2/np.pi)
                    y[n][:] = ecut.to_numpy().reshape(len(ecut))
                for n in range(len(ev)//d):
                    yy=y[n*d][:]+n*np.max(y)/d
                    yy=smooth(yy,l,p)
                    a.plot(x, yy, c='black')
            elif value.get() == 'E-K with MDC Curves':
                    y = np.zeros([len(ev),len(phi)],dtype=float)
                    for n in range(len(ev)):
                        ecut = data.sel(eV=ev[n], method='nearest')
                        if npzf:
                            x = phi
                        else:
                            x = (2*m*ev[n]*1.602176634*10**-19)**0.5*np.sin(
                            (np.float64(k_offset.get())+phi)/180*np.pi)*10**-10/(h/2/np.pi)
                        y[n][:] = ecut.to_numpy().reshape(len(ecut))
                    for n in range(len(ev)//d):
                        yy=y[n*d][:]+n*np.max(y)/d
                        yy=smooth(yy,l,p)
                        a1_.plot(x, yy, c='black')
                    if emf=='KE':
                        px, py = np.meshgrid(phi, ev)
                        tev = py.copy()
                    else:
                        px, py = np.meshgrid(phi, vfe-ev)
                        tev = vfe-py.copy()
                    if npzf:
                        px = phi
                    else:
                        px = (2*m*tev*1.602176634*10**-19)**0.5*np.sin((np.float64(k_offset.get())+px)/180*np.pi)*10**-10/(h/2/np.pi)
                    pz = data.to_numpy()
                    h1 = a.pcolormesh(px, py, pz, cmap=value3.get())
                    ylb=a1_.twinx()
                    ylb.set_ylabel('Intensity (a.u.)', font='Arial', fontsize=22)
                    ylb.set_yticklabels([])
                    # cb = fig.colorbar(h1, ax=a1_)
                    # cb.set_ticklabels(cb.get_ticks(), font='Arial', fontsize=20)
        if 'E-K with' not in value.get():
            if  value.get() != 'Raw Data':
                a.set_title(value.get(), font='Arial', fontsize=24)
        else:
            at_.set_title(value.get(), font='Arial', fontsize=24)
        a.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=22)
        a.set_xticklabels(labels=a.get_xticklabels(), fontsize=20)
        if 'MDC Curves' not in value.get():
            a0.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=16)
            a0.set_xticklabels(labels=a0.get_xticklabels(), fontsize=14)
            if emf=='KE':
                a.set_ylabel('Kinetic Energy (eV)', font='Arial', fontsize=22)
                a.set_yticklabels(labels=a.get_yticklabels(), fontsize=20)
                a0.set_ylabel('Kinetic Energy (eV)', font='Arial', fontsize=16)
                a0.set_yticklabels(labels=a0.get_yticklabels(), fontsize=14)
                if value.get() == 'Raw Data':
                    a.set_ylabel('Kinetic Energy (eV)', font='Arial', fontsize=16)
                    a.set_yticklabels(labels=a.get_yticklabels(), fontsize=14)
                    a0.set_ylabel('Kinetic Energy (eV)', font='Arial', fontsize=16)
                    a0.set_yticklabels(labels=a0.get_yticklabels(), fontsize=14)
            else:
                a.set_ylabel('Binding Energy (eV)', font='Arial', fontsize=22)
                a.set_yticklabels(labels=a.get_yticklabels(), fontsize=20)
                a0.set_ylabel('Binding Energy (eV)', font='Arial', fontsize=16)
                a0.set_yticklabels(labels=a0.get_yticklabels(), fontsize=14)
                if value.get() == 'Raw Data':
                    a.set_ylabel('Binding Energy (eV)', font='Arial', fontsize=16)
                    a.set_yticklabels(labels=a.get_yticklabels(), fontsize=14)
                    a0.set_ylabel('Binding Energy (eV)', font='Arial', fontsize=16)
                    a0.set_yticklabels(labels=a0.get_yticklabels(), fontsize=14)
                a.invert_yaxis()
                a0.invert_yaxis()
        else:
            if 'E-K with' in value.get():
                if emf=='KE':
                    a.set_ylabel('Kinetic Energy (eV)', font='Arial', fontsize=22)
                    a.set_yticklabels(labels=a.get_yticklabels(), fontsize=20)
                    a.set_ylim([ev[0], ev[n*d]])
                else:
                    a.set_ylabel('Binding Energy (eV)', font='Arial', fontsize=22)
                    a.set_yticklabels(labels=a.get_yticklabels(), fontsize=20)
                    a.invert_yaxis()
                    a.set_ylim([vfe-ev[0], vfe-ev[n*d]])
                a1_.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=22)
                a1_.set_xticklabels(labels=a1_.get_xticklabels(), fontsize=20)
                a1_.set_yticklabels([])
                a1_.set_xlim([min(x), max(x)])
                a1_.set_ylim([0, np.max(n*np.max(y)/d)])
            else:
                ylr=a.twinx()
                a.set_ylabel('Intensity (a.u.)', font='Arial', fontsize=22)
                a.set_yticklabels([])
                ylr.set_ylabel(r'$\longleftarrow$ Binding Energy', font='Arial', fontsize=22)
                ylr.set_yticklabels([])
                a.set_xlim([min(x), max(x)])
                a.set_ylim([0, np.max(n*np.max(y)/d)])
        if value.get() == 'Raw Data':
            acx.set_title('                Raw Data', font='Arial', fontsize=18)
            cb.set_ticklabels(cb.get_ticks(), font='Arial', fontsize=14)
            if npzf:
                a.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=16)
                a0.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=16)
            else:
                a.set_xlabel('Angle (deg)', font='Arial', fontsize=16)
                a0.set_xlabel('Angle (deg)', font='Arial', fontsize=16)
            a.set_xticklabels(labels=a.get_xticklabels(), fontsize=14)
            a0.set_xticklabels(labels=a0.get_xticklabels(), fontsize=14)
        # a.set_xticklabels(labels=a.get_xticklabels(),fontsize=10)
        # a.set_yticklabels(labels=a.get_yticklabels(),fontsize=10)
        # cursor = Cursor(a, useblit=True, color='red', linewidth=1)
    if pflag == 2:
        f, a = plt.subplots(2, 1, dpi=150)
        if value1.get() == 'MDC fitted Data':
            x = (vfe-fev)*1000

            a[0].set_title('MDC Fitting Result', font='Arial', fontsize=24)
            a[0].set_xlabel('Binding Energy (meV)', font='Arial', fontsize=22)
            a[0].set_xticklabels(labels=a[0].get_xticklabels(), fontsize=20)
            a[0].set_ylabel(
                r'Position ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=22)
            a[0].set_yticklabels(labels=a[0].get_yticklabels(), fontsize=20)
            a[0].tick_params(direction='in')
            a[0].scatter(x, pos, c='black', s=5)

            a[1].set_xlabel('Binding Energy (meV)', font='Arial', fontsize=22)
            a[1].set_xticklabels(labels=a[1].get_xticklabels(), fontsize=20)
            a[1].set_ylabel(
                r'FWHM ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=22)
            a[1].set_yticklabels(labels=a[1].get_yticklabels(), fontsize=20)
            a[1].tick_params(direction='in')
            a[1].scatter(x, fwhm, c='black', s=5)
            
            a[0].invert_xaxis()
            a[1].invert_xaxis()
        elif value1.get() == 'EDC fitted Data':
            x = fk

            a[0].set_title('EDC Fitting Result', font='Arial', fontsize=24)
            a[0].set_xlabel(
                r'Position ($\frac{2\pi}{\AA}$', font='Arial', fontsize=22)
            a[0].set_xticklabels(labels=a[0].get_xticklabels(), fontsize=20)
            a[0].set_ylabel('Binding Energy (meV))', font='Arial', fontsize=22)
            a[0].set_yticklabels(labels=a[0].get_yticklabels(), fontsize=20)
            a[0].tick_params(direction='in')
            a[0].scatter(x, (vfe-epos)*1000, c='black', s=5)

            a[1].set_xlabel(
                r'Position ($\frac{2\pi}{\AA}$', font='Arial', fontsize=22)
            a[1].set_xticklabels(labels=a[1].get_xticklabels(), fontsize=20)
            a[1].set_ylabel('FWHM (meV)', font='Arial', fontsize=22)
            a[1].set_yticklabels(labels=a[1].get_yticklabels(), fontsize=20)
            a[1].tick_params(direction='in')
            a[1].scatter(x, efwhm*1000, c='black', s=5)
            
            a[0].invert_yaxis()
            
        elif value1.get() == 'Real Part':
            x = (vfe-fev)*1000
            y = pos
            a[0].set_title('Real Part', font='Arial', fontsize=24)
            a[0].plot(rx, ry, c='black', linestyle='-', marker='.')

            a[0].tick_params(direction='in')
            a[0].set_xlabel('Binding Energy (meV)', font='Arial', fontsize=22)
            a[0].set_xticklabels(labels=a[0].get_xticklabels(), fontsize=20)
            a[0].set_ylabel(r'Re $\Sigma$ (meV)', font='Arial', fontsize=22)
            a[0].set_yticklabels(labels=a[0].get_yticklabels(), fontsize=20)

            h1 = a[1].scatter(y, x, c='black', s=5)
            h2 = a[1].scatter(k*np.float64(bbk_offset.get()),
                              -be+np.float64(bb_offset.get()), c='red', s=5)

            a[1].legend([h1, h2], ['fitted data', 'bare band'],fontsize=20)
            a[1].tick_params(direction='in')
            a[1].set_ylabel('Binding Energy (meV)', font='Arial', fontsize=22)
            a[1].set_yticklabels(labels=a[1].get_yticklabels(), fontsize=20)
            a[1].set_xlabel(
                r'Pos ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=22)
            a[1].set_xticklabels(labels=a[1].get_xticklabels(), fontsize=20)
            
            a[0].invert_xaxis()
            a[1].invert_yaxis()

            # a[0].set_xlim([-1000,50])
            # a[0].set_ylim([-100,500])
            # a[1].set_ylim([-600,200])
            # a[1].set_xlim([-0.05,0.05])
        elif value1.get() == 'Imaginary Part':

            tbe = (vfe-fev)*1000

            x = interp(tbe, -be+np.float64(bb_offset.get()),
                       k*np.float64(bbk_offset.get()))
            y = interp(x, k*np.float64(bbk_offset.get()),
                       -be+np.float64(bb_offset.get()))
            xx = np.diff(x)
            yy = np.diff(y)

            # eliminate vf in gap
            for i in range(len(yy)):
                if yy[i]/xx[i] > 20000:
                    yy[i] = 0
            v = yy/xx
            # v = np.append(v, v[-1])  # fermi velocity
            v=interp(pos,x[0:-1]+xx/2,v)
            yy = np.abs(v*fwhm/2)
            xx = tbe
            ax = a
            a = ax[0]
            b = ax[1]
            a.set_title('Imaginary Part', font='Arial', fontsize=24)
            a.plot(xx, yy, c='black', linestyle='-', marker='.')

            ix = xx
            iy = yy
            a.tick_params(direction='in')
            a.set_xlabel('Binding Energy (eV)', font='Arial', fontsize=22)
            a.set_xticklabels(labels=a.get_xticklabels(), fontsize=20)
            a.set_ylabel(r'Im $\Sigma$ (meV)', font='Arial', fontsize=22)
            a.set_yticklabels(labels=a.get_yticklabels(), fontsize=20)

            x = (vfe-fev)*1000
            y = fwhm
            b.plot(x, y, c='black', linestyle='-', marker='.')
            b.tick_params(direction='in')
            b.set_xlabel('Binding Energy (eV)', font='Arial', fontsize=22)
            b.set_xticklabels(labels=b.get_xticklabels(), fontsize=20)
            b.set_ylabel(r'FWHM ($\frac{2\pi}{\AA}$)',
                         font='Arial', fontsize=22)
            b.set_yticklabels(labels=b.get_yticklabels(), fontsize=20)

            x = (vfe-fev)*1000
            y = pos
            yy = interp(y, k*np.float64(bbk_offset.get()), be -
                        np.float64(bb_offset.get()))  # interp x into be,k set
            
            a.invert_xaxis()
            b.invert_xaxis()
    if pflag == 3:
        if value2.get() == 'Real & Imaginary':
            f, a = plt.subplots(2, 1, dpi=150)
            a[0].set_title(r'Self Energy $\Sigma$', font='Arial', fontsize=24)
            if dl==0:
                a[0].scatter(rx, ry, edgecolors='black', c='w')
            elif dl==1:
                a[0].plot(rx, ry, c='black')
            elif dl==2:
                a[0].plot(rx, ry, c='black', linestyle='-', marker='.')
            a[0].tick_params(direction='in')
            a[0].set_xlabel('Binding Energy (meV)', font='Arial', fontsize=22)
            a[0].set_xticklabels(labels=a[0].get_xticklabels(), fontsize=20)
            a[0].set_ylabel(r'Re $\Sigma$ (meV)', font='Arial', fontsize=22)
            a[0].set_yticklabels(labels=a[0].get_yticklabels(), fontsize=20)
            if dl==0:
                a[1].scatter(ix, iy, edgecolors='black', c='w')
            elif dl==1:
                a[1].plot(ix, iy, c='black')
            elif dl==2:
                a[1].plot(ix, iy, c='black', linestyle='-', marker='.')
            a[1].tick_params(direction='in')
            a[1].set_xlabel('Binding Energy (meV)', font='Arial', fontsize=22)
            a[1].set_xticklabels(labels=a[1].get_xticklabels(), fontsize=20)
            a[1].set_ylabel(r'Im $\Sigma$ (meV)', font='Arial', fontsize=22)
            a[1].set_yticklabels(labels=a[1].get_yticklabels(), fontsize=20)
            
            a[0].invert_xaxis()
            a[1].invert_xaxis()
        elif 'KK Transform' in value2.get():
            
            tbe = (vfe-fev)*1000
            ix=(tbe-tbe[-1])*-1
            cix=np.append(ix+ix[0],ix)
            tix=cix[0:len(cix)-1]*-1
            # kx=ix
            kx = np.append(cix,tix[::-1])
            ky = np.linspace(0, 1, len(kx))
            ciy=np.append(iy*0+np.mean(iy),iy)
            tiy=ciy[0:len(ciy)-1]
            ciy = np.append(ciy,tiy[::-1])

            #for imaginary part
            ix=(tbe-tbe[-1])*-1
            cix=np.append(ix+ix[0],ix)
            tix=cix[0:len(cix)-1]*-1
            kx = np.append(cix,tix[::-1])
            ky = np.linspace(0, 1, len(kx))
            cry=np.append(ry*0,ry)
            tcry=cry[0:len(cry)-1]*-1
            cry = np.append(cry,tcry[::-1])

            # Hilbert transform
            analytic_signal_r = hilbert(cry)
            amplitude_envelope_r = np.abs(analytic_signal_r)
            instantaneous_phase_r = np.unwrap(np.angle(analytic_signal_r))
            instantaneous_frequency_r = np.diff(instantaneous_phase_r) / (2.0 * np.pi)

            analytic_signal_i = hilbert(ciy)
            amplitude_envelope_i = np.abs(analytic_signal_i)
            instantaneous_phase_i = np.unwrap(np.angle(analytic_signal_i))
            instantaneous_frequency_i = np.diff(instantaneous_phase_i) / (2.0 * np.pi)

            # Reconstructed real and imaginary parts
            reconstructed_real = np.imag(analytic_signal_i)
            reconstructed_imag = -np.imag(analytic_signal_r)

                # Plot
            if 'Real Part' not in value2.get() and 'Imaginary Part' not in value2.get():
                f, a = plt.subplots(2, 1, dpi=150)
                # Plot imaginary data and its Hilbert transformation
                a[0].set_title(r'Self Energy $\Sigma$', font='Arial', fontsize=24)
                if dl==0:
                    a[0].scatter(tbe, ry, edgecolors='black', c='w', label=r'Re $\Sigma$')
                    a[0].scatter(tbe, reconstructed_real[len(ix):2*len(ix)]+(ry-np.mean(reconstructed_real[len(ix):2*len(ix)])), edgecolors='red', c='w', label=r'Re $\Sigma_{KK}$=KK(Im $\Sigma$)')
                elif dl==1:
                    a[0].plot(tbe, ry, c='black', label=r'Re $\Sigma$')
                    a[0].plot(tbe, reconstructed_real[len(ix):2*len(ix)]+(ry-np.mean(reconstructed_real[len(ix):2*len(ix)])), c='red', label=r'Re $\Sigma_{KK}$=KK(Im $\Sigma$)')
                elif dl==2:
                    a[0].plot(tbe, ry, c='black', linestyle='-', marker='.', label=r'Re $\Sigma$')
                    a[0].plot(tbe, reconstructed_real[len(ix):2*len(ix)]+(ry-np.mean(reconstructed_real[len(ix):2*len(ix)])), c='red', linestyle='-', marker='.', label=r'Re $\Sigma_{KK}$=KK(Im $\Sigma$)')
                a[0].set_xlabel('Binding Energy (meV)', font='Arial', fontsize=22)
                a[0].set_xticklabels(a[0].get_xticklabels(), fontsize=20)
                a[0].set_ylabel(r'Re $\Sigma$ (meV)', font='Arial', fontsize=22)
                a[0].set_yticklabels(a[0].get_yticklabels(), fontsize=20)
                a[0].legend(fontsize=20)
                if dl==0:
                    a[1].scatter(tbe, iy, edgecolors='black', c='w', label=r'Im $\Sigma$')
                    a[1].scatter(tbe, reconstructed_imag[len(ix):2*len(ix)]+(iy-np.mean(reconstructed_imag[len(ix):2*len(ix)])), edgecolors='red', c='w', label=r'Im $\Sigma_{KK}$=KK(Re $\Sigma$)')
                elif dl==1:
                    a[1].plot(tbe, iy, c='black', label=r'Im $\Sigma$')
                    a[1].plot(tbe, reconstructed_imag[len(ix):2*len(ix)]+(iy-np.mean(reconstructed_imag[len(ix):2*len(ix)])), c='red', label=r'Im $\Sigma_{KK}$=KK(Re $\Sigma$)')
                elif dl==2:
                    a[1].plot(tbe, iy, c='black', linestyle='-', marker='.', label=r'Im $\Sigma$')
                    a[1].plot(tbe, reconstructed_imag[len(ix):2*len(ix)]+(iy-np.mean(reconstructed_imag[len(ix):2*len(ix)])), c='red', linestyle='-', marker='.', label=r'Im $\Sigma_{KK}$=KK(Re $\Sigma$)')
                a[1].set_xlabel('Binding Energy (meV)', font='Arial', fontsize=22)
                a[1].set_xticklabels(a[1].get_xticklabels(), fontsize=20)
                a[1].set_ylabel(r'Im $\Sigma$ (meV)', font='Arial', fontsize=22)
                a[1].set_yticklabels(a[1].get_yticklabels(), fontsize=20)
                a[1].legend(fontsize=20)
                a[0].invert_xaxis()
                a[1].invert_xaxis()
            elif 'Real Part' in value2.get():
                f = plt.figure(figsize=(8, 7),layout='constrained')
                a=plt.axes([0.2,0.12,0.7,0.8])
                ttbe=tbe/1000
                if 'nd' in value2.get():
                    a.set_title(r'Self Energy $\Sigma$ Real Part', font='Arial', fontsize=24)
                    ty=np.diff(smooth(ry,20,3))/np.diff(ttbe)
                    if dl==0:
                        a.scatter(ttbe[0:-1], ty, edgecolors='black', c='w', label=r'Re $\Sigma$')
                    elif dl==1:
                        a.plot(ttbe[0:-1], ty, c='black', label=r'Re $\Sigma$')
                    elif dl==2:
                        a.plot(ttbe[0:-1], ty, c='black', linestyle='-', marker='.', label=r'Re $\Sigma$')
                    a.set_xlabel('Binding Energy (eV)', font='Arial', fontsize=22)
                    a.set_ylabel(r'$2^{nd} der. Re \Sigma$', font='Arial', fontsize=22)
                    a.set_xticklabels(a.get_xticklabels(),fontsize=20)
                    a.set_yticks([0])
                    a.set_yticklabels(a.get_yticklabels(),fontsize=20)
                else:
                    a.set_title(r'Self Energy $\Sigma$ Real Part', font='Arial', fontsize=24)
                    if dl==0:
                        a.scatter(ttbe, ry, edgecolors='black', c='w', label=r'Re $\Sigma$')
                        a.scatter(ttbe, reconstructed_real[len(ix):2*len(ix)]+(ry-np.mean(reconstructed_real[len(ix):2*len(ix)])), edgecolors='red', c='w', label=r'Re $\Sigma_{KK}$=KK(Im $\Sigma$)')
                    elif dl==1:
                        a.plot(ttbe, ry, c='black', label=r'Re $\Sigma$')
                        a.plot(ttbe, reconstructed_real[len(ix):2*len(ix)]+(ry-np.mean(reconstructed_real[len(ix):2*len(ix)])), c='red', label=r'Re $\Sigma_{KK}$=KK(Im $\Sigma$)')
                    elif dl==2:
                        a.plot(ttbe, ry, c='black', linestyle='-', marker='.', label=r'Re $\Sigma$')
                        a.plot(ttbe, reconstructed_real[len(ix):2*len(ix)]+(ry-np.mean(reconstructed_real[len(ix):2*len(ix)])), c='red', linestyle='-', marker='.', label=r'Re $\Sigma_{KK}$=KK(Im $\Sigma$)')
                    a.set_xlabel('Binding Energy (eV)', font='Arial', fontsize=22)
                    a.set_ylabel(r'Re $\Sigma$ (meV)', font='Arial', fontsize=22)
                    a.set_xticklabels(a.get_xticklabels(),fontsize=20)
                    a.set_yticklabels(a.get_yticklabels(),fontsize=20)
                    ll=a.legend(fontsize=20)
                    ll.draw_frame(False)
                a.invert_xaxis()
            elif 'Imaginary Part' in value2.get():
                f = plt.figure(figsize=(8, 7),layout='constrained')
                a=plt.axes([0.2,0.12,0.7,0.8])
                ttbe=tbe/1000
                if 'st' in value2.get():
                    a.set_title(r'Self Energy $\Sigma$ Imaginary Part', font='Arial', fontsize=24)
                    ty=np.diff(smooth(iy,20,3))/np.diff(ttbe)
                    if dl==0:
                        a.scatter(ttbe[0:-1], ty, edgecolors='black', c='w', label=r'Im $\Sigma$')
                    elif dl==1:
                        a.plot(ttbe[0:-1], ty, c='black', label=r'Im $\Sigma$')
                    elif dl==2:
                        a.plot(ttbe[0:-1], ty, c='black', linestyle='-', marker='.', label=r'Im $\Sigma$')
                    a.set_xlabel('Binding Energy (eV)', font='Arial', fontsize=22)
                    a.set_ylabel(r'$1^{st} der. Im \Sigma$', font='Arial', fontsize=22)
                    a.set_xticklabels(a.get_xticklabels(),fontsize=20)
                    a.set_yticks([0])
                    a.set_yticklabels(a.get_yticklabels(),fontsize=20)
                else:
                    a.set_title(r'Self Energy $\Sigma$ Imaginary Part', font='Arial', fontsize=24)
                    if dl==0:
                        a.scatter(ttbe, iy, edgecolors='black', c='w', label=r'Im $\Sigma$')
                        a.scatter(ttbe, reconstructed_imag[len(ix):2*len(ix)]+(iy-np.mean(reconstructed_imag[len(ix):2*len(ix)])), edgecolors='red', c='w', label=r'Im $\Sigma_{KK}$=KK(Re $\Sigma$)')
                    elif dl==1:
                        a.plot(ttbe, iy, c='black', label=r'Im $\Sigma$')
                        a.plot(ttbe, reconstructed_imag[len(ix):2*len(ix)]+(iy-np.mean(reconstructed_imag[len(ix):2*len(ix)])), c='red', label=r'Im $\Sigma_{KK}$=KK(Re $\Sigma$)')
                    elif dl==2:
                        a.plot(ttbe, iy, c='black', linestyle='-', marker='.', label=r'Im $\Sigma$')
                        a.plot(ttbe, reconstructed_imag[len(ix):2*len(ix)]+(iy-np.mean(reconstructed_imag[len(ix):2*len(ix)])), c='red', linestyle='-', marker='.', label=r'Im $\Sigma_{KK}$=KK(Re $\Sigma$)')
                    a.set_xlabel('Binding Energy (eV)', font='Arial', fontsize=22)
                    a.set_ylabel(r'Im $\Sigma$ (meV)', font='Arial', fontsize=22)
                    a.set_xticklabels(a.get_xticklabels(),fontsize=20)
                    a.set_yticklabels(a.get_yticklabels(),fontsize=20)
                    ll=a.legend(fontsize=20)
                    ll.draw_frame(False)
                a.invert_xaxis()
            ####################################################################################### KK definition
            #######################################################################################
            # f, ax = plt.subplots(2, 1, dpi=150)
            # a = ax[0]
            # b = ax[1]
            # a.set_title('Self Energy', font='Arial', fontsize=24)
            # a.plot(rx, ry, c='black', linestyle='-',
            #        marker='.', label=r'Re $\Sigma$')
            # a.tick_params(direction='in')
            # a.set_xlabel('Binding Energy (eV)', font='Arial', fontsize=22)
            # a.set_ylabel(r'Re $\Sigma$ (meV)', font='Arial', fontsize=22)

            # tbe = (vfe-fev)*1000
            # ix=(tbe-tbe[-1])*-1
            # cix=np.append(ix+ix[0],ix)
            # tix=cix[0:len(cix)-1]*-1
            # # kx=ix
            # kx = np.append(cix,tix[::-1])
            # ky = np.linspace(0, 1, len(kx))
            # ciy=np.append(iy*0,iy)
            # tiy=ciy[0:len(ciy)-1]
            # ciy = np.append(ciy,tiy[::-1])
            # # de=np.linspace(0,1,len(kx))
            # # de[0:-1]=np.diff(kx)
            # # de[-1]=de[-2]
            # de = np.diff(kx)
            # de = np.append(de, de[-1])

            # for i in range(len(kx)):
            #     # ky[i]=np.trapz(y=iy/(iy-kx[i]),x=iy,dx=de)
            #     intg = 0
            #     for j in range(len(kx)):
            #         if i != j:
            #             tval = ciy[j]/(kx[j]-kx[i])*de[j]
            #             if str(ciy[j]) == 'nan':
            #                 tval = 0
            #             intg += tval
            #     ky[i] = -1/np.pi*intg/2
            # a.plot(tbe, ky[len(ix):2*len(ix)], c='red', linestyle='-', marker='.',
            #        label=r'Re $\Sigma_{KK}$=KK(Im $\Sigma$)')
            # handles, labels = a.get_legend_handles_labels()
            # a.legend(handles, labels)
            # # a.legend([h1,h2],['measured data','KK transform'])

            # #   KK Re
            # b.plot(tbe, ciy[len(ix):2*len(ix)], c='black', linestyle='-',
            #        marker='.', label=r'Im $\Sigma$')
            # b.tick_params(direction='in')
            # b.set_xlabel('Binding Energy (meV)', font='Arial', fontsize=22)
            # b.set_ylabel(r'Im $\Sigma$ (meV)', font='Arial', fontsize=22)

            
            
            # ix=(tbe-tbe[-1])*-1
            # cix=np.append(ix+ix[0],ix)
            # tix=cix[0:len(cix)-1]*-1
            # kx = np.append(cix,tix[::-1])
            # ky = np.linspace(0, 1, len(kx))
            # ciy=np.append(ry*0,ry)
            # tiy=ciy[0:len(ciy)-1]*-1
            # ciy = np.append(ciy,tiy[::-1])
            
            # # kx = rx
            # ky = np.linspace(0, 1, len(kx))
            # # de=np.linspace(0,1,len(kx))
            # # de[0:-1]=np.diff(kx)
            # # de[-1]=de[-2]
            # de = np.diff(kx)
            # de = np.append(de, de[-1])

            # for i in range(len(kx)):
            #     # ky[i]=np.trapz(y=iy/(iy-kx[i]),x=iy,dx=de)
            #     intg = 0
            #     for j in range(len(kx)):
            #         if i != j:
            #             tval = ciy[j]/(kx[j]-kx[i])*de[j]
            #             if str(ciy[j]) == 'nan':
            #                 tval = 0
            #             intg += tval
            #     ky[i] = 1/np.pi*intg
            # b.plot(tbe, ky[len(ix):2*len(ix)], c='red', linestyle='-', marker='.',
            #        label=r'Im $\Sigma_{KK}$=KK(Re $\Sigma$)')
            # handles, labels = b.get_legend_handles_labels()
            # b.legend(handles, labels)
            
            # a.invert_xaxis()
            # b.invert_xaxis()
            #######################################################################################
            ####################################################################################### KK definition
            
            
            
        elif value2.get() == 'Data Plot with Pos' or value2.get() == 'Data Plot with Pos and Bare Band':
            f0 = plt.figure(figsize=(8, 7), layout='constrained')
            a0 = plt.axes([0.13, 0.45, 0.8, 0.5])
            a1 = plt.axes([0.13, 0.08, 0.8, 0.2])
            a0.set_title('Drag to select specific region', font='Arial', fontsize=18)
            selectors.append(RectangleSelector(
                a0, select_callback,
                useblit=True,
                button=[1, 3],  # disable middle button
                minspanx=5, minspany=5,
                spancoords='pixels',
                interactive=True,
                props=props))
            # f0.canvas.mpl_connect('key_press_event',toggle_selector)
            f, a = plt.subplots(dpi=150)
            if emf=='KE':
                px, py = np.meshgrid(phi, ev)
                tev = py.copy()
            else:
                px, py = np.meshgrid(phi, vfe-ev)
                tev = vfe - py.copy()
            if npzf:
                px = phi
            else:
                px = (2*m*tev*1.602176634*10**-19)**0.5*np.sin((np.float64(k_offset.get())+px)/180*np.pi)*10**-10/(h/2/np.pi)
            pz = data.to_numpy()
            h1 = a.pcolormesh(px, py, pz, cmap=value3.get())
            if emf=='KE':
                yl = a.get_ylim()
            else:
                yl = sorted(a.get_ylim(), reverse=True)
            cb = f.colorbar(h1)
            # cb.set_ticklabels(cb.get_ticks(), font='Arial', fontsize=20, minor=False)
            cb.set_ticklabels(cb.get_ticks(), font='Arial', fontsize=20)
            
            a.set_title(value2.get(), font='Arial', fontsize=24)
            a.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=22)
            a.set_xticklabels(labels=a.get_xticklabels(), fontsize=20)
            if emf=='KE':
                a.set_ylabel('Kinetic Energy (eV)', font='Arial', fontsize=22)
            else:
                a.set_ylabel('Binding Energy (eV)', font='Arial', fontsize=22)
            a.set_yticklabels(labels=a.get_yticklabels(), fontsize=20)
            try:
                if mp == 1:
                    if emf=='KE':
                        a.scatter(pos, fev, marker='.', s=0.3, c='black')
                    else:
                        a.scatter(pos, vfe-fev, marker='.', s=0.3, c='black')
                        
                if mf == 1:
                    ophimin = np.arcsin(
                        (rpos-fwhm/2)/(2*m*fev*1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
                    ophimax = np.arcsin(
                        (rpos+fwhm/2)/(2*m*fev*1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
                    posmin = (2*m*fev*1.602176634*10**-19)**0.5*np.sin(
                        (np.float64(k_offset.get())+ophimin)/180*np.pi)*10**-10/(h/2/np.pi)
                    posmax = (2*m*fev*1.602176634*10**-19)**0.5*np.sin(
                        (np.float64(k_offset.get())+ophimax)/180*np.pi)*10**-10/(h/2/np.pi)
                    if emf=='KE':
                        a.scatter([posmin, posmax], [fev, fev],
                                marker='|', c='grey', s=10, alpha=0.8)
                    else:
                        a.scatter([posmin, posmax], [vfe-fev, vfe-fev],
                                marker='|', c='grey', s=10, alpha=0.8)
            except:
                pass
            try:
                if ep == 1:
                    if emf=='KE':
                        a.scatter(fk, epos, marker='.', s=0.3, c='black')
                    else:
                        a.scatter(fk, vfe-epos, marker='.', s=0.3, c='black')
                            
                if ef == 1:
                    eposmin = epos-efwhm/2
                    eposmax = epos+efwhm/2
                    if emf=='KE':
                        a.scatter([fk, fk], [eposmin, eposmax],
                                marker='_', c='grey', s=10, alpha=0.8)
                    else:
                        a.scatter([fk, fk], [vfe-eposmin, vfe-eposmax],
                                marker='_', c='grey', s=10, alpha=0.8)
                        
            except:
                pass
            h2 = a0.pcolormesh(px, py, pz, cmap=value3.get())
            cb1 = f0.colorbar(h2)
            cb1.set_ticks(cb1.get_ticks())
            cb1.set_ticklabels(cb1.get_ticks(), font='Arial',
                               fontsize=14, minor=False)
            a0.set_xlabel(r'k ($\frac{2\pi}{\AA}$)', font='Arial', fontsize=16)
            if emf=='KE':
                a0.set_ylabel('Kinetic Energy (eV)', font='Arial', fontsize=16)
            else:
                a0.set_ylabel('Binding Energy (eV)', font='Arial', fontsize=16)
                
            try:
                if mp == 1:
                    if emf=='KE':
                        a0.scatter(pos, fev, marker='.', s=0.3, c='black')
                    else:
                        a0.scatter(pos, vfe-fev, marker='.', s=0.3, c='black')
                        
                if mf == 1:
                    ophimin = np.arcsin(
                        (rpos-fwhm/2)/(2*m*fev*1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
                    ophimax = np.arcsin(
                        (rpos+fwhm/2)/(2*m*fev*1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
                    posmin = (2*m*fev*1.602176634*10**-19)**0.5*np.sin(
                        (np.float64(k_offset.get())+ophimin)/180*np.pi)*10**-10/(h/2/np.pi)
                    posmax = (2*m*fev*1.602176634*10**-19)**0.5*np.sin(
                        (np.float64(k_offset.get())+ophimax)/180*np.pi)*10**-10/(h/2/np.pi)
                    if emf=='KE':
                        a0.scatter([posmin, posmax], [fev, fev],
                                marker='|', c='grey', s=10, alpha=0.8)
                    else:
                        a0.scatter([posmin, posmax], [vfe-fev, vfe-fev],
                                marker='|', c='grey', s=10, alpha=0.8)
            except:
                pass
            try:
                if ep == 1:
                    if emf=='KE':
                        a0.scatter(fk, epos, marker='.', s=0.3, c='black')
                    else:
                        a0.scatter(fk, vfe-epos, marker='.', s=0.3, c='black')
                        
                if ef == 1:
                    eposmin = epos-efwhm/2
                    eposmax = epos+efwhm/2
                    if emf=='KE':
                        a0.scatter([fk, fk], [eposmin, eposmax],
                                marker='_', c='grey', s=10, alpha=0.8)
                    else:
                        a0.scatter([fk, fk], [vfe-eposmin, vfe-eposmax],
                                marker='_', c='grey', s=10, alpha=0.8)
            except:
                pass
            # b.set_xticklabels(labels=b.get_xticklabels(),font='Arial',fontsize=20)
            # b.set_yticklabels(labels=b.get_yticklabels(),font='Arial',fontsize=20)

            n = a1.hist(pz.flatten(), bins=np.linspace(
                min(pz.flatten()), max(pz.flatten()), 50), color='green')
            a1.set_xlabel('Intensity')
            a1.set_ylabel('Counts')
            a1.set_title('Drag to Select the range of Intensity ')
            selectors.append(SpanSelector(
                a1,
                onselect,
                "horizontal",
                useblit=True,
                props=dict(alpha=0.3, facecolor="tab:blue"),
                onmove_callback=onmove_callback,
                interactive=True,
                drag_from_anywhere=True,
                snap_values=n[1]
            ))
            try:
                if value2.get() == 'Data Plot with Pos and Bare Band':
                    if emf=='KE':
                        a.plot(k*np.float64(bbk_offset.get()), (be -
                            np.float64(bb_offset.get()))/1000+vfe, linewidth=0.3, c='red', linestyle='--')
                        a0.plot(k*np.float64(bbk_offset.get()), (be -
                                np.float64(bb_offset.get()))/1000+vfe, linewidth=0.3, c='red', linestyle='--')
                    else:
                        a.plot(k*np.float64(bbk_offset.get()), (-be +
                            np.float64(bb_offset.get()))/1000, linewidth=0.3, c='red', linestyle='--')
                        a0.plot(k*np.float64(bbk_offset.get()), (-be +
                                np.float64(bb_offset.get()))/1000, linewidth=0.3, c='red', linestyle='--')
            except:
                pass
            if emf=='BE':
                a.invert_yaxis()
                a0.invert_yaxis()
            cursor = Cursor(a, useblit=True, color='red', linewidth=1)
    try:
        if value1.get() == '---Plot2---' and value2.get() != 'Real & Imaginary' and 'KK Transform' not in value2.get() and 'MDC Curves' not in value.get():
            try:
                h1.set_clim([vcmin.get(), vcmax.get()])
                h2.set_clim([vcmin.get(), vcmax.get()])
            except:
                pass
            a0.set_xlim(xl)
            a0.set_ylim(yl)
            a.set_xlim(xl)
            a.set_ylim(yl)
            if value.get() != 'Raw Data':
                plt.tight_layout()
            # if value.get()=='Raw Data':
            #     plt.connect('motion_notify_event', cut_move)
            copy_to_clipboard(f)
            st.put('graph copied to clipboard')
            if value.get() != 'Raw Data':
                threading.Thread(target=show_info,daemon=True).start()
            plt.show()
            try:
                h1.set_clim([cm.get(), cM.get()])
                h2.set_clim([cm.get(), cM.get()])
            except:
                pass
        else:
            plt.tight_layout()
            copy_to_clipboard(f)
            st.put('graph copied to clipboard')
            threading.Thread(target=show_info,daemon=True).start()
            plt.show()
        # f.ion()
        # f0.ion()
    except:
        print('fail to export graph')
        pass

    # fp=fd.asksaveasfilename(filetypes=(("PNG files", "*.png"),))
    # f.savefig(fname=fp)


def move(event):
    global xdata, ydata, x1, y1, x2, y2
    if event.xdata != None:
        out.get_tk_widget().config(cursor="crosshair")
        try:
            out.get_tk_widget().delete('rec')
            # out.get_tk_widget().delete('x1')
            # out.get_tk_widget().delete('y1')
            # out.get_tk_widget().delete('x2')
            # out.get_tk_widget().delete('y2')
        except:
            pass
        if mof == -1 and value1.get() == '---Plot2---' and value2.get() != 'Real & Imaginary' and 'KK Transform' not in value2.get() and 'MDC Curves' not in value.get():
            x2, y2 = event.xdata, event.ydata
            px2, py2 = event.x, event.y
            out.get_tk_widget().create_rectangle((px1, 600-py1), (px2, 600-py2),
                                                 outline='black', width=2, tag='rec')
        if value.get() == 'Raw Data':
            if event.inaxes:
                cxdata = event.xdata
                cydata = event.ydata
                xf = (cxdata >= ao.get_xlim()[0] and cxdata <= ao.get_xlim()[1])
                if emf=='KE':
                    yf = (cydata >= ao.get_ylim()[0] and cydata <= ao.get_ylim()[1])
                else:
                    yf = (cydata <= ao.get_ylim()[0] and cydata >= ao.get_ylim()[1])
                if xf and yf:
                    if emf=='KE':
                        dx = data.sel(
                            eV=cydata, method='nearest').to_numpy().reshape(len(phi))
                    else:
                        dx = data.sel(
                            eV=vfe-cydata, method='nearest').to_numpy().reshape(len(phi))
                    dy = data.sel(
                        phi=cxdata, method='nearest').to_numpy().reshape(len(ev))
                    # try:
                    #     x.remove()
                    #     y.remove()
                    # except:
                    #     pass
                    # x=a.axvline(cxdata,color='r')
                    # y=a.axhline(cydata,color='r')
                    rcx.clear()
                    rcy.clear()
                    rcx.set_title('            Raw Data', font='Arial', fontsize=16)
                    rcx.plot(phi, dx, c='black')
                    if emf=='KE':
                        rcy.plot(dy, ev, c='black')
                    else:
                        rcy.plot(dy, vfe-ev, c='black')
                    rcx.set_xticks([])
                    rcy.set_yticks([])
                    rcx.set_xlim(ao.get_xlim())
                    rcy.set_ylim(ao.get_ylim())
                    out.draw()
        xdata.config(text='xdata:'+str('%.3f' % event.xdata))
        ydata.config(text='ydata:'+str('%.3f' % event.ydata))
    else:
        if value.get() == 'Raw Data':
            rcx.clear()
            rcy.clear()
            rcx.set_xticks([])
            rcx.set_yticks([])
            rcy.set_xticks([])
            rcy.set_yticks([])
            rcx.set_title('            Raw Data', font='Arial', fontsize=16)
            out.draw()
        out.get_tk_widget().config(cursor="")
        xdata.config(text='xdata:')
        ydata.config(text='ydata:')

    # print("event.xdata", event.xdata)
    # print("event.ydata", event.ydata)
    # print("event.inaxes", event.inaxes)
    # print("x", event.x)
    # print("y", event.y)
mof = 1


def press(event):
    # event.button 1:left 3:right 2:mid
    # event.dblclick : bool
    # print('%s click: button=%d, x=%d, y=%d, xdata=%f, ydata=%f' %
    #       ('double' if event.dblclick else 'single', event.button,
    #        event.x, event.y, event.xdata, event.ydata))
    global x1, y1, mof, px1, py1, ao, bo, out, tb0, tb0_, tb1, tb1_, tb2
    if event.button == 1:
        x1, y1 = event.xdata, event.ydata
        px1, py1 = event.x, event.y
        mof = -1
    elif event.button == 3 and value1.get() == '---Plot2---' and value2.get() != 'Real & Imaginary' and 'KK Transform' not in value2.get() and 'MDC Curves' not in value.get():
        if value2.get() == '---Plot3---':
            ao.set_xlim(xl)
            ao.set_ylim(yl)
            out.draw()
        else:
            bo.set_xlim(xl)
            bo.set_ylim(yl)
            try:
                if mp == 1:
                    tb0.remove()
                    if emf=='KE':
                        tb0 = bo.scatter(pos, fev, marker='.', s=0.3, c='black')
                    else:
                        tb0 = bo.scatter(pos, vfe-fev, marker='.', s=0.3, c='black')
                        
                if mf == 1:
                    tb0_.remove()
                    ophimin = np.arcsin(
                        (rpos-fwhm/2)/(2*m*fev*1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
                    ophimax = np.arcsin(
                        (rpos+fwhm/2)/(2*m*fev*1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
                    posmin = (2*m*fev*1.602176634*10**-19)**0.5*np.sin(
                        (np.float64(k_offset.get())+ophimin)/180*np.pi)*10**-10/(h/2/np.pi)
                    posmax = (2*m*fev*1.602176634*10**-19)**0.5*np.sin(
                        (np.float64(k_offset.get())+ophimax)/180*np.pi)*10**-10/(h/2/np.pi)
                    if emf=='KE':
                        tb0_ = bo.scatter([posmin, posmax], [
                                        fev, fev], marker='|', c='grey', s=10, alpha=0.8)
                    else:
                        tb0_ = bo.scatter([posmin, posmax], [vfe-fev, vfe-fev], marker='|', c='grey', s=10, alpha=0.8)
            except:
                pass
            try:
                if ep == 1:
                    tb1.remove()
                    if emf=='KE':
                        tb1 = bo.scatter(fk, epos, marker='.', s=0.3, c='black')
                    else:
                        tb1 = bo.scatter(fk, vfe-epos, marker='.', s=0.3, c='black')
                        
                if ef == 1:
                    tb1_.remove()
                    eposmin = epos-efwhm/2
                    eposmax = epos+efwhm/2
                    if emf=='KE':
                        tb1_ = bo.scatter(
                            [fk, fk], [eposmin, eposmax], marker='_', c='grey', s=10, alpha=0.8)
                    else:
                        tb1_ = bo.scatter(
                            [fk, fk], [vfe-eposmin, vfe-eposmax], marker='_', c='grey', s=10, alpha=0.8)
            except:
                pass
            try:
                if value2.get() == 'Data Plot with Pos and Bare Band':
                    tb2.remove()
                    if emf=='KE':
                        tb2, = bo.plot(k*np.float64(bbk_offset.get()), (be -
                                    np.float64(bb_offset.get()))/1000+vfe, linewidth=0.3, c='red', linestyle='--')
                    else:
                        print('plotting bb0')
                        tb2, = bo.plot(k*np.float64(bbk_offset.get()), (-be +
                                    np.float64(bb_offset.get()))/1000, linewidth=0.3, c='red', linestyle='--')
                        print('plotted bb0')
            except:
                pass
            out.draw()
        mof = 1


def release(event):
    global x2, y2, mof, tb0, tb0_, tb1, tb1_, tb2, out, ao, bo
    try:
        out.get_tk_widget().delete('rec')
    except:
        pass
    if event.button == 1 and mof == -1 and value1.get() == '---Plot2---' and value2.get() != 'Real & Imaginary' and 'KK Transform' not in value2.get() and 'MDC Curves' not in value.get():
        x2, y2 = event.xdata, event.ydata
        if value2.get() == '---Plot3---':
            ao.set_xlim(sorted([x1, x2]))
            if emf=='KE':    
                ao.set_ylim(sorted([y1, y2]))
            else:
                ao.set_ylim(sorted([y1, y2], reverse=True))
            out.draw()
        else:
            bo.set_xlim(sorted([x1, x2]))
            if emf=='KE':    
                bo.set_ylim(sorted([y1, y2]))
            else:
                bo.set_ylim(sorted([y1, y2], reverse=True))
            if abs(x1-x2) < (xl[1]-xl[0])/3*2 or abs(y1-y2) < (yl[1]-yl[0])/3*2:
                try:
                    if mp == 1:
                        tb0.remove()
                    if mf == 1:
                        tb0_.remove()
                except:
                    pass
                try:
                    if ep == 1:
                        tb1.remove()
                    if ef == 1:
                        tb1_.remove()
                except:
                    pass
                try:
                    tb2.remove()
                except:
                    pass
                if value2.get() == 'Data Plot with Pos' or value2.get() == 'Data Plot with Pos and Bare Band':
                    try:
                        if mp == 1:
                            if emf=='KE':
                                tb0 = bo.scatter(
                                    pos, fev, marker='.', s=30, c='black')
                            else:
                                tb0 = bo.scatter(
                                    pos, vfe-fev, marker='.', s=30, c='black')
                        if mf == 1:
                            ophimin = np.arcsin(
                                (rpos-fwhm/2)/(2*m*fev*1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
                            ophimax = np.arcsin(
                                (rpos+fwhm/2)/(2*m*fev*1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
                            posmin = (2*m*fev*1.602176634*10**-19)**0.5*np.sin(
                                (np.float64(k_offset.get())+ophimin)/180*np.pi)*10**-10/(h/2/np.pi)
                            posmax = (2*m*fev*1.602176634*10**-19)**0.5*np.sin(
                                (np.float64(k_offset.get())+ophimax)/180*np.pi)*10**-10/(h/2/np.pi)
                            if emf=='KE':
                                tb0_ = bo.scatter([posmin, posmax], [
                                                fev, fev], marker='|', c='grey', s=50, alpha=0.8)
                            else:
                                tb0_ = bo.scatter([posmin, posmax], [vfe-fev, vfe-fev], marker='|', c='grey', s=50, alpha=0.8)

                    except:
                        pass
                    try:
                        if ep == 1:
                            if emf=='KE':
                                tb1 = bo.scatter(
                                    fk, epos, marker='.', s=30, c='black')
                            else:
                                tb1 = bo.scatter(
                                    fk, vfe-epos, marker='.', s=30, c='black')
                        if ef == 1:
                            eposmin = epos-efwhm/2
                            eposmax = epos+efwhm/2
                            if emf=='KE':
                                tb1_ = bo.scatter(
                                    [fk, fk], [eposmin, eposmax], marker='_', c='grey', s=50, alpha=0.8)
                            else:
                                tb1_ = bo.scatter(
                                [fk, fk], [vfe-eposmin, vfe-eposmax], marker='_', c='grey', s=50, alpha=0.8)
                    except:
                        pass
                    if value2.get() == 'Data Plot with Pos and Bare Band':
                        if emf=='KE':
                            tb2, = bo.plot(k*np.float64(bbk_offset.get()), (be -
                                        np.float64(bb_offset.get()))/1000+vfe, linewidth=5, c='red', linestyle='--')
                        else:
                            tb2, = bo.plot(k*np.float64(bbk_offset.get()), (-be +
                                        np.float64(bb_offset.get()))/1000, linewidth=5, c='red', linestyle='--')
            else:
                try:
                    if mp == 1:
                        tb0.remove()
                        if emf=='KE':
                            tb0 = bo.scatter(pos, fev, marker='.',
                                            s=0.3, c='black')
                        else:
                            tb0 = bo.scatter(pos, vfe-fev, marker='.',
                                            s=0.3, c='black')
                    if mf == 1:
                        tb0_.remove()
                        ophimin = np.arcsin(
                            (rpos-fwhm/2)/(2*m*fev*1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
                        ophimax = np.arcsin(
                            (rpos+fwhm/2)/(2*m*fev*1.602176634*10**-19)**0.5/10**-10*(h/2/np.pi))*180/np.pi
                        posmin = (2*m*fev*1.602176634*10**-19)**0.5*np.sin(
                            (np.float64(k_offset.get())+ophimin)/180*np.pi)*10**-10/(h/2/np.pi)
                        posmax = (2*m*fev*1.602176634*10**-19)**0.5*np.sin(
                            (np.float64(k_offset.get())+ophimax)/180*np.pi)*10**-10/(h/2/np.pi)
                        if emf=='KE':
                            tb0_ = bo.scatter([posmin, posmax], [
                                            fev, fev], marker='|', c='grey', s=10, alpha=0.8)
                        else:
                            tb0_ = bo.scatter([posmin, posmax], [vfe-fev, vfe-fev], marker='|', c='grey', s=10, alpha=0.8)
                except:
                    pass
                try:
                    if ep == 1:
                        tb1.remove()
                        if emf=='KE':
                            tb1 = bo.scatter(fk, epos, marker='.',
                                            s=0.3, c='black')
                        else:
                            tb1 = bo.scatter(fk, vfe-epos, marker='.',
                                        s=0.3, c='black')
                    if ef == 1:
                        tb1_.remove()
                        eposmin = epos-efwhm/2
                        eposmax = epos+efwhm/2
                        if emf=='KE':
                            tb1_ = bo.scatter(
                                [fk, fk], [eposmin, eposmax], marker='_', c='grey', s=10, alpha=0.8)
                        else:
                            tb1_ = bo.scatter(
                                [fk, fk], [vfe-eposmin, vfe-eposmax], marker='_', c='grey', s=10, alpha=0.8)
                except:
                    pass
                try:
                    if value2.get() == 'Data Plot with Pos and Bare Band':
                        tb2.remove()
                        if emf=='KE':
                            tb2, = bo.plot(k*np.float64(bbk_offset.get()), (be+np.float64(
                                bb_offset.get()))/1000+vfe, linewidth=0.3, c='red', linestyle='--')
                        else:
                            tb2, = bo.plot(k*np.float64(bbk_offset.get()), (be+np.float64(
                                bb_offset.get()))/1000, linewidth=0.3, c='red', linestyle='--')
                except:
                    pass
            out.draw()
        mof = 1


def angcut():
    t0 = threading.Thread(target=o_angcut)
    t0.daemon = True
    t0.start()


def ecut():
    t1 = threading.Thread(target=o_ecut)
    t1.daemon = True
    t1.start()


def loadmfit():
    t2 = threading.Thread(target=o_loadmfit)
    t2.daemon = True
    t2.start()


def loadefit():
    t3 = threading.Thread(target=o_loadefit)
    t3.daemon = True
    t3.start()


def reload(*e):
    t4 = threading.Thread(target=o_reload)
    t4.daemon = True
    t4.start()


def expte():
    t5 = threading.Thread(target=o_expte)
    t5.daemon = True
    t5.start()


def exptm():
    t6 = threading.Thread(target=o_exptm)
    t6.daemon = True
    t6.start()


def bareband():
    t7 = threading.Thread(target=o_bareband)
    t7.daemon = True
    t7.start()


def plot(event):
    if value.get() == '---Plot1---' and value1.get() == '---Plot2---' and value2.get() == '---Plot3---':
        trans_plot()
    else:
        plot1()
        plot2()
        plot3()
    
im_kernel = 17
d,l,p = 8,20,3
def plot1(*e):
    if 'MDC Curves' in value.get():
        def select_all(event):
            event.widget.select_range(0, tk.END)
            return 'break'
        
        def ini():
            v_d.set(str(d))
            v_l.set(str(l))
            v_p.set(str(p))
            cl.focus()
        def chf():
            global d, l, p
            try:
                d = int(v_d.get())
                l = int(v_l.get())
                p = int(v_p.get())
                if p < l:
                    t8 = threading.Thread(target=o_plot1)
                    t8.daemon = True
                    t8.start()
                    gg.destroy()
                else:
                    tk.messagebox.showwarning("Warning","Invalid Input\n"+"Polyorder must be less than window_length")
                    gg.destroy()
                    plot1(*e)
            except:
                gg.destroy()
                plot1(*e)

        def on_enter(event):
            chf()
            
        gg = tk.Toplevel(g, bg="white", padx=10, pady=10)
        gg.title('Plotting Parameter')
        gg.iconphoto(False, tk.PhotoImage(data=b64decode(gicon)))

        fd = tk.Frame(gg, bg="white")
        fd.grid(row=0, column=0, padx=10, pady=5)
        ld = tk.Label(fd, text='Energy Axis Density (1/n), n :', font=(
            "Arial", 18, "bold"), bg="white", height='1')
        ld.grid(row=0, column=0, padx=10, pady=10)
        v_d = tk.StringVar()
        cd = tk.Entry(fd, font=(
            "Arial", 16, "bold"), textvariable=v_d, width=10, bg="white")
        cd.grid(row=0, column=1, padx=10, pady=5)

        fl = tk.Frame(gg, bg="white")
        fl.grid(row=1, column=0, padx=10, pady=5)
        ll = tk.Label(fl, text='Savgol Filter Window Length :', font=(
            "Arial", 18, "bold"), bg="white", height='1')
        ll.grid(row=0, column=0, padx=10, pady=10)
        v_l = tk.StringVar()
        cl = tk.Entry(fl, font=(
            "Arial", 16, "bold"), textvariable=v_l, width=10, bg="white")
        cl.grid(row=0, column=1, padx=10, pady=5)
        
        fp = tk.Frame(gg, bg="white")
        fp.grid(row=2, column=0, padx=10, pady=5)
        lp = tk.Label(fp, text='Savgol Filter Polynomial Degree :', font=(
            "Arial", 18, "bold"), bg="white", height='1')
        lp.grid(row=0, column=0, padx=10, pady=10)
        v_p = tk.StringVar()
        cp = tk.Entry(fp, font=(
            "Arial", 16, "bold"), textvariable=v_p, width=10, bg="white")
        cp.grid(row=0, column=1, padx=10, pady=5)

        l_smooth = tk.Label(gg, text='Note:\n\tPolynomial Degree 0 or 1: Moving Average\n\tPolyorder must be less than window_length', font=(
            "Arial", 14, "bold"), bg="white", height='3',justify='left')
        l_smooth.grid(row=3, column=0, padx=10, pady=10)

        bflag = tk.Button(gg, text="OK", font=("Arial", 16, "bold"),
                          height=2, width=10, bg="white", command=chf)
        bflag.grid(row=4, column=0, padx=10, pady=5)
        cd.bind('<FocusIn>', select_all)
        cl.bind('<FocusIn>', select_all)
        cp.bind('<FocusIn>', select_all)
        
        gg.bind('<Return>', on_enter)
        gg.focus_set()
        ini()
    elif value.get() == 'Second Derivative':
        def select_all(event):
            event.widget.select_range(0, tk.END)
            return 'break'
        
        def ini():
            v_k.set(str(im_kernel))
            ck.focus()
        def chf():
            global im_kernel
            try:
                if int(v_k.get())%2==1:
                    im_kernel = int(v_k.get())
                    t8 = threading.Thread(target=o_plot1)
                    t8.daemon = True
                    t8.start()
                    gg.destroy()
                else:
                    tk.messagebox.showwarning("Warning","Invalid Input\n"+"Kernel size must be an odd number")
                    gg.destroy()
                    plot1(*e)
            except:
                gg.destroy()
                plot1(*e)

        def on_enter(event):
            chf()
            
        gg = tk.Toplevel(g, bg="white", padx=10, pady=10)
        gg.title('Gaussian Smoothing Kernel Size')
        gg.iconphoto(False, tk.PhotoImage(data=b64decode(gicon)))

        fd = tk.Frame(gg, bg="white")
        fd.grid(row=0, column=0, padx=10, pady=5)
        ld = tk.Label(fd, text='Kernel Size :', font=(
            "Arial", 18, "bold"), bg="white", height='1')
        ld.grid(row=0, column=0, padx=10, pady=10)
        v_k = tk.StringVar()
        ck = tk.Entry(fd, font=(
            "Arial", 16, "bold"), textvariable=v_k, width=10, bg="white")
        ck.grid(row=0, column=1, padx=10, pady=5)
        
        l_smooth = tk.Label(gg, text='Note:\n\tKernel size must be an odd number', font=(
            "Arial", 14, "bold"), bg="white", height='3',justify='left')
        l_smooth.grid(row=3, column=0, padx=10, pady=10)
        
        bflag = tk.Button(gg, text="OK", font=("Arial", 16, "bold"),
                          height=2, width=10, bg="white", command=chf)
        bflag.grid(row=4, column=0, padx=10, pady=5)
        
        ck.bind('<FocusIn>', select_all)
        
        gg.bind('<Return>', on_enter)
        gg.focus_set()
        ini()
    else:
        t8 = threading.Thread(target=o_plot1)
        t8.daemon = True
        t8.start()


def plot2(*e):
    t9 = threading.Thread(target=o_plot2)
    t9.daemon = True
    t9.start()


def plot3(*e):
    if value2.get() == 'Data Plot with Pos' or value2.get() == 'Data Plot with Pos and Bare Band':
        def ini():
            global mp, ep, mf, ef
            if len(fev) <= 0:
                mp = 0
                mpos.deselect()
                mpos.config(state='disabled')
                mf = 0
                mfwhm.deselect()
                mfwhm.config(state='disabled')
            if len(fk) <= 0:
                ep = 0
                epos.deselect()
                epos.config(state='disabled')
                ef = 0
                efwhm.deselect()
                efwhm.config(state='disabled')

        def chf():
            global mp, ep, mf, ef
            mp = v_mpos.get()
            ep = v_epos.get()
            mf = v_mfwhm.get()
            ef = v_efwhm.get()
            t10 = threading.Thread(target=o_plot3)
            t10.daemon = True
            t10.start()
            gg.destroy()

        def on_enter(event):
            chf()
            
        gg = tk.Toplevel(g, bg="white", padx=10, pady=10)
        gg.title('Data Point List')
        gg.iconphoto(False, tk.PhotoImage(data=b64decode(gicon)))
        lpos = tk.Label(gg, text='Position', font=(
            "Arial", 18, "bold"), bg="white", height='1')
        lpos.grid(row=0, column=0, padx=10, pady=10)

        pos = tk.Frame(gg, bg="white")
        pos.grid(row=1, column=0, padx=10, pady=5)
        v_mpos = tk.IntVar()
        mpos = tk.Checkbutton(pos, text="MDC", font=(
            "Arial", 16, "bold"), variable=v_mpos, onvalue=1, offvalue=0, height=2, width=10, bg="white")
        mpos.grid(row=0, column=0, padx=10, pady=5)
        mpos.intvar = v_mpos
        mpos.select()

        v_epos = tk.IntVar()
        epos = tk.Checkbutton(pos, text="EDC", font=(
            "Arial", 16, "bold"), variable=v_epos, onvalue=1, offvalue=0, height=2, width=10, bg="white")
        epos.grid(row=0, column=1, padx=10, pady=5)
        epos.intvar = v_epos
        epos.select()

        lfwhm = tk.Label(gg, text='FWHM', font=(
            "Arial", 18, "bold"), bg="white", height='1')
        lfwhm.grid(row=2, column=0, padx=10, pady=10)

        fwhm = tk.Frame(gg, bg="white")
        fwhm.grid(row=3, column=0, padx=10, pady=5)
        v_mfwhm = tk.IntVar()
        mfwhm = tk.Checkbutton(fwhm, text="MDC", font=(
            "Arial", 16, "bold"), variable=v_mfwhm, onvalue=1, offvalue=0, height=2, width=10, bg="white")
        mfwhm.grid(row=0, column=0, padx=10, pady=5)
        mfwhm.intvar = v_mfwhm
        mfwhm.select()

        v_efwhm = tk.IntVar()
        efwhm = tk.Checkbutton(fwhm, text="EDC", font=(
            "Arial", 16, "bold"), variable=v_efwhm, onvalue=1, offvalue=0, height=2, width=10, bg="white")
        efwhm.grid(row=0, column=1, padx=10, pady=5)
        efwhm.intvar = v_efwhm
        efwhm.select()

        bflag = tk.Button(gg, text="OK", font=("Arial", 16, "bold"),
                          height=2, width=10, bg="white", command=chf)
        bflag.grid(row=4, column=0, padx=10, pady=5)
        gg.bind('<Return>', on_enter)
        gg.focus_set()
        ini()
    else:
        t10 = threading.Thread(target=o_plot3)
        t10.daemon = True
        t10.start()


def load():
    t11 = threading.Thread(target=o_load)
    t11.daemon = True
    t11.start()


def fitgl():
    t12 = threading.Thread(target=o_fitgl)
    t12.daemon = True
    t12.start()


def tstate():
    try:
        while True:
            state.config(text=str(st.get()))
    except:
        pass

def lm2p():
    t = threading.Thread(target=loadmfit_2p)
    t.daemon = True
    t.start()


def lmre():
    t = threading.Thread(target=loadmfit_re)
    t.daemon = True
    t.start()


def lm():
    t = threading.Thread(target=loadmfit_)
    t.daemon = True
    t.start()


def o_loadmfit():
    global g, st, lmgg
    lmgg = tk.Toplevel(g)
    lmgg.title('Load MDC fitted File')
    lmgg.geometry('400x200')  # format:'1400x800'
    b1 = tk.Button(lmgg, command=lm2p, text='vms 1 peak to 2 peaks', font=(
        "Arial", 12, "bold"), fg='red', width=30, height='1', bd=10)
    b1.pack()
    b2 = tk.Button(lmgg, command=lmre, text='reverse vms axis', font=(
        "Arial", 12, "bold"), fg='red', width=30, height='1', bd=10)
    b2.pack()
    b3 = tk.Button(lmgg, command=lm, text='load MDC fitted File', font=(
        "Arial", 12, "bold"), fg='red', width=30, height='1', bd=10)
    b3.pack()
    lmgg.update()

def dl_sw():
    global dl, b_sw
    s=['dot','line','dot-line']
    dl=(dl+1)%3
    b_sw.config(text=s[dl])
    t = threading.Thread(target=o_plot3)
    t.daemon = True
    t.start()

if __name__ == '__main__':
    g = tk.Tk()
    os.chdir(cdir)
    if os.path.exists('open_check_MDC_cut.txt')==0:
        with open ('open_check_MDC_cut.txt', 'w', encoding = 'utf-8') as f:
            f.write('1')
            f.close()
        if os.name == 'nt':
            os.system(rf'start cmd /C "chcp 65001 & python -W ignore::SyntaxWarning -W ignore::UserWarning "{app_name}.py""')
        elif os.name == 'posix':
            try:
                os.system(rf'start cmd /C "chcp 65001 & python3 -W ignore::SyntaxWarning -W ignore::UserWarning "{app_name}.py""')
            except:
                os.system(rf'start cmd /C "chcp 65001 & python -W ignore::SyntaxWarning -W ignore::UserWarning "{app_name}.py""')
        quit()
    else:
        os.remove('open_check_MDC_cut.txt')
    try:
        with np.load('rd.npz', 'rb') as ff:
            path = str(ff['path'])
            name = str(ff['name'])
            lpath = ff['lpath']
            ev = ff['ev']
            phi = ff['phi']
            st = str(ff['st'])
            lst = ff['lst']
            print('\nRaw Data preloaded:\n\n')
            lfs = loadfiles(lpath)
            data = lfs.data[0]
            for _ in data.attrs.keys():
                if _ != 'Description':
                    print(_,':', data.attrs[_])
                else:
                    print(_,':', data.attrs[_].replace('\n','\n              '))
            dvalue = [data.attrs[i] for i in data.attrs.keys()]
            lensmode = dvalue[8]
            rdd = path  # old version data path
            dpath = path    # new version data path
    except:
        print('No Raw Data preloaded')

    try:
        with np.load('bb.npz', 'rb') as f:
            bpath = str(f['path'])
            be = f['be']
            k = f['k']
            bbo = f['bbo']
            bbk = f['bbk']
            print('Bare Band file preloaded:')
            print(bpath+'\n')
    except:
        bpath = ''
        print('No Bare Band file preloaded')

    try:
        with np.load('efpath.npz', 'rb') as f:
            efpath = str(f['efpath'])
            print('EDC Fitted path preloaded')
    except:
        print('No EDC Fitted path preloaded')

    try:
        with np.load('mfpath.npz', 'rb') as f:
            mfpath = str(f['mfpath'])
            print('MDC Fitted path preloaded')
    except:
        print('No MDC Fitted path preloaded')

    try:
        with np.load('efit.npz', 'rb') as f:
            ko = str(f['ko'])
            fphi = f['fphi']
            epos = f['epos']
            ffphi = f['ffphi']
            efwhm = f['efwhm']
            fk = f['fk']
            emin = f['emin']
            emax = f['emax']
            semin = f['semin']
            semax = f['semax']
            seaa1 = f['seaa1']
            seaa2 = f['seaa2']
            sefp = f['sefp']
            sefi = f['sefi']
            print('EDC Fitted Data preloaded (Casa)')
        fpr = 1
    except:
        print('No EDC fitted data preloaded (Casa)')

    try:
        with np.load('mfit.npz', 'rb') as f:
            ko = str(f['ko'])
            fev = f['fev']
            rpos = f['rpos']
            ophi = f['ophi']
            fwhm = f['fwhm']
            pos = f['pos']
            kmin = f['kmin']
            kmax = f['kmax']
            skmin = f['skmin']
            skmax = f['skmax']
            smaa1 = f['smaa1']
            smaa2 = f['smaa2']
            smfp = f['smfp']
            smfi = f['smfi']
            try:
                smresult = f['smresult']
                smcst = f['smcst']
                print('MDC Fitted Data preloaded (lmfit)')
            except:
                print('MDC Fitted Data preloaded (Casa)')
        fpr = 1
    except:
        print('No MDC fitted data preloaded (Casa)')

    emf='KE'
    try:
        vfe=e_photon
    except:
        vfe=21.2

    '''
    try:
        with np.load('efpara.npz','rb') as f:
            rdd=f['path']
            fphi=f['fphi']
            efwhm=f['efwhm']
            epos=f['epos']
            semin=f['semin']
            semax=f['semax']
            seaa1=f['seaa1']
            seaa2=f['seaa2']
            sefp=f['sefp']
            sefi=f['sefi']
            print('EDC Fitted Data preloaded')
    except:
        print('No EDC fitted data preloaded')
        
    try:
        with np.load('mfpara.npz','rb') as f:
            rdd=f['path']
            fev=f['fev']
            fwhm=f['fwhm']
            pos=f['pos']
            skmin=f['skmin']
            skmax=f['skmax']
            smaa1=f['smaa1']
            smaa2=f['smaa2']
            smfp=f['smfp']
            smfi=f['smfi']
            print('MDC Fitted Data preloaded')
    except:
        print('No MDC fitted data preloaded')
    '''
    v_fe = tk.StringVar()
    v_fe.set(str(vfe))
    windll.shcore.SetProcessDpiAwareness(1)
    ScaleFactor = windll.shcore.GetScaleFactorForDevice(0)
    g.tk.call('tk', 'scaling', ScaleFactor/ScaleFactor/0.75)
    g.geometry('1900x1080+0+0')
    g.title('MDC cut')
    g.config(bg='white')
    # g.geometry('1920x980')  # format:'1400x800'
    g.resizable(True, True)
    icon = "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"
    icon1 = "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"
    icon2 = "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"
    icon3 = "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"
    icon4 = "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iigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACkpaSgCvfXH2e1kl6BRXxD+0NrT6l46u3U5j8sCvsvxhMYfDl4VPzbOK+BfHV5cXuvXTMjNyRyPevls+quNFQXc+q4ep3ruo+3+RzMZBxnrXIeL5z80ee9dZIrqu4Rtx7V5/4kmllvD+6cj6V8bhY807n3WIfumT0Sul8HwFpN/Sua2S7TmJ/yruPCNq8dikhjbr6V6GIlamclFXkdDtznJoVd7qo5p8NpJcSYVG57Yr1j4Z/CG58Q30LSxFYcbjkc15lDD1MRJRgjpr4inhouVR2sa3wD+HE+saobyWP91Gw7V9g2FrFZ20cUY2qowAKxPBPhG18KaakUCbWI+biukx7V+mZfhFg6Kgtz8xzDGPGVnNbC0lLRXpHljOn1rmvGnjKDwppsksxG7af5Vs6xqsej2T3EpAC8mvjv43/FO51vWruG3J+yE4Ra8vMMZHB0ubqerl+BljatuhwXj7xlJ4o1SaSRmKeY2BntmuTdtzDaOKRmaQ5ZDzz0oy68BDt+lfmFSbqy5p7s/U6VONKPJFWSA9aSjDf3Gow/9xqgsKKMP/cajD/3GoAKKMP/AHGow/8AcagApyNtNN2t/cb8qCGPRGqozcHzR6ClFTXK+pdRwwpc1SUuv8LCp42fP3WzX0WHzKLSVS9zwK2XyTbgycL0OKeIzMDtP1q9pOjXWpXMcaRMd3tXq3gz4FXuoyJJIhEZPNezR/f6w2PFrv2PxvU800Hwvd6y4W3jLnOOma+hfhn8B1Rbe4vgDnDFa9N8E/CfS/DcMcgizKOSGFd6sQjXCIqjtgV7VLCxjqzwa2MlP3YlTTtLg0uFYLZNkWOMVfpMbcAdKWu/0PMCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKT1paKAK15ZxXls8Uq7kYYNecX3wT0e9upJTZRNu7kV6eaF6VjUo06vxq5tTrVKXwOx5K3wB0VlINlDz7Vi3f7MWh3Mu42UP5V7pQKxjhaMNom7xld7yPBj+y3ofP+hQn8K1LD9nfR7OBI1s4gAa9l/hoIzRLCUZLWILGV1tI810z4I6BZXCu+nwtj2rutN0Ox0kKLS1jhAGMqK0MdqQKF5Fawo06XwRsYTrVKnxybF5ooWlrfYxCiiigDF8TaGdcszCG4IxXmU37Pun3UjPNBHIx7tXsvRqBzXLWwtKu06ivY6qWKq4dWpu1zxb/hnbTP+faOj/hnbTf+faOvatoo2isP7Pw/8p0f2jif5jxX/hnbTf8An2jo/wCGdtN/59o69q2ijaKP7Pw/8of2jif5jxX/AIZ203/n2jo/4Z203/n2jr2raKNoo/s/D/yh/aOJ/mPFf+GdtN/59o6P+GdtN/59o69q2ijaKP7Pw/8AKH9o4n+Y8V/4Z203/n2jo/4Z203/AJ9o69q2ijaKP7Pw/wDKH9o4n+Y8V/4Z30zIzbR1o2vwB0SLBazhY/SvWGUYpMYprA4eLvykyx+JkrORyuk/DPw/pca7NNhEg/ixzXSWtlBZrtgiWNfYVODzTq7IxjH4VY4pTlL4ncT60tJ3pa0ICiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP//Z"
    icon5 = "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"
    icon6 = "/9j/4AAQSkZJRgABAQEBSgFKAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAMLAwwDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9UqKKWgBKKWigBKKWigBKRqdTWoASiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACkZlX73SlpkihsbjgCgA8lW5zgVVuJ7a3yZJlTHWuG+JnxYsPA9i+9XkcD+A18h+Pv2jtQ1kXQ055IDghd9AH3WuvWIYBblSfqKuJN9qXMb7h7GvzR8OfFzxVBMs1zfCRByVUnNfTnwb/AGgoNUaO1ulkWTgFm6UAfTaAhQD1p1Vra+jurWOZGDhxuGKlSYO2OlAElFKeKSgAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigB1FLRQAlFLRQAlFLRQAlFLRQAlLSUtABRRRQAUUUUAFNanU1qAEooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKa0qKcFgDQA6ik3DGc8Uo56UAFYPjLW00LR3ndtvBArd3D1rx79pi+ubPwfataqzkykPs7DFAHyb8afiRc65rktqshK7iOvvXN6H8Nb3xBGrRxlt9YetYvNb8wnc275vavsP9mvSbDU9LWSTYzRruxQB8keJPBd94RYrNEyqPaq3h/xFLpsu+3Yo49DX3H8dPhfZatoc1zDAC23ORXwZf6fJo+uSwbCAGxj8aAPuj4HfEr+3tPs7WWTc6xhTk969uuWKMpHQ18Rfs3XF2ut4KsE3ccV9wQKJrWMtwcUATqxZFJ9KWkOFwOnFIZFHU0AOoqPz4843jNPVg3Q5oAWiiigAopNw9aWgAooooAKKKKACiiigAooooAKKKKACiiigB9FFFABRRRQAUUUUAFFFFACUtJS0AFFFFABRRRQAU1qdTWoASiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAqtNEsj564qzUcbKu7JoAjDdFApJEmE3ynEePWpy8aKWry34jfGGHwndSWu4Bgm7rQB6Rd6haWMe6eRQcZOTXjPx58baXdeFzbwzKz7jkA+1fP/wARP2h73UJJI7eUjPHBrx/UvG2ragxa6lYxMcDNACagscd9PKvds16t8C/i9H4PkKztti/i/OvGftHmH5j1qveKLWNgrFd3HBoA+8de+P8AomseGZYo5EJZf6V8aeKNUt9R8SSyxnILViabdSLaeWJiRjH3jS6foslzdbwSTmgD1H4W/Fi18K35DRrlDjJzXtkn7XVjDtTavH1r5Lh8M332iQpExBPBxS3HhHUC24xvQB9laf8AtZ6PcKvnBVb6Gus0n9obw/qQAMiDPtX57ahpM9rO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UUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFACr1qpc/8eN1j0b+VW161UuP+PG5+jUAfn1+0Rn/hLJvTea9H/ZQaJZhgjOa83/aK/wCRrm/3jVb4BePl8L6gfNfA3H+dAH6MbQ6juPenrgDA6Vw3gf4kWvia3QI4JxXcR/d9e9ADqKKKACiiigAooooAKKKKACiiigAooooAKKKKACqVx8tyv0NXao33yyK3+yaAPgP9qqbd4+IB7rXjun2bXevQxjnL/wBa9T/akmz8RMe61yXw904X3imDIyN9AH3j8BdFbT/CsBYbcrXqLJ826ud8CW62Phe1UDHyj+VdGrBlH0oAKKKKACiiigAooooAKKKKAH0UUUAFFFFABRRRQAUUUUAJS0lLQAUUUUAFFFFABTWp1NagBKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAQ5I4ODTWg3QvGTncOaWTIU461Xj3+Z96gD57+MXwMg8Q3MlzFa5lOTuxXx54o8NXfha6nEULReW5H5Gv1PkgSaPDqGyK8S+JvwTstWt55Y4V3NlulAHx38NPjNq3h26RFvGjAr7C+F3xwXXdJiF5dCSctjJPNfIvjv4USeGryR1QqM1zPh/xbe+HdVjijkYIpB60AfqNp+ppqNuHjOcjPFTw+Z5jbjkV4D8EvikuoWsMU8vzYA619AW1wtzCJE5BoAlooooAKKKKACiiigAooooAKKKKACiiigArO1IO1vOw+8oO324rRqOaMSROp/iBoA/Nv8AaHjuJvG8ss5LYbg4964/wPqlzaeLbMRSFQzZPvXsn7VGhCx1x5duMmvF/BWz/hKtPLHnP9aAP0s+HFw934ZtzKd5C9/oK6qE5j+lcr8MQp8L2+Ofk/oK6uEYU/WgB1FFFABRRRQAUUUUAFFFFAD6KKKACiiigAooooAKKKKAEpaSloAKKKKACiiigAprU6mtQAlFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAB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"
    icon7 = "/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAJqAmkDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9U6KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACoZz8pAPuR61NXPeNvF2k+BPD99r2u6jFpuj2ERnuZpeioOpoA1kuTtAZSjHhU65qa3k8yPO7cc4PFcP8ADb40eC/i94ZfXvCPiC01PS1kaH7Qrbdrr1GGwa7G31K1kVFW6gd26BZF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"
    icon8 = "/9j/4AAQSkZJRgABAQAASABIAAD/4QCwRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAABIAAAAAQAAAEgAAAABAAeQAAAHAAAABDAyMjGRAQAHAAAABAECAwCgAAAHAAAABDAxMDCgAQADAAAAAQABAACgAgAEAAAAAQAAAligAwAEAAAAAQAAAlikBgADAAAAAQAAAAAAAAAA/8AAEQgCWAJYAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/bAEMAAgICAgICAwICAwUDAwMFBgUFBQUGCAYGBgYGCAoICAgICAgKCgoKCgoKCgwMDAwMDA4ODg4ODw8PDw8PDw8PD//bAEMBAgMDBAQEBwQEBxALCQsQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEP/dAAQAJv/aAAwDAQACEQMRAD8A/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Q/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//R/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//S/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//T/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//U/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//V/fyiiigAooooAKKKKACiiigAooooAKKKKACio6KAJKjqSo6AJKKjooAkoqOigCSo6KKAJKKKKACi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EVj/AGbrFxaf3Gr9Q/8AgnL8Xf8AhFvGVvpN1JtWeQKPqW4r5D/am+HUngP4gXdv5TRpJKa4z4C+I5PD/wAQtHvPN8tEuI6AP7c9H1G31WwhvLf7kiVsV4R+z94jt/Efw9064jff+5jr3OgCSiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKjoAkr8+P27vibb+DvhpqNv5ux5E/vV9+XdwlvbSzv0jXdX83//AAU0+Mv9raw/hqzl+T95/FQB+OvjDVZNZ8Q3d/I+/wAxq/Rv/gnl8L5PE/ja11C4i3pA++vzHggmvbgRR/O71/Tx/wAE2fhPHofhhNYvLfY8kNAH6u6Hp1vpumwW8SbPLSt2o9g24qSgAooooAKKKKACiiigCOipKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/9P9/KKKKACqs6JJC8f99amooA/Az/gpT+z15ltdeLNPt/8AUeY/yLX4LWk9xoeqpJ9x4Hr+2745/DXT/iN4L1HR7iJZHuItlfyG/tKfC27+HXjq8haDy7dpH2fTdx+lAH78/wDBOn4z23iLwvbaLdz/ADxx9M9gtfrOjfLX8d/7Gvxs1D4c+ObK3+0MkEk0aV/Wr8PfFtn4t8PWuqW77/MSgDu6koooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiimfc96APKvjB4sh8J+Db++ZtreW+PrtOP1r+PT9qDxxJ41+I17cebvSN5K/fj/gop8cLfwr4MutDs7j9/JX8xWq3U+s6vJcH53negD339mb4WXvxH8f6XZpF5kDy4ev69vgh4Es/BHgmx06CPY6JHX46/wDBMv4H+W6eJNQtP9X5bpvr97oIUgiWOPpQBZooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP//U/fyiiigAooooAjdA64evx1/4KDfsvW/irRLrxRo9v+/gTf8AItfsdXMeKPDmn+J9Kn0vUEV0nTZzQB/CzNBqngjxDiRGgntHr+hL/gnz+1fZ6rpVl4X8SXex9kafO1ec/tifsHW8Caj4s0PbGn7x6/GXw/4m8QfCfxUkmn3DI9vNQB/cbZX1vfQJcW770erVfmz+wr+0f/wtTw3a2eoPvutlfpNQBJRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRUdABXGeOvEtn4Y8OX2qXEuzyIXeuzkfYua/IT/goN+0nb+DvDc/hvS5f38/yfJQB+Ov7bnxpvPiH4/urOOXfBG8leBfAn4Zap8Q/Gdlp9vbtIjvWX4Z8HeKPi34z8uzt5J3u5fv1/SR+xV+x3pfw80e11zXLdftWyOgD7B/Zu+G9n8PPA1pZxxeXIYvnr6NqG1gjtIUt7dcInFTUASUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH//V/fyiiigAooooAjqSo6KAPkL9sLxFBoPw4v2lH+tgkX81Ir+Pnx3qseseIbq5j/jev6v/ANvz/kmV5j/nn/7Ka/kin+fVz/v0Afur/wAEqdL1D7Ta3Em7Zvr+g1Olfjp/wTE0qzg8JWtxGnz1+x1AEdSVHUlABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFR1JQB5X8WvF3/CH+DtR1SNGd44t6bK/mU+JGh+Ov2kfi++nw20otVkwSy9Bu9K/qT8VeFdP8W6VPpWo/wCpnTY9eVeC/wBnTwH4K1V9YsLdWmf/AGaAPkz9lT9ibw/8NrO11jWLdZLrZX6TWVjb2MCW9umxEqykaQrsjXiloAkooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/1v38ooooAKKKKACo6kqOgD8yv+Ciniqz034e3VnI/wA8ibK/lYgj8/Wkjj/jev6Pv+Cn3mR+GH+ev5x9ATzNftB/02joA/qI/wCCcHhm80rwHa3EifwV+qVfCP7DFp5Hwxsvk/gr7qoAKK+ffin+0J4K+GP7vWL+KB/9pqy/hl+0t8P/AIkukel6nA7yfwI1AH01RUaSCRN6d6koAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACo6kooA8c+LXxX0P4XaJJqmsXCw7Fr5M8Fft6/DvxNr39jyahF+8fZ96vPv+ClF9cQeAl+ztt5b/0E1/M1o3inWNK8Uw3tvdsnl3H96gD+57QNf0/xFp6ahp8qyI9b1fnx+wf49m8U/DmIXU/muoUY7gBa/QegAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//X/fyiiigAooooAKKKjoA/Af8A4Kk+MZI7Z9L/ANuvw9+HtkNS8XWEL/xzR/8AoYr9hv8AgqYn+nv/ANdq/I34TZ/4TXTv+u0f/oYoA/sK/ZZ0OPRvhzYxx/8APIV9J3x2WrmvDP2d/wDkQ7L/AK4x17nef8e0n+5QB/LX/wAFGPGmuHx5dWcdwyIk1eLfsX+PfEVl8QLOxinOxpEXr2JUV3v/AAUY/wCSk3v/AF2rwv8AY9njh+JNp5jYHmL/ADWgD+xXwhdSXeh20kn9yOusrifATxyeGrJ4+8MddtQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH5Pf8ABS9JP+EBXC92/wDQTX8vF0+3VJJPSX+tf1w/t8aBb6r8Mb2SdfuQyV/Jh4jgS18QXUUfaWgD+jT/AIJd6pcTeHVhlbt/7LX7RV+J3/BLj/kBrn0P/oNftbQBJRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH//Q/fyiiigAooooAKKKKAP5yP8AgqZ/x/v/ANdq/If4Uf8AI6ad/wBdov8A0MV+vn/BUv8A4/Wx/wA9P/Zq/IP4Uf8AI6ad/wBdov8A0MUAf2Xfs7f8iBZf9cY690vP+PaT/crwv9nb/kQLL/rjHXvF0m+FxQB/J/8A8FGE8v4i3v8A12r5H/Z5uXtviJYKrYDSxg/iwr7v/wCClnhK4s/Gc2ohPkd6/Oz4MMw8e6YFGQZowQf94UAf2hfBOf7V4G06T/pjHXsdeB/s8Sb/AIc6X/1xjr3ygAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKjoA+Bv28dRjtPhdqEcn8cMlfyTeJpPO8Q3cn/TWv6tv+Cgt/aQfDW4jmbY7hsf981/KTqMcd14kkjj/wCWktAH9EH/AAS0/wCQE2fX/wBlFftlX5J/8E1PCEumeDVvj3C/ov8A9ev1soAkooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9H9/KKKKACiiigAoqOpKAPwc/4Ki+Do59NfUP8Abr8FvCWovpXiO0uf7ksdf1J/8FEfA/8AbngC6vI08x4031/KnOkljqn7z/lm9AH9g37FXjuPxX8OrL597+VX21P/AKpvpX4xf8EwPFsmpeG7XT5Hr9n3+5QB/OV/wU+/5Clfkn8GP+R+0r/rvF/6GK/cb/gqF4D/ANG/tSNP4N9fhz8GFZviBpbKOBNGST0A3CgD+yj9nn/knWl/9cY698rwP9niMx/DnTN/XyY698oAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACo6kooA/KP/AIKXyPH4CXHXLf8AoJr+ZDQ7b7d4vtbb/npdY/Wv6av+Cl//ACIS465b/wBBNfzgfDDTf7S+I9hb/wDT1F/6GKAP6t/2GvDP9jfC2Jz1cKfzWvuWvnf9mTS/7K+Gdjb/AOxH/KvoigCSiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/9L9/KKKKACiiigAooooA8h+MPw+tviJ4UvdIuE3+ZDIlfz++OP+CcHiSfxU8mnxN5Mj/wB2v6XKha1t2beY1z/u0AfBn7Hf7MsfwW0SD7RFsnjr75oCIn3eKKAPlr9pb4E2fxm8NTWFxErvs2V+bPwh/wCCa0fhnxUmsahb/JA+9Plr9y6Nka9FoA5fwl4ft/DWjwaXAmxIE2V1lR1JQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFR1JRQB+Uf/BSuF5PAK+Uvdv/AEE1/OD8NtP1pviHYtYxkMt1EST0A3iv7Gvjv8GdL+L/AIdfR9QTfXyN8J/2APA/gfXv7YktPnjff89AH1T+zH/aH/CtLL+0N2/ZHX0hWPoej22h6emn2i7I0rYoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//T/fyiiigAooooAKKKKACiiigCOpKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/2Q=="
    icon9 = "iVBORw0KGgoAAAANSUhEUgAAAP0AAAD9CAYAAAB3NXH8AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxIAAAsSAdLdfvwAAMJ8SURBVHhe7Z0FnJXV1saH7u6QRkXBRMHuVuxur3r1mtfW67WujS1Id0oo2IrY3Yp0w8DMEMPA9AzwfOu/h8V9Pd8AE4ByOevH5pzzzhs71rNqr73fBMUpTnHaqSgO+jjFaSejOOjjFKedjOKgj1OcdjKKgz5OcdrJKA76OMVpJ6M46OMUp52M4qCPU5x2MoqDPk5x2skoDvo4xWknozjo4xSnnYzioI9TnHYyioM+TnHaySgO+jjFaSejOOjjFKedjOKgj1OcdjKKgz5OcfoL0vr160OB1q5dq/z8/PAZJf97cSkO+jjF6U8mB3gsiKO/+b5u3bo/nBv9e3EoDvo4xWkHotKA3SkO+jjF6S9EaHPMeNfqfI+CPA76OMVpB6dNAdgB78RvFwguFEpKcdDHKU5/QXKQxxLHSgN4KA76OMXpTyTX5oA8OztbqampofAdWrNmTfi+KYugJBQHfZzi9BcgwP3rr79q/PjxGjBggEaNGqV3331XM2fO1JIlS5SZmbnhzP9aASUVBHHQxylOpSCAFy3FJTfV58yZo0ceeURdu3ZVx44dw+dhhx2mCy+8UM8884y+/PJLJScnBytg5cqVysnJ2fg8PmNNfv9bXl5e+HSLgs846OMUp1JQLND5HS3ugwO26Lmxmnru3Lm6/fbb1aFDB1WrVk21a9dWvXr11KxZMx1yyCH6+9//rqefflq9e/dW//79NXLkyGAVTJw4cePnRx99pG+//VY//vhjsBqmTZum33//XbNmzdLixYs3CoA46OMUp61IUaBHQR39DvF3J74vXbpU999/v9q2basqVaqoYcOGqlSpkhISElSmTBnVr19fu+22m/bbbz/tv//+4RNr4MADD9QBBxygI444Qmeffbauuuoq3XDDDbrzzjv18MMP65577tG9996rF154IQiEZcuWxUEfpzhtTQLchYE9Os3GsSjooYULF+qJJ54Imn2fffbRqaeeqiOPPFI1a9YMwKeULVtWVatW/YMw4LNcuXLBOsAyaNKkiVq0aBEExN577x2EA58nnXSShg0bFiyKOOjjFKetQLFg3xxFzyWnnu9paWm66667AkgB+913360rrrgigLhixYoB3Gj/Ll266Pjjj9exxx4bPo866qjwHU3fuXNn7bnnnsFacEuhcuXKwVXAGiBAuGDBgjjo4xSn0hKgjTXn+Q2g+cSX9r/xO1bLQykpKcEMb9q0qY455pjg359//vlBswP4ChUqBJBjpr/55puaPHmyPv74Y7333nt6++23NWLEiPC3//znP7rppptCHAA3oXr16kHTY/J/9tlnYZYgDvo4xamU5KB34jtTbETaZ8+evTGwNm/evFASExODZk9PTw8+NtF4Am3//ve/g4ZGKxO133XXXQPgXcsjFKZPn66MjIzgLuTm5gbBkpWVFe4zf/78MAuAQLjxxhvVvHnzcN25556rCRMmhGdwfhz0cYpTKSkW9Gh2AA+4Aepll10Wys0336xbbrklBNeIxL/44ov6+uuvQ4T9t99+Cxq6cePG2n333YOJj5bGX8e851ifPn2CoADwTNkhOHgW4Af4ABoiPsD0X7t27cJsAG7DokWLgiDi/Djo4xSnUhKgd+CjhSE0LyY3kXaCcfjWderUCVqbgBxmfOvWrUPQ7qyzzlKPHj2CD492Bqh77LFHCM5xfvny5YOpjz/O/ZmaI3Fn7NixIYnnnXfe0euvvx6OA26IoCC+fPv27TVw4MBgTSAcqGMc9HGKUykIEPkcPAWNC+GjDx06NIDYTfRddtklTL3VqFEjCADAT6AOkF966aUhGMdxpuLOOOOMEMlHWODXX3zxxZoxY0awCv71r3/pvPPOC0E8zj3xxBN18sknB0vhjTfe0KpVq/T4448HqwEXYdCgQcHy8NhCHPRxilMpCMA76CGABa1YsSKAvlWrVsFEZwoNUD7wwAO67bbbgrm/7777qm7dumGqjfn2vfbaKwAVHxxNDZjR1ggMsvNIwmHa7bjjjgvCpEGDBiHA51N4mPME8piWe/DBB/8AegSBm/9x0McpTqUgN+udEAAQ/jbmPWY6wD3ttNP0/vvvB7MfX59Eme7duwcTH23PVBumOHPsCIdPPvkkTLEBdgCNi3DNNdeEKDxTcwgMrAE0PpF6rAeEx6233hriAwgWrkEQcB80fRz0cYrTViLX8lFiamz48OEB1CTRYIoTVXfCx8YPx6dHa5Nvj1YG9HfccUeIwrPYhuAdwgDgIxgw5zmP6bunnnoqCAeCgkT8cR2uvfZaff/997ruuuvClB3P79evX7A88OmhOOjjFKdSkPv0sYSmx6wGdAD2oIMOCgE3zqfwdzQ/IG7UqFEAfadOnUJiDdF2ptewCn755Zdg5mPG4wpgsuP3H3rooXrppZfCCjyEC/EAfH+m+licc+WVV4ZAIO4FgmP58uUbF+nEQR+nOJWCoua9a3w+ATVmNb48U25HH330HzQ9guLnn3/W4YcfHoCMcOBcgnpM8wFm7kEiDuY792AKDyDjw5O5x5Qfc/PEDpji4xziASThEPgrTNPHQR+nOG1Fco0PsDDv0fRoWsx7fHPX9O5bY8JznHOI1KPlATPz+ETqmW8nIOczAAAeIKP1OQ8NDuiZtjvllFNC7ACwf/755wH8zA5wT1bl4U5s9+i9NzYqDamES8ko+TlOXMfuIe6TcA2dyvpi5iWJVkaXEbqU9N1HnGLvGx2kWBMtei7fY6+FCqv7X4283rHtia07v3eE9mxvih13fnvx3xB95zzEJyADbJjcBNTw6dHM33zzTQi0TZo0Kfwdsx4Nj9/uGv/ZZ5/VmDFj9Morr6hly5ZBaBCowxVg3h/wYxEwE8C9OJcFNUzvkbOPdUDgEM1PIJFluD6rAG1z0BfGSN5B/jc6ju/RjgSwq1evDmYJ0gxTCAn2wQcf6LXXXgumE7nGvXr1Cp1JUOPJJ5/Uc889F8yZ0aNHh9TDTz/9NJg7XEv2E+mQ3I9oJs8gwylaR+oVHcjCiL/7OTsKRft7S0TbONeZOE7FJ/zncePGheAaYGSOHm18/fXXh+j8JZdcEoJxHAfwgJhIO5l3f/vb3/Tyyy8HX55rATzf4e9//vOfG89Fq7O+nnl7BAJTeMwI4EYAeiwCBAo+f3TTjT/FvC+MqdDmZBuR1IC2ZkqDDCOyjmgYa43pDKYpkJqYNzSI4AedQMdRkGxMZxA4wXQiaYHOphO4lkAH0x7MZ/bs2VMffvhhkJYIAadYUPtvr3dRwfNXoFiw8z22LXx3in6P03/J+8v7LkpuwUb7k5RXQA+o0bho61q1aoVceAQB/jkmO9NsaHc0PryLtgfArKZDy3MO/IwpT94+Wps5fQQB/M65XEeQj/NxKb744ouwNJfnYt4PHjw41Mfxtl1AT6cgaSjuV0B0EH/DFGIhARKK5APMGxYfMHVBIgIdgGSjYQQxSHagE73QMdES/RspjEg8fCHPhMJ/IhGCiCcSl80GMJGwBnATsC42p+UKG/i/MjkzRgUA9Xd3KU6lo8J4ASuV3WyIsjPVxjQbnxS0Ob8BO0A955xzdOaZZ4bjpOdScAvwydu0aRPy9Zm+g8i4I7CHy4CvD3/D8wAcRYgVTPQeywCeR+j07ds31Ge7Tdk5k0WJY2j1pKSkMFdJpTBRSEVkbTDaG4nnDY8FNsAHvCQ1eMfRODoBQNNpXI9UpTMQEnQOphLXcj/uy2/uw3VITAQA9cDXYmUU5j9CySnalh0F+NSxMAHGMQQwxYUBJdqmzQm+nYXog9hxpp84Hts/fh5/J6b0ww8/BEuVJB13NynwPAVLgP3v8MHJwIPv4V/4lgJ/slrurbfeCgoTQjG6e0AiDkoR5QXIEQ7M0ePGMlsA73Mf8vpRZKQIU8ftoum9M/gE7GQkfffdd6EDML/R5ICWRkbBDTiRVphASDwSGZiaQDLiGxHldF+eTiPf+NFHH9VDDz2k++67L8x3/uMf/wiLFQh0nHDCCaGDkKhofX+GfyIQECRMo7CembgBVogPbuzg72hEOxh4UjIZAwKhMOZPP/0UCnPCuFZbsnR2VmL8vTjF/ob4Tf+hNNzCjSoMJ84h6EykHsWHm+o+PiY7vE7En620IBQQQWvMd8aL2BTxKl9TT/wKNxWFBQ+j2LAIsJxRsGCPemxz0HsHQDAcATl8dFYUoV0BHxLJgY5G9mSFgw8+OEg15i0JUKCBkZxEPhEaU6dODZ1GoWMoMDOrkTCH+DvPc2sC1wHpyvORkuwphkmEVYA14HVA0NDxBFqQ0twD88h9tx2JqC/1hgHpJ5iFPkQ4Mh1EaieFeAmbLxI78TYTX4lTARUGbLcCmUlCs0etQud5PimALWoh8N0j6vQzwWgAz4YX8CVK7NVXXw087ffiGkz0aCQe4jiChaA0RLAa5ebWLUoRXFBP7lV60NMXW8CBN5B5SQB3+umnB5MccP0X8GVDoGOfffYLUclHHnk0nItU+3XKb4FhM7Iyw71iH8cAhONhYJCofKdj8415fwygh5ERFAge6oJQQHhgETCniWTl+VHw02EcJ7ZAuiOa0RMceN6OQAwyDEGGF3ELgphM+xBMQrChDdyFIvbBnDFMh9mJJbaz0x95q6A/0aZsjoGVRBwIcNJXxIMceE5c54X7RPmGYwgKLCtiWATosHpJq0VrM0/vfrg/34n7MKbR4y4MsNjYfQf3mDF97LHHwtQ2iqv0oOd5AWf2X6ROfjg3zySUfVmyJEnTfp+u5555PkTUmWcsU64AWLVq1Fbrlm3U5YCDddEFF+ulF18x8+Rnpa5KD9eH+9j9c/PzlLM23+BsktL+D5/rCyTr2rUFnQfI7VsoOXmZSlm+VFdfe6UOO+JQ7bXP3rrkskvVt38/ff3tN0pNW6X8dQXzqVOmTAlTfwgjZgTorHIVyiuhjGn9alVVr0F9dT34ID3y6H+CAEpZvsyeXSB83O/3gY0dnD+LosyFSUj0F6sGy8pXbnkQiAJzUAA/gpioL8Elch+caFv0vrFUWB/EMnn0b5v67sQxGNk1nZPfJ/aawo5Hf3tdor/dz4UYSwrk56JpARdBOSxN3EmsIha6EH8iqEbeO4IUFxLBSpTdARiti5Mf80/SbQEmihC/HmWHICgOcS8EDu4ZEXxmq4h3IdCxlhlH78dSg35drjWOulvJz1+n/AKch7LW+m3+vMUmDb/UP2+5TYcefIiaN222geHKhs+Dux6ka668Si+/2MP8knetctO0YuUqA7pdb/cA1tHCMUDvxZ9VUBAGecpfn61Vacs0d95MnXDiMWrYsH54Fm4DZs9DjzysyR9/pFlzZoeOYOCxQgioIHE5Z5eWLVS3fj0TTqYJy5dToyaNdchhh+q2O27XhDcmata8uSZYcjeCPpahoO0dHefZUYaiXkxHEptA8jOP65YMn1hantaJMGAayWMcHMfUxC3CwoGcafw53H9L5PUpjLgevxQ3jOATlhe+KQU/ld8cpw2uqQp7ptcnSoXVL1p/p6hAAag+jgCIupELQvyIwJhH3bGG6C9iTViHBIMRpMSdAP7zzz8ftD7mdJQKqyMEwIlHAVLvc+IuXpfNUfQc8usROhdccEGoI+PLWOK2YfJ7f2w9894Kbcgz4AP23Nx8q/hqffLRpwHwBx9wkCqWN01ilaAi9evX1Z4dd1PvXi/p4w/f1aKFc62T0pSVn61cgy6xSgpbEiB7gQ+Fav9Xn5sFYL+RqQW/sQwKzsjOWqPkpMW69ZabtM9ee6tGNWNocyH4JCB4//33GcgnhsGl8xl8Ah1MHTIXStSUfAC0IdIyoayZv5Uqqv1uu+q007tp8NAh+uSzTzduQRRlsMIEwLai6DP47r+pAxoEwBMQQuA52CnMcBDsIciJhcPuLQQ6YVzOoxD5ZR91LCHux739MwoWyJ8dW5y4jr4ioAQDAmpcLoKx9PVFF10U8inQnhSi0fxGo7J4hKWi5Fbg+wIK5p7JOSf2ADgZO6fY51L8e5Rij/t1jCWxD54D2LH+3A0NvLChfyjwhwtK3EEEK7NBbFcF8J1i+8N/U4gHYEEwLY3FwE43HnQrDuG3cx/iYQhw6oz1Rv/S5259bJVAHjfz9gB4ytKlyfp48if625VXq8t+B6p65SqqUKasylnntGq5i844o5teePEZG7DpppWTlbcuywCcayBfpwyD7mq7V5qVlVZIm+E3cpM3eiEMXABkmpltBpoJBrMy7BNtb8Oo/Owspa1Yrk8+nKwH73tAB3Xuqib1GwfgV69aTe3btTGGOidER/Hv0SJODALJQTAVswt0YuWqVYLWx+Rv2bqVzjz7LD38n0dCZyJhGSAfVD5jQbGtyJ8JRZkE64UoLqYogUpnUhgUbYVvzzQSPikalRVfMBtCAA3GuUR+YXiYHz+WNvnzeBaFY1g0CE9cJawC4i8wIGYx5ib1AOSYnYABQYJAZc4aIcM0FdoStwqrwy0Qtz7QpsQgEFRoMOrPmCC8WUJK8JE6MpY8C18YLRvtm8LIxwiQu9DmGqw+tDWCBxAHd88Epbs+9Av19bwR71e3ojgfgYrlyDgURj5WPA/eI9iGpqdNuBEIyKKS3wu+RWERo8JioK+ohy/M8fZuFdDTtV6oANHI8WPH6fq/X6c2LVqqcd36qpBQRuWt7Na2nc49+xxjuJGa8vvPysnPMLDmGIjzlW5gXWEl2Xx4JikwKhOtLLQbzzOUL8hep6U2NqvsGAIAmGIFICTScrOUsmqlFixaGAIZH30wSa+PeU39evbRDVffoEO7HKYalaurUtmKQfBUr1xJzZo2DgyIdGQulI7xwcdsx8SCkWAqZhKQ5C7V0YL4XzAxgHFf0DvWP7cHOXNHmRwAkqhBEhLSHoZEKwEwAnUEJvFXuYZAH8yJlUNE37U91/n67gLBXnB/mJT7A2gEBn3Hog/iBkwP+bQpueGYlggSQE5/cT8Aw715xkZLyr5T+M6xwgp/878DNsDFvWgTQgCtzKwQACKJBW0NEGhfYX3k5IILQngR+CV702Mf9B3gJ/BJsI1ZHQQClhGgQjDCG94m6kgAmFkRAn5RXvDnR0FPX8JHCGcEGvPqUSW0JfJ70QbiN/AjMSpmAMjfJ4DtlhDPKzXoCbDRDAJbBMaoLIxww/X/UNfOB6hq+YoG9gRVNA3bof2uuvziS/TOW28HgKWbNs4xkCPTVtldkuz7ArvZjNz1+s0w9JtZI7/aWPxoJ3ybmq3vV2ZpWsZaLTBcJlpZlJmrRGvMjMRF+vjbbzRy3Bh1f+Y5/eMfN6rbqafrqCOODQHCtq13Va3q9VSlEia+mWNWF9yMqlUqBWlIgAs/CG3hQIAQAGgrMpzYyZTUXrRPlEE5RqCEpIjo4Ea/b2uKZWSYAOsD0x7tEdVCmPmsw6ZdsYRvSRAJbeNtBFT4qfjVXIPJClOxvoE8cGZaECIkiQAImB2hAbiZgqJ/AQyg8HtSqBP9578BMiBGq1M81sA5XqLXF1a4J9ciXHALyLUA/IwN44rgYlzoLweKk/8mCEeGJkD2+2KuIwQQYvQpkXosFxJlsAYRbOxmg4Xi/YwVgCWD4EWQOPlY+Sf1YayYLeGZ8CLCE0FQFKLesXzH85j7p91YLbHPLzXoqTpmNUGtpJRkY4h3zYf4h/bqtKca168XNHyNSlXUoW17/f1vV4dg3eLEpUrLyAz++tLcdZqXt04zc/I1zQAO0L/MWK9JK/L0zvJcvb0sR2+nZOudpRmalLRGny/P1FfL0/XxgiS9O2W6Xhk9Ro8895wuNyFzLKb4PvurUePmql6jjmrVbqD6jZqrcrXaqlazgRo3a6V27TuoXv2GgcFca2NCwigwcVQyB0awBq5YtlyffvyJ/nXvfSHwWL9uPZW1dpUzd4XBJTeaTD78SzQmwiIWiNuSYp9F/bFSMBPdtHctBCiJRFNH2ucFgjkw+YlIO/MCRoQATIkGYu0CGhXfE60EoNGIUYb3Qv8Cdgcsf6evETwIBkCBpiTISLSZe6OpL7/88iCEiTPwN3x8PjmXSDnXMbtAtBs/mIQqxtOficDgGfwdYXT11VeH+gNU4hMAyjW79wNEP+Lu8GyEHfejv/iNJQOIyAHBdaB/IYQJliXjT3IN/cV17qZgJRLH8DGKHSsEEVoY4URGKjvfoDSjQC0qeTsgvtNGbyfkfy8V6Kk+Jc+0fHZujr79/hszBW8zJtlLDerUDhq+ZuWqatG4qS4+7yJr2FuaMcc0fH5BoA4DZo7VY4pp7W9Nm3+StlbvGdhfW5qpsUuz9NrydXo1MUtjEzM1flGaxs9N0dipCzXwix/15Jg3ddeLvXVotzO0+/4HqFqDRkqoYP5VGabayqtKzbpq1tZ8P9P0hxx/so44uZtOv+gynXPJ5TrkyGPUrGUr1ahZOzAJg+Ogj86NBrIGrl+7TosXmjUx+SPd+I8b1GG33VWtSlWVL1tgMuNrYv7jB8IUHjDZXsAvDPT4hL4xIyAAfNSVCDRM5W5MlBBYJC+RL+4CEaCiPUmkAuiAFhC7LxtbOJ/+5BpiAwgFQAlIuR4QooXRjgTn2OwRhmfhE5F6AEScBN+cZajkaXz11Vfhk3ojlOhnAoDEJbAyMLcRvIwDz/a684kw4DiCi2AhWhxNjcmLewK4MP8h+gTTHuGCkKSd1JcIPvXy86IAptDX1A/BhCVIH9Df1IVnYj1EtbGTAxMirsQCMCwJrODi8k4U8H9QWhuIY86XxQZ99EZUi8AZU2dTpv6mhx550EyU9qpWvZKqVaqoKhXMh2zUWHfccru++vI7paxYrXSrD94Fs5D461+Yc/5OqjQ+OUejDOAjDOAjluaEMnJJtsYm5+nVxas1dNpi9frqF905YJTOuuPf2v2EU7XLgYcooWY9laluvleVmqrRqImat9tNnbocFAB+ze13qcfIMRr69vt67fOv9P6PP+n9b77XSwMGqfPhR6pmvYYqU9bMyurVtEfHPXX5lVdo2ozpBS7Lhk7fqBHz1yotdZU+++RT3f7P29Rxjz0D8GEuQMUAY9KiUZDsDirvr1hG8e9bm/y51GHIkCFB21FH6kcQiuQPmBCAR+sGU2DlACo0a9SNcSZ2LeaF+wFotDYaEQ3MJ+DG54XhiREQdcfXx/IAcIAY87MwF2NTRB1pGyAlZoRwBbRobuIT+LDkngM86oDQoY5uZQBiT+dGQBPsIshJEgz3QHtjAZBoQ9CQ84kTEBgjqMszidtEYxuQ9zdtQZDRzzzPwY/lwvXRa2LHnb5HoCA8KHwvTEhsLdoi6KlgFOixBOgXLl2k1yaM1/kXnqf6DczUq4zfXBAsu+SiizV8+EgtWJKiNdY/GEVJ1uZZ2evMV1+nd0zdjzHQD0/O1+DEbA0xDT88KUejrbyalKVeP8/TU5O/090jJ+j8B59S+xPOUL19DlSFFm2VUK+xKjZqobot26vtXp11TLezdM3Nt+vR51/UqHfe14e//Kr3f52iL+bN17dLluqn5BR9v3iJ3vz6G1175z3a/7AjlGCMXN7qWb9hAx1+9FEaMmyoVqSuDAItgN3bHg6sV5LdZ9yYsbr4wovUqkXBBgcMLgXQsy4APw4m4FpnCh/oaH9url+LSn4Pv7//hkkBMBrWNTOFGAQCAfK64MtzDAbHFIbZHeCuNbkHbUTT4zIgTLAaMMUxbdFQaElcBzQ3/i7MjuWECQygMGPRbDC0ly0RdfS2FUaAkGAd/Y0gQaiQa4HQIYKN6xG1SmgH4Ecw0BfEK9z3x9KgLbQR4DNliMWBz+0UO2a0iXZwDqY8AV6egyKgv7gHFkq0rbHt4Z60A7BT+B77nK1JRQK9M4dTdCCycjI1afIHuvbvV2n3Du1UqWJZlS2ToLp1amm/ffbVmDHjNGPughBlJ+JORH6GWTRfrcjUW8npBvJM9U3KVj8rQ1IM7MvzNSrJjs9OUv9fZgewX/TI09rztPNUsV1H0+wNlFDRtFCFaipTv6l2P+RonXjhlbrniec05t3J+mH6bM1YmqL5q1drQWaWpq1J1wzTalMz7HtmtqbZ588pyzTorXd10/0PqoaBvUwl83fLl9MubVvrsquu1Lc//mDWi7XTCgHKghSgAqLdaJlePV9Rt1MLdidxfxltiI+JpsS0ZvoKjerXeZ9tTYKZovf17wCZJBcY3+uIqYs/jrb089D6mKasbyAaDeA5D4alTVwHCDDTEWqY+WgvIvS0kUwvAAfzextj6+RU2LHikN8/Sv6bZ1LgU7QlACZyjbVBmxFShbkkHMNaoe3sOoMQwJ/nfFayOQj9/lC0Hmh/nomlgNtB4NTvi4Ch/7EeuEeU/F5O3I/7UGLbuLWpyOZ9LOidZs2Zqf889pB2272tqteorArljVGsdN5/35AUMG3WbK1Zu34j4KeZW/Tl6jy9nbRGoxNXqf+SDA1YlqfhK9dq7Grz4VPS9fIPU3Xb0HG6xIDcods5qt5pPyU0aGYmvJnxFc2nbNJSrQ84VAefeaEe6jNY/d6apE+nztG8VVlaYQIl1foz1eoYXAgD7czcHP1gpvlPNjC/pmfq59TVmjxrnoa++4GOP+ssVa1n9y1nWqByRbXZfVc9+vSTSiLV1q6npd5abzcDNuXX3zRowMAQtWXe1jUiAEMTksKK34gWgrg2OtBba2Bj7+O/eS6MjykL81E/TE/SoGFQgMFcOuCFudF6BCVpA+fzSbvwh3EJmNokJ5y5ZyL4aG9vG1RYe5xn+Fu0lJS41oHhIIzypf8N4m/MJBErIAjHFCIBOfqDWQXGydtK32AREBcgUo+WJkjJjM2miOdE20NgD9Aj9LkvQpP7ElMh/wHhAfn5bgH+GVQq0CO9vv76S1162YWqV9cY3xpLadmiqa677lq9P+kDJa1aHabkmID4PXO9PkvN1tvLszUycbWZ86s1bLn57Gbij0tbpxGLU/WC+e1XvdhLe517iWru3VkJdUyzV64WfPaE2o1UY4/9dPgl1+rWF/rpuQkfaPxvs/Xp4hWaY2DHdSBegG5dY9V14C80s/yntNX6weryY3qWWRmr9FXKSn1qFsh9Tz+l+i0RKKatDfjVG9TVcd1O0efffi0yA4FpQdKP9cGGTwpmKowPEAAMA80gU2AkAkcs5gFYTjAi5My7LcjHBgsDLU5EHCZ35mZOG3OTJZlMQRHAREjxdwcC5+EWYLHgi+MmYObSXg88Uf9oe7xEKfZ3lPhbUfpgc/dwoh5RTRqtC59oY9J4CQwiANDoaH/a6L4/Be2MW4PFhvmPoEPAuXBzoEfb7Z9YPNwXa8j5AOAT52C7Ku83v8ZB7/eMJY5tKx4pknkPeQX8Nw1PTFyku++5Xfvs21EVKxQAvnq1ijr8sK7q16+Pps+epdX5a4OWn2/99MWKjGDSj0427b4kPWj50SvXaUxKnvr8vkj3T5ik8x7prvYnn6GEpq2UUMnATqlVTzV231t7nHKOLnv0eT3+xsca9NM8vbF4jd5IXKnJy9L0S2a+gbvAhUCmUgA/wMcjm52br19My/+Umacvlqfpq5Vr9M2yFRo16X0dePThqlLftL1ZKAlVK6pO00b6zzNPae7ihcpdtzYUWk0B+GGxzYZ+IG+c5JXovC4FrUliDFt+xS6eKGyQS0vcM3pfxgsznnl35n7dGkGLkTQC0zOvDtgpzvQICDS7R9Yx3QtLFNkcQ8a2j9+cD89QSsrM3sZocQBGieOQ/43f/kzAR8CS5cXkuyOw8d8BqLs0FI75ijeSjxAaaHN/LuTfEa7MreMa4ApxPfeir0lxZl9H6uLXQV436kWJ/o3vfnxbULFB7xVE+n366cdmxu+thg1qC8Djyzdv1lBXXnGxaYbvlZaVsVHL/5aep/cMoOOWrtHwZVnqa/57v+SCCH2vH+bphr5j1PWqW1XvgCOU0HAX07wmgWvUVfPOXdX2iGN0xm3/0u0DXtUzn/ykfjOWaazd9HVD+Nhl6ZqYvFKfp2ZoWnqulllfIlPzrdp0a2pOnh1bryX2e2b+Ov1uAvaLVZnh/C+WrdSXs2fq5n/fo+a7m1lWvbK5D2WDALjqhus0d+li0/Jo+oJ7UeiNjcC376SnojV5N5lHygEXAMJkxEQkmaUk865FIR8fPv075N+ZW8a3ZeoJRgbgmLAeZaauHENDkTWHtgIQTCExdRSlKONG+YHjsUwNbSumjaUogCD/DXEsth5oWQQZ6cLEJXy5MX3gkXsHLtF++uXOO+8MZjpJStG0azLgmJUgYIcrxHUU4iLkChAYRDFAsfXg+i2VbUFFNu+9AlScTsVsHTFiWEjAKW9mcTnTkmXKJqhd+1a69967wwo2tC06YrFd+uXKTI2dv0yjl6Zr+Io8DVyer6HLctX/5wV6cOS7Ovyq21S23T5myptfWcm0bpNWarhvV5116z268aV+6vHZzxo8I0mjU/I1ZNk69Ular5cWZGiwCZFXl5ipnpYVMvnI0wf0ppxluFSWIXZFdn4w85dYmWvlOxMOn6dmmuWRqnem/KqnBvTTbl0OVBUWpZQvq2oN6uvY00/RTzOnbsjpJxfBmMWEB71AYVkvxj/9QYQahkBzYhoGjWECkNV55OmzJJfMKJiNOf+wFNkolgm2FjFWzviYvcQWMNMJwsGQPh0H4Kkv0Wy0FFl2AIGFOtFZBx/7KBOWtO7R+5WGCquX12lTv6FovfkOgBFw5KcTh8Enj5r8FAQkAp3+YwqSmQmEPX3LbAVJNQh4t5hwk7D0uAZLK3aVolO0Lt4eL9uSigx6iMpgHhEEIlnhb1deFZJvyGXHHyYKfnK30zT61fHmU7IIxoBmyP/N7OwJC9M0aNYyDVq4WmNWrlff+avU8+e5uu7pHup07KlKaNTatHsdJTRooQp77K9WJ56j8x97SQN/nqdBM5M0bFGGhtjN+lrpuTRfLyevU6+U9eqdmKExZjl8lrFO04xPTR6E5wayvss1tGZaXyMMyOefZ99/t/r8sDpX36zK0EQb8BFff6UzrvuH6rfd3YSOmWflyqtVxz10w9236/Off9Qvs2Zq1txFWrwoWWmp6SFSzXp98ySVnVuwHnve3Nl6/LH/mBZtamAvE/ojoWI5VaxeVbt37GTM8rBSkpaFOoViIoP1/6UlZ6Qoo/gxPmE4QE/EnSk2zHwHPJ9kkeGekGoMI7vvCUVB49/59GdFmTbK0LHMXRRCyETvB/lzom1z4lhhx0tC1JcpRXx+wE/CDxoegUg/IcQBNKY7gTmsJgKgvCMeC4GYCJod6877lpgA2XVMnRI49T6hznzfXJvoh2hBwbIGhJWF5BT4eSWlYoEeosKY9kRxjz36GFUrW0kVEsqpUrWqarfH7rrl9rv05Tc/ylxoYdCSJ//pinV6LSlHA+emhvn3QfNWqftX03RDv1HqdOLpqtaijYHNmLHFrqp9wOHa/ZzLdfnLQ/To5J/s3DQxfz/U8DLY1HVfc9B7pUg97XtvM/EHWxmzcp0+XLNWvxm/miwIvnwg06go1mzrHywONn9aaH0/NT1f36Ss0UcLkzTUANH/40919j9uVYN2expQrR7lKqpm40Y66LijdNsD9+tfjz2uhx/trqeffFlDBo7Qhx9M1vRZU5SetSpMWdInudk5+uyjybrowvPVqo2Z+Wb1JFQ2jV+poho0a2Z+9N/1w9ffG3dbhYKmh8H/yOQlIR/8KGD4jhYigEXiClloLK9l2g2mJFgFoxLEw2clsEfcIZaZovf045v6e2HnFoUcDBDfYwHB98J+R49tDeJ+gBOtz5w9i7BYU0Egjn4D+IAaLc5vZkHYZhptju/uQhThwDGWAzNVhxvBOHh9+aSN0f5y8nbxNy+4hSQQEYdhnQO5FARU/fySULE1PVFhkiCYAmnSqHHIraeQlHD2+edp2PDRIfMOfYF//ZP53e+lZGvs0gy9nloA/h7fztQFT/VW29MuVEKdJkqoakBr3EpNjzpRp9z3iO4e/65e/GGWhpOok5yvYQb0IQbuQVb6GvgBfW/77IsQSMq1czL11sos/ZCZr0TrB4QNsdywCMg+061/F2fka+qKDH21MFlv/DpN/T/4TM+Om6jbX+qpm5/orkNOOkvV6+2iMuVrqGKl6qpYtVoI6DVr304tO+yp5m33VMs2e6pLlyMM2JeZpH9EY8aN0i+//apFiYutc6TlScl6dfRIA9jhqlEX4WHANyYoV6myjjjsSA3sM0AZqWlWMQbcS+nJGciZgN9oGNJZ0VpMU2FuuibCp+c4L1QIC58i8QZnNsiZ0MmPR8nPCa7LhnNjPzdH0edBfr/CyP9WlPsWlXh27P185oPkIjQ/YCN/Ac3vmhxwM5/vlhOF30zhIiwQHFgP0X6B+O5tjn0uv6N/pyCEWPOA+8CMEDECxpb7Rq2y4tAWQR+VxBAMgvagI2pWrxHy6wF9+7btdM899+n7734OQTQCeHPNtP8sNVdvWRm1JE0TzZcfOi1Rdw6eoF1Pu0QJzc2cZu69eVu1OPY0Xfz0S3rmsx/Uc8o8DViQpldNYAwyYA8w0Pc3kPc216hXkvSKCTo++yav14ClZgUk2r2TVgfQ4z0VTNuZ5M7JUWpWjmYtSdKkH6Zo4NuT9Oigkbr+8Wd0mmn2g8+/VI33PVDN9uqsWs3bG0gZQAJcBHLMP2MKy0z9hBp2vGpdA3A1JVSoqSq1G6rNrrvp0COPMMvmDj374kuaMW2mcjIytSRxkW655Sa1am/uCto++Pdl1bzpLvrnjbdq9tTpxmkMNoz+/0FUEoqOEcyA+0FwkSWmTNGhiWBStBTLQwk6YpoSZ2D+2JmP+2AhwGxR8r/HHuc358MTuAZoNCdn4KKQ15+6E1MgWMbiJZSLJzdBsfeLrU9piHtH70dd0PxE+pnrZ/oV4ekLcbx45iJKjwQf+pxkp2gWn5P3Cc/x71GK/t0L9yFjEPeBZzHNSvoxFIvNolKRNT0PoCBlmJ5A6hCxZ418xbLldPCBXfTSCy9r8cKlQbviQ0/NWa93UzM1Zrn58cvSNWjGYnV/9wudcN3dqtHhAAN8fdPwbdTkqJN0wRMv6onJ36r/nGSNTluvoaukHua/Y8L3MuCj3V8xRAP8fva9v30OSlqnYWYNvL48Sx+l5WqKqXcSTJOM+eaa1p02f55ef/8D9Rg6Qjc99KhOuuJa7W3uROP9D1a5Fgby2o0MzDaICJ5qjVS2qplxFeqYJAf4NpjlK6gC2Vn77q9Ox56s3Q4/Xk06HagKDVvYdTVUrkYt7XvQITrulFM0YMAgLUtO0arlyzRi+FB12nsvVa5uYKto2rWMmYYVKuvUE07ROxPe0PocqyhRxvUlG7RYijIr8RaixUxHse1XNIeeaUXSbFltRrAuyoCQM10sOXPFnsc9mI5i7psoOAEu0nmj9SkOATB4ixkPti4nrZXZh8KmDKHC6loa4n7RutNujgF+ND8mP6v8sJRc61MAJEE+0n9ZV+CJONF+4778jvZ3LHHcz/VCfzJmaHqmU1kWTb/zDH9OcalIoKcibk4QVKBxVADJw0qzOqYJzz/7HL352htavSojBM6WWt/9YtbH+GWrNHTJcvPNk/TEpK90zj2Pq2nno5RQdxcDTgPV73qsOl91ix5881P1n75EI5fn6TWTGq+k5Bb47TbevUyCAHxM+4H2OcTKYNPyQ00ovLEyP2T3vbNwmSbPW6JPZszRuEkf6ZnevXXvfx7VKeddoM7HHK+Ge+6jhIbNTWuboKmyYYbASqVWu6nGrp3U+oAj1bbz4WrYooMBtZbKlAWs5dWswx46/eq/655e/XXvwJG66onnddRVN2jPY0/RbgcfqX2POFqnnXu++vUfbKA36W6m++9TftUVV12pRs2aBtO+XPmKJiDLau8OndT9kce03CwPD+aVlpyB+ATwPoXEyjP34ZmCIjCFnwkwmW1whiyMuBd/Z8yh2HNhRjQwGhBwsiyW4BarFMlLQPM7026JHAhcwwo//GSsE6a7yIpjhRsWSZSKct+iUvRetNv7E4r+DeuJDEc0LTkO9KdP7RHdx6xHIxMf4VwIvHA/7kM7va3RZ0TJn885Xkj6YVYBIYOiJdHHhSB/LwkVWdPzAJITiNqzNNKztypUKKfWrVronjvu1Mzps5RvSmy18cjMrLX6KitPryavDKB/+ssfddmzvdT4gGPMjzdNWauRKpqffMhVt+vOEe9rwNSlGr44Q0OW5WuwafkB5mb2MfOeAuh7L19nJr4Bffl6DUnO06BFZjnMWqZ+38/UoC9/0YtvTNK/evTTpbfeZf75qWq/T2e16bSvKjVsZs8zjV7dwF7TPpu2V51OXdXm8JPU8eRzdMx1t+qCBx/XHX2G6har32FnXqIytRqH3P6EclVUv+2uuvju+9Tvi+80etZC9flpmh596yPdN3ScHh40Si+PHqsJkybrl9+nKy3NKmvjuXTR4rDqa7cOu4d99QgClTPQN6hVT1decKm+/fxLrc8zQBU+9sUiZyAAikAme44VZACHMaIwDUV2GQzpfiZUmKZwpuMcTHc/5uR/R9sQIOTebnqSzILA8aCgP2dz5M/CjCWfgIQm16BYKQgVzH3I68FntE7bmqgjgEXjk6HH6kWm6YK1a/49xX1u3qdA4I1gt4Oewj0o/ttLlPyYn0shxwO3gv4gGEsA3YVqrDAuKhXLp2f6h00GSFbAR0TCVaxYXnvv3UnPPN3dNE12QUKMCaAfU9P10SoD5oJEK0v12KQvdeR1d6hyu/0MUBvm4bsepQdf+0QvfDtXo5fkaSTz74nZ6mPAB/T9DUO9AXxKnvqaGT9waaaGLcnU0AWrNMCsgn4/zNKjY97WDU+9rEPPv0It9jtItVvvrrJ1GtozqoY8/YS6BuBGLVS+TceQ+NPxjEt06q0P6Ppn++neIePV65uf1ffn6RoxfYF6fPK9zrnjQVVotmuBJVDWzPwadXS6+eJ9vvlJry9bo1dT1mj4opV6fclqfbEqR3NzTRja2GVam8MQWgfkZWXrjQkTQxqrC8eKZcxVSCinEw4/Rq+NHhf8/60BeifGie2uWGfuQGSMYEbqQSQZE9UZbVOAdnLm29QxrAWEP8ksHrkGsAAXwQIVhylhZFbqOegRlCS7IKx8G+6SMvnmKNo+Jwecf48S/UbcgQQmVlQSyPMAKQXgE3gjk3FT5P0Y2x6O+9+8sK8g6cLcm/0asdQKi7sUh4ps3kO+qIBKBNPeCnvCH3/iCfryq2+0Ii1d6fnrQw78TxnZ+mh1pkYkLlf376boby8PUUIbA3ydNirXco+QanvZsy+r75SlGjQ/RyPMTx9ipW/yWvVKzg3A70fyTnKW+e6ZGpmcoVELV+qZT37U3aPe1On/elx7n3uF6u93qGp2sPvWN9Md37yCAZ1VeE1aqHqHvbXrSafroMuv03mPPKs7hr6u7pO+Vf8f52j0zGSNXZCq8SuzzKVYY9ZIqgbPWqp+X/+uPU48uyCoV7aaytVtol2POUk39B+m0UlpmmDKcbDVaWjiGr27MldTzKIhN4BwUx7jYF213gTB/LnzwvpuT/SokFBeNavUUJN6jfTM408rccHCcO6WyBkhSrHHYAJ8P/xhdr3BFAQ0CBw2hMDnRjM7oxSHYfw5fg2/YVZMbqwZ5vlhfNw9otaYwLgZxSVMVvIJmBViZRqCiy2q2OfO4w+x7S4N4xeVHJjebojnkpZLwI6ELE+9RcgiqJi7J9EJita3sDYURv4cLCb2IgBvjCcLhtzqiRUYxaFigR5NT4DIFxWQcda8xS666tprNGX6DKXn5CvdTiVu+W1apt5PzQjZcq/8NldXvjBU5XY/RAkt9lGro7vpnEef1KMffxnm4Aca2AcEwK8PoO9ngAfsfRelabCVATMT9dwXv5hV8F5YU7/PuZep9j6HqFzrPQum/DDf8dUb7hKA3uKI43Xw5deo293/1tPvf6rnP/9JvX6ZrYEzkzRkfqqGmWswamm2Ri0zNyElQ4NWZpslka4hi1er709zdMzVt6sMLkjleiZAaqmpCZaLzJroO2NxWBzUx6yNPnaPccuyw4zBYut/2DzoTroqb71SkpL1wnPPBzObAcOnx8Rv0bi5brj2H1pURNBHqTAGYvDxrzEpWdUI+Hge/iYMSPCJhI6oqR0F8JZoU8DCbyXIhgVB1hlmPVYgWt7vW5T7O3Eu2h6tjhZlPpoZCHjOp6Y4J3rP4ty/pBR9RhRouEbMl7NxBtqdPvcZEhJ4CELGavui1tefQ9tJEfbYjIOeMdmmoPeO5kFMFfBSSIIsQbIZ6Fu0aqnHnnpS883kybA2mUUeUl6/XZOlyWtyDPSrNGzeCt0x/D0dePmdOuBi86H/87KeMh95xPJ0DceMNxO+Z9JavbQ4S70MjIOW52pYipnyC1foGfPXH544SWfd96h2PfEslW21hwHczHfSdSvXMQ1vPnurXVVlny5q3+0cnXj7fbqh71C99MWPGr1wmQbOSdIgsxCGmqUwZHmOBhrQByxbq4HL12ngyvXqtzJffex5g8wnGZCYpVd+mq9ruw9Qlab2nIoG+jI1Vav13jr1tgf1wpdTTVDkh6zAXotMaKTk6nNr4xzT7LQ7eMiMq+EkMz0jbK+F5sUNqlCuIJjX2DT98Ucdp8mTPjJm3rLP64zi4xAlP4bZToAJDeM+JsIG3x7Ax06lFQf0sRS9Ho1OwdcFsO4yFJdi6wGguC+MHRU6nBc9tyT1Lw0hOGPr8/HHH4cAJgIW0IMLND9WyrBhwzbWMbauhdU9ei4Fa4L7+DoJpsm3hqtT5EAeDcb8YouhjSaraZN99ttXE99+S6tskDBxYX7myr9aZZo+zYCxJE2vJmfr5e/mG3i/0YPjv9Bzn081Db9Ko+0CfHei9C8l5uqVpBwNW7VOo1Pz1M+0+7Of/xim8g658h+quNs+SqhpWh2gVzQzvn5LlWmxq/a7+Eodc8e9uvzF3nrwrQ/V+6cZZqYvCRtxjEk1FwHtnZypASvMejC/o++GKcBXzBwJZcU6DbY69E5Zr8EpazV0TpoeHvOh9j3hXJWt1jSAvlqTXXXE5TfriXe+0piUfA2z6/ubkEIATF6VZSZ+Xtijn/aHYTO+YHutpYlLQmCHqTIAX76s+fUG/sYNm+iJJ55SYmJBZtXmqDCAOlNAmMUE7zDjfT0840Lwh+md6Dw396JE71VUgsn8uVtiuGj9ikKcW1i9YgEWe07079uDaDeCzfvCj7FTksdvHPi4KGTRIRALo8LqHm0f33GhmHZlPHGlya/wF2jE9lVxqMigR1swv8tSQZc8+I6nnna6ps6cFebm0SdMVgB6VrK9tTJDw5PTzWfO1/AlVhbkGagyNDIx38z5XPVLXRtAR3Zd/+UGuNT1Gmkmc68p83T76AlhmW2ZXfdWQtN25q8b2KthwrcO0ffj/naTLnv0Wf1rwnt6/LPv9NKvszRo0XKNMm0+dJkJD7vvELtfn+Rc9TLt3tPu3yOU9VYM7ICfICFJPwb4gfa97xID8pI89fpqhk665naVq9M8BB0r1GuhvU+5UPcMfUOjFiBMZC7Jeg1LztF7KzP13eos2W1C2wMcGI9165WXkxvypTvu1cnMvwqqVIkdYyuoSRPTwuddoCm///cNKJuiKBM4eVQYYoqOLC1SP2E4zEzcL/Lp3f+LpeIwjD83yuiFUWF/K85znGKfw/M55oCI/q0k9y8uxT6D314XJ7Qv8QzMcA9qovnZr89z5WNpU8f8OM8gGw/rDcADfPZGYPbMycemuFRk0OPDuUahAjSMTK/LLr9Si81/BfToFBgf/fVNeq7eWpWtIcvSC1bUGcgGmzQYukSmyc0vNpT0SEK756nP0hz1X5JloF2j3r/N023DX9f+l11jgN+rYKqtqpnZtZuYv76v9jvn0gD2Z9/7VL2/m6J+sxM1eKn5/ma+D11hZvqKteq9NM/uawIl2Ux2tLsVAA7QsSqChgfsVlitx9w/OQD9kqSRyeuDGX/lf54vmOJD2FSpq8b7HaHLH++pvr8u0WgTHGj6/onpmrhstb5MXaNFG9ruoPe8mx9++lGnn3mG9VklYwj8PjK4yqpDp730Ys9XiuzWRwfYGQPwkyaKlnHrixVzmIT42r4XXizFMu3mCMA5Ra+Jfud+UbDyWdT7xxLXba5+pbl3SWhLz6PdBLixqgAoY4DgZfYECw8Tf0uBzcLuTx+QkcjCHYQ5woTlu8RusDa4pihTooVRkUFPw3gZBBsyuAlD1Pbmm29VyrLUwOz49DD+IqvL1+brTjCffeDyTPVaaea6Aa5H4joDiwHfvvczoPU0zdrXNCur53pPT9Gdr0/Wifc8qhYnnaVKROSbtAw+e5V2e2rv087VJQ8/pSfe+kA9vv1Vw+YY+JLXGPDSNGhlbthya4Bpdxbk9EwqsB54ZtDkGwq5+v2tAHJSewkeDrD69E5cr+Gr7bidMyAxR32nLtYtfYeYkOlkwDeTuUK1MONwwi3/0rOf/a6RKQVxgX4G+rFLV+ij5amaZ23GkPNhcNDzdtw77rlbjU27h9TeDaVpi5a68dZ/Fhn0sYzBgKMJsLzYl81NQJJECKxhATgQHUR+j+j3LVH0PL8uFuSxtDnQxhL3Kez8oty7qM/YGsSzYp9HXZzIgeBNPihCn6ZluhQLgIAc7XTa3H2cOIcYGmnTCBHuxyIfNv7EZeDvhV1XFCoS6HkAUVkWaLDqyINFNOruO+9RSsryAHrX9PON87/LXKs3UrM02LRvr5Vr9fKy9Xp+sYESMJrGJ3jXx8BJVl3/6Ul64M3Pddq/u6vF8WcpoW1HA/suIYGn8UFH69Arr9cNrwzSU5O+0MgFyzVs6SoNBOwpGQbeHA0xh5qgXF/TwGj3l82VIG23D8A2LQ/4+9l3nh3AvgHwaPb+5PEvNMFj5yEMesxNVe8Zibp3zEQ1OfRIq8eGRJ0GLXToFTfqiUnfarQJGNKEB5obMWrxSk1alqaZJCVZ24kz/ze1vmCThae6P60mTZurStXqISUX0Ddo0lQnndZti6B3BvFPwO5TdOw+y3JZnzLCvCTYQ966Z4VFye8BRb9viTg39nz/XZz7FIf8voDFA2gci4KnpExfHOKZ0RKl6DH8b6ZofTdcCtqeuXUCrT4DAXm9/dpom5z4G2nJgN7zAJgeZFaDdQ6xdSkOFQn0dDrMyzwwyzGpBP58uzZt9cZrr2venLnKzM1TWl5+yLmfmbNOP+RI761Zp+HmuwMmQN7LwPaKmc+Y3r1T1mqwacynzZS+59V3ddQt96t658PNZ28VfPg6Bx6hTuderttHTNCD73+pF35boAFLMzV4ZUHUHa1OcC4E6JZlh+Phu/ntfa30Ss4PQmAg4LQC+EOxemBlIBBwMXovzlG/pbl2jPX52SYMsjVmRY4efedjdb30GhM8DZRQ3kBfuZZ2OeQ43TroVY1blqlXzWLjXDYFeTNxjb4yAbDA2hw18QF9hml6cvHRwAxceV7IYaCvVLm69t2v8/9LMYV8QGM/GQeYB0nPTreYkz6dgxAm9RZNQDbY1gQE94Ixo/VxEPrv2E/+7rMGrORjjz00FwwbzaWPZXi/B7Q127AtyfuCgB6BNwc91pe/poq/e1sLa1fsMcYa3oBvfP0EAoWpwMJ4pji0RdC7hMJEwWwkYwoTBmZji+uvPvs8LDTJzjffxipqeNJ0A/23BoC3V+WbVs7WIAMXZjVR856m8V9JyQ9ZdoNSsvTwpK90/F0PqdahRysBH77NHmFN/ZHX3RbW2z//3Qy9NH1p8Pv7YR0gPOw+wVw3UDOnz9ZbTLkNNIsCgTDIzulr9+dvTAH2TsoJAT2OkQfgpV9ynvon54SgItf3tfoMNAEyLjVP3T/+TifedJdp+uYKa+wr1lazA4/Sjb2HaczS1RptfNt3aUaY75+4JF2fLs/VbOsqovgbZTrBPNO4r48do8MOOTQMXNlyBSv4ylfgrTp769tvv/8DWKKfkDMUBCMwNUYElx1cyIZzLcD6eObpmWEBbFsLMP58L7EUrV/0XAhwkzaKvwuzkmhCxh7JQrSB9kCcX5i221HI28u6g27dum0cE8x8koxYeYcg9vOifeQUO170DcKSGJpbD+RgsG0XGYGl6a8i+/RUGu1CWiTTQfiSDCQvf1i7dr1yrBHLTdsn2vcpGbn6wTj/g/T1IW12QNC6BWAliEYkvedyA2VKpu5+9xPtfe0NSti/ixL26azGx52scx95Ui98+o36/jJLY5IzNWrFWg0zNKGlg3ZeaoAlAGf3Grphnr8//rtZD4CZHP1+9slzydUfZv73UBM0lGFJZpqbZh/KPvtLs8KWXYOS7ftKZhTYe99AvHqd+v04Q1c/2UNlmrRVQhW0fV3V6XSI/vbsAA03F2AEgmdxlkbYfcYvWaPJ5mawvbdVI8zXhyE10K/Py9WH772rk088KUh+gnkB9OUqq0OHPcO7/XzA/TOWISCYgOk3EkJIXmEZJ0yFhme5J4teCLT6ks7CGKsk5EEjaEuM6sRxAM+CHN5Hh1lKVhkAYJtptuYim4956Nh78BuG3tS9/8qEIOPV2Z6azPgwjYowJigXJW+f92lse+kD1lKQ6syqPkCPO8125VhM0dyL4tIWQR+tDPnWLABgGgoJzlTFmjW8KNrMWgP7StP2i/LW6ufV6fohe70+NhN4FCZ5Uq76p6wLJnUAvmljps96Gegf/OJ7nduzl/a89h/a7/obdUXPPur+2dchUDfWfHZefjHczsdFYGqtl/nrvZnySy5YbcexAnehIJsPq2K4IW/gEgPzokyNXbE+vBprxKIMDZ69XH1+T1SPn+bo+W+n65mvp6rHlEV67rf56jE9ST1nLlXfWUv1mpnso39fqAeHjFXZxu03gr5K2/10wcMva+DUFPPrTdAk5oWlvWOTVuuDFZnhTbt2OGTnocPCgK5fq6+/+iJMt2AhAXhKxfJVtPuuHcKOs7EMEP2MFgCIn8eLKZiig7FgBsx89sDDBfNrtxZFQQ9RVxjSi1OUT/juacFYID7bQ6HOBIBZ8Ydm3Fx9t3ZbtjUR9+L10B58o9B2ZlMQgLH9CPmxaP9B/EaAo1hZ0ce96DvWvZCpWNJltVCRNT2VoxLM/QJ8opXffPOd5i9I1NKUVM1LXqYlmZmauyZT3y9bqR+z8vRtnjRxufm95u8OMvMac7uPgZDps57mQ79iWnVQyho99dMUPfjZN3rqu1/U8/fZGrwAUGVpZKppbtOk+OcE6EI8YKlp4SQDdYo02IRIn6UFU36Dlq3T8OXrwnTaqwZydszt8eM8Pf7+d3rkzc90z+h3dGPfUbrimT469+FndNq9j+oEcyvOe7qXzny6py7pMUTX9B2tmweN1xNvfqLn3vhId788UOUatVFCdTOvytdWhZYdddbdT6nfT4vNr5dGWhmSlK5RSWl6Z2WGfspeFzbfxK/HxA9vx1mXb332S0inDLvRJhSk5FarWFW7td89+IFQLGigqPkLEZyDeVja6eu5YQbe4kIKrLtiWxMs1CV6Pwf7pp7B+fwdXmGxCNoJZqUwu+Dg57VTBKWcYtsf/f1XJu8HPmk3bcIS9gg+hW22UZRR7ezt4zovUeI3sRty+Fli7OPNNCDP2FTST1GoSKCHmXyBAX49mxxgdpx++pl6uvvz6tFngAaPGafvZszU7+bff7c0Rb9n54uEwU/W5OuN1IItrQjEBR/cNHEv096smcfEH5GabWZ4hgYaeIbY78HmV+MvFyTWrA0uAUHA3qbZicKH6Ltp+sFE/00oDDUXYkRiesirH2T+f0/T4g+89mEAedcrbtT+F16rDqddqBZHnqy6nQ9T5T32Vzn2w2uzh8rtZW7FngeqRpfj1PSoM9TyuLPU5cJrdOLVt+rwcy5X2XrNlFDLQG9+PavvTrnxX+r52VSNTcwJO/MONf9+RHKq3l6xWt9l5YaXcjIcwI+3+a5dm2e+2dyQJkvSTLky5QPwq1eqpvZtd9Wro0bbmf8NaDHYzhBoWSf+jibHP/SUT7QIGp/8ejY3gaKAiWWk0lJhzLkp4jwW3/gGk55gQr35jdmPlbO5+23t+m8L8jp6nyN8aZvPqDhQGbfo+w/8Oj431U60OQlx5PbTZ24lsa8hef3OM8WlLYIeP5IlmwRg2FGVaCS+GbnddevWD+9773LwEbr0muv05kefaEZysqavWBneOU+M8Sfj/o9X52mcgYMFLQCfOXUi7KykI+pOMG2QmfF8D0LBtHXIx8cVsE8vLLNl+i1sn2U+/SDzqVl51//Xmeo+6Uv9c/BoXfbUSzrln/dp7zMvVrNDj1NC83ZKaNK6ICDHe/Cq1bVSy7R3bbGv/sZNNWo1VUJddsRppISGbVSrbUdVbmbXVatp59r5FasooV4THXbRVXpsvLk4vy7QkNkpGrEk1VyY5Xp3Wap+SM/RIhs/1/SAfr2Z9ytWLAurE5leIxUXTV+1QhW13KWVXunRk27+f5IfYlDRDmh88iTYpoy97QrchIKXU8Bg7JTq10cZwY+VhqIMGb23xxeI9eC/I6D4u5/PJ4EoXnsd3WKKOiMI2H4KvvJzvdBe7lmSlXp/JnlfkzvBIhySpLzNvCuPAJy/RyDaXv/tFP1OfxILYB29J1/Rf6R2sztSSU38LYKezRV5bzYphYCdh2K6IHlq1qyt+vUaq2273XVKt7M1/u13NW/ZMi1OTw9RfMOmZltffLc6R28tWaFRzLEvXhWCZYCcBJe+Sflhjpw98F4m/x4T3i7saaV3mtTDbkTabI+UdSFQ19+0K67CIDPphy9arZc+/Vp3Dxqik265Tbsceawq79ZRZVuaH97AQM52WJUMtJWtw1h2W90GwoCbYGAu33b3cG7lPfdVQsvdVa51RyU03c3AbUKgkpU6jU0A2LX4o5hW7JVXpbr2O+l03dNnsHp8/I1e+W6qRi9errFLUvRe0kr9tDpTS6y97tNj3hs7GAOnh8QmZj7Kb9hFhxz8Zk2ah4g2FGWE6MADLgAFw2AiMgaerIE24eUULD+FHHhbk9zFgPju9QPwbBkNb7AJJPEePxcAYB3i17PrC5aJAwDmJcmE7bWcos8gbXXMmDFBY0b74a9O0X4B4ADdk9gQemwG4kKO/uFcFxTRdsa2mfuRcelTs6TAs9qObblYclwSSnAmiUppCCkCo7EpgwcmGDCkDtsCscSWQM2jjz5upsvTGjBwqD798iulmEYiSQfvhdnYX5Yk6+3fpunJ8W/qhl6D1fP76Xo1KUNv2kmjDNRDTHv3NVO9D8kymP2A3Y4xNcfe9oPIlDNXgFz619KlNw1RvAfvsU9+0k1Dx+jQy69U2yMPV7mWrUxrG0j9VVjVWJTTTDU77KOEXdqrYZcjTftfpCOuvjFYAuf++zHdbOC9qfeQkPhz4wsDdcG9T+qka+/QPqdeoFod91Ojffcz66CGgd6AX84GsErVsEFH3Q5764grrtftA0ep34+/a+CvU/XFynRNXWPaL2dtyEykJ0N/2j/8L5j84EMPES/BwEzj3fZsLIqv72ByimpojvN33pSLBoGZogBilRf+cxTs/j16n9IQdfD6OaABJS4egCbGwLQcjOivqGbjTdYEEL12X55PfpOwgmlP3ZmCRKvDwAhG9oPDnGV+moAVf+N50f7x+kSP/dnkQMaEp20oSV8AxXgj6LDIiktE8OEdn6tH4WLpkX4NlaQfNmp6LowyCSYWc74EXAhAkV2EpkKzEEzCAmCKImNNuia9/4H69Oob8r1/nzFdi1OSlJmfq0UrlqvnsGE6/4Ybte9pZ6rz+Zfq5r7DAvBHLlylVw3IRNuZhmMePyTw2CeFBJreS7LDfPgwExKshe/500w9OflL3ThguI698351Ou8SVTWTOaGBdS5zo5XNBK9ZVxVat1ezrodrj1PO0uUPd9ffn+2tB0a/pafe/UIvffaLBv48V/2s9LXSf+qCsNa+7/ez1Puraepv5Zm3PtE13XvowvsfUOtDDla5hqb5y5t2Ne2cUM60fvX6qr7bPtr1lHN02n0PhZTdkd/+rB/NzDe5tCFyb/+Rmmf/WGZL3xx59FEB9BQkdvWq1YIG8Ow57//oJwXGp78BmZvKMBJLnBkDDxD54Pv1xWWGzZHfCwFEgg3amM0g0WbUAzOeaVz4hU/2usMVdFfEC3zkr4ZmmTa75VDgK7I9iXtgRRIA5PhfHfSFKUvcMAQbY+VWGdhhmy3+HjvOmyNwyLv0mAXhPtyP/sGvZ9xL0hcJsRd4Rcj6odP91b0MBkv7MOU8chgY0hj6xx++08UXXmTSeT917/6Upkz9TXPnz9E7k97V/gd1UQ0b5PING6t8q3bqcsnVevb9L/TaojS9vrIgKw/fnnl2lr72WbE2ZNuR4tpv/gr1/HWOnvn0W/1r1ARd9dQLOubaf6jV0ccqoVWbAn+7ijEVb7WtXV+Vdu2gNsecrKOuvVl/695T942cqCG/zteQqYs1bPYKDZuXpqEL0zXSXIpXzaIYbYJlROq6YHGMsee/au4G03sjF6Sq75R56v3tT7r0oUfUcC9et2WStlxV63h7VnmzInADajVV5b26qP3JZ+nWZ1/WVzPnhzl6sF6g6gsKL8JgivPkU09RuQqm9Qz0bDNWpUqlsFTZF8Z44M41Nb8BGVNBaFA0anSFI9rQt6aC/LriMMCWKJYxuTfxBVKAPREF4LvLx28+qSeCycGOlvffrvEJSuHfE53mk79xDhYM++2RXQhj0w/RNjnPbs12lpSi9aCvKExlM5+OsvQoPoLxkUceCQFxP9/He3PE+JPNiECknwE9/UdgGL7x5/s9i0L/D/QwDpIVE42AAYBHYjENQe49iQFeWa7LSF+t18aPVaeOe5jfUU9nn32mvvzycxMaszR27KsFb3vBLzZflv3m2h55op576+OQzDLZFNSIlaTOFgT2+q5gYU6+Bq7IVe95y/T0V7+q20NP6fh/3h2shCZdzTxubverVr0A6LyCqlV71divqzqccb5OvPUeXf1CHz08cbIG/DpP45MyNW5ZroE8V8OW5mq0CZVhuA7meDPtx1babLHdz6yJYG2krAsJPYOTs8OS4GHzluoRc0uadTlEZarWU7mKtVS5aiM12GUPVWvRSQn1WpjWN1+rXlN1Pu0sjXz7Q61ck6PcHAMKWKFY1/L+OkzZc847VxUrm0VioC9XjvfIVQz7rHniRmGgp5ANCQBIcoGJAAY+3vXXX/+HHHu/zqk4jLApigU9RJ2oM1NyaGwyxXwunrpR3KTnOFobIPsxivu7AJ/zMV9haH6z+Qc78RChhhdj3R/n2a3Rvq1J3v++zRXxFxfStI11EQhvFw60qyhEvAT3gLGnD+k7sIlwKUlfbDTvvcJUhmgs+5kThOEhSCm+Y9bjg3Hufxu4TO9/8LYxZGeVr1hOB5k5PGnyB8YU00y7TQzHq1QzDcmS0pp11O6wo/XCxA/09ep1+tpuMd6MhoErTdsb0Ci9k7L00pwU3fHOZzrz6ZeV0GFfJbTZzYBl5o1r9Tr1VGuvfdXmhNN0xA136KxHntPNQ18P++a/8sucsHHm2JXrNMH8/6EmTEISzxITJEvXhRdlvLx4bYghsI9+T+IIpulfCktx129I7zULJDVP/ecn6YHX31J1ts8uX9PaV09167fVAYefpoPOuEJNDz7O2tTINH591d69o+576jnNXbS0YIVdBPQUgl7soIp5G5igrJm6pukBDQtkIO9T/4QpGA+m48jCIwkHTQpIyHBjO2TMX4hBjwXo1gRFlLkoaGD8TQJ5zChgfsLY1M2ZHI0P2NF4rATkO0Igaq24CYxy4TcZe7SLe9MP3gfelmgd/mpEfakr1hfxLiyY6NQdJj79hXtUVKKdWFZkMdI/LjjJ/EMxl6Q/NgbyogyDZmEdMEkFPAAf7PLLLw9R4j9Kp3WmadZo8scfqNsZp6l8lQrac++9NGrsGCUvSzFm/lGndzs15A6XweeuVkNN9zpAjw8fp69X5uhz0/RjU0mnLYjkkzvPevgec1foxnHv6ZA7HjSwNwsBuYQGTZXQuJkq7tYxbHZ5+j0PhG2xHnn3Sz337XQNmLNcI9hA06wGTHbuE3LtDcC4DYCZQCFxgwBsKz1N2/dIMaDb30MugAkCwM86/35Wv0FLVur20a8pofXuZtpXV5kKdVS7YTuddP7VuuHJV3Tuff9R6+NPVdODDlWHo47Toy+/ojkLl9hIha4x1Np/fLfy848/hRRm93HLm6avUb1qWCSDvx4dNGdyHxsCdSNGjAi7sQAYJD2vWeI6NKGT36O4TLAl2tT9qB/CjKAu5qczpWtu/HzWg7NnnKfhokCwUggAErADCN4mBBrXkKnncYoo4CGvS2H1+TOosLowJuS0kDTlKbm0D4HPUlvM9aIS92YGhzgJ/YOAhH8I6hJz8+fH1mFzFEAfBTyEr0A0FnOSCiOlyR8maORzgzyEbLO8teYK/PSNLr7yUtWsX1cdjDEHDh+q7NycIK0ffuiBMKfP22ISKlZWDQPQnS/11XtzkjXJzHkSXMimG7BsfZi+65OYqxdnLNONr32kI+97UrucdqE6nn+FDvvbjTrxlrt01oOP6breQ/X4h1+p3/RFGrggLexgM3yF3Wd5wbp6XAQSf55ZtFr9zfrti/m+woSLafThZlmEef4Nabw8kxx+Aoq8QmuQnTMwbb0GrMzSoKUr9K8Jb6mCaXGm/MpWqaeaDVvrjKtu1IvvfKyn356kO/oP1PXdn9XdL/TQ+998r+SVq61vrIMc9BuCeb/+/Evw34na82agSuXKqnatGmGenaWXPmjO5AX9WzAuntIKaAAWZh4aEeFc2GBznQuMrUGx/OHEs/FR0czEFwAvTIk2Z8YHYcDsBPsE4qOzSIjZIAJ8gPu5554LzOzakOvZKML3gXN3x8n7xctfhbwu/km9SaQitwXsEL9wsPp25FhoRRkj7sn9cAPpHxeqBICxEL0v/NlFoWDeu/b2T3wS9u4mAolmQoqT7820ERLYGRPKz8/V79Om6ILLLlHzNq20j5nzA4YM1pr0TC1bsTwMLJq+UvDDq4aEl1uf6aUJMxI1MTFTQxKzQ6INIOxr5veA5HVhr7pnf1msG8d+qMt6j9StI97Uf979Qs989pOe/3aqek5ZoCFL1micAXqEae7hpqnZ6LKXmfCk7PYz4Pax8qJZDyT4hCQfu28vpgAN4KTvhl18DOh9FmZr4FKzMJLY4GNtED7EGPqkZGhocpoen/yZau5/kMrUbaqKtZuoSqNWOunqm9Tv61808JfpGv7r73pr1mx9OGO2Zi5fFbYAp2fW2WfBl4JPtDLTURtBX6Gi6tauEywo3+K5oD8L/FfvYz7x6ehHLC4Az+Bj6hPZhWIHnGv8PluDoveJ3pdP3LvXXx+vgw/uqjr1aodAJS/4QIuH2RwDMMC+6IILw7oBtBx7x8G0/CY4TBAPZqZtuJG+i6y7Lk48L1r+KuS4caJuWGdMOYIdBCCAB/h8JzaGIEeDb4m4F/dngw6sJ/qI+2AxkBJfkv5IiEpxlzwkBLBwANOMyiKteL0Q/vwfiOfY5fPmzNedd9+lWvVrq0271nqpx8t2j2RlZGZryNDhYd14WGhCVlv5ajrhmlv05sI0jeKd8+ZHhx1sosWAN9CAT2Gr6X4mHAaar09EvyCpx/xtUniT8/5wXX8rmO0E5cLafQM7nxSOhU00DOwDrQwmf98+SQqikMvvW3HzfJ4xjA09Tch0POviME1HKm6lFrvq7DsfDIHCVxenatScBZqUtExTM7JlMkNr1pq/m7+24MW0oXvMTF+/Th988KFOOO5EA3o9Az1R2ArB1OUtMYUxN+TjgTYlow+/GTMRSY+pH3vd9qd1ysxI008/f6fzLzxHtRvUKnhpZ4Uy6rDn7nrggfvDVt9XX/U33fD36zTt96n6/PMvw25L//rXv/XWW++EGQlMYBiZT6Ylo+mqOyKBKQKsAJ+9Cj3PhXEDT+S6YP7HCotYcj4gBsCiHdwD7sMn/ICvXxL6A+j9O0wGM+KHUUnMSjR/lMlChaiT8WXivEXh/Xb1G9ZTixbNQ57xvHkLtHpNlkaOelX7d+kaQF82JM7U1JGXXRdeNjHafGfeSefA+wOA0bhW0Ny80opcfUrBslwTBmauh2m+DddGAe+gjxYHPef99xkFx1j2y++NoA/fCza+7PndDHU857IN6bq1VbltR51z32MaMDUxJAm9umCJJi9bqelZ+eHd+FHQF8hEk9Tr1gYGP+aoY1WDaUYy8ipUUvNdWgY3yrWnD3L0k4KFxSo6X1cN82Deu9/755FZFGuzNWPmFP3tmisKQM/ruSsmqFGThqbhTwt7/x+w73466IAD9dh/HtVdd9ytrl0PVrduZ+iZZ54LL4QkYo8wwwwmch+dhtxRyMcM4jtjAyjJouSFID5ugBbtz9x7UYU2oMcNxOqmn3CHwGN0M5LiUJiyc/Lv+CP4Xr6wg0qTLfX/gkacbqBPSUwOiz6at+DFgw3Ctb/99rtWpWVo/GsTdPDh7CayAfQGnP26XahXvpyqsQTvWBJroKMA8gItW1D43YdXXbEyDxPdznnZfoeUXOMLdsJhuW643sAbdsPZUDYCHm0fWzYIEArnusD5f6BPytMr389Wp3OvLIjSV6sb3qZzySPdNXRWkl7l9duLl+kL8+Nn56yVyaZg3ufmrTUwGGDpJyuAfty413T4oUeEt9eGpbUVK6t1m3bBH3ZyoRsVxPQ5Pj+gRxPCPIwJPnSsz7v9iXrmK3HpQt153x2q26hOAeitVKhUPiiAvTvtpSaNGodtv1u1aB1Sj5s0aqq2rdtpr457B9MekxVAMLWH7+oaLMqbf3WirtH6Isgx30krJm2WWQrX9LhpZNSR8VqUNmL54PZ47APhyJRmYVuiFYWCTx/7YHKE2e+LihKUwZQkmygaeAjXcJmN++oVaWFThF13b6969eqE+WOW3aatztRbb7+rY044MTB6QvlKQdPvctCxun/M+6bpcwzcprUBqgE7LLSJAT5r5Mm5L1hauy7svANwicIH0Nt1oXCPTZT/gnxtKK+kGphDKXh2MPsjgI+Cvud3s0zTX2Ga3rRsrQaqv28Xka336vzlYRHRBymr9cPqbC00/PFOO1P4BtT8jaYbXcT3kcNH6ZCDDg0LblhlRw5+m7btQ2ab97/3L6D3Y2gMND3ulWt6tAVB1i2Zh9uD1q7PV0qqCf3ujwftXgbQk3Vo9axUqcLG2QpcGtpd0XgAwcfbfvhep1bt8HcEmc/R/z83cgcgxis6bhDjCbBxlZnBcNDj1oEvcl5irymMcLeJrxHL4XoS5tgwpaTuXaGgZwUPUVckC9FitApbHDlxfriGywz02WbGM8W39757mRSqHYJTn332hdIzcvTxJ5/p7PMvMGYw0Jcpb1qgmqq021tXPtu34EWUBvqgcTcB+kFodIC5oWDS+z53nO+g53tBKdDcXgquK/gb2X59VuSpV2pOQSE/gL9vBvQvfjVNu59xiWl507J1GoX03pt79teExFWamLRaX6ZlB9PeTg+r67JN0+fkFCTVeL8i8QcNGKyDOncNL7IEAIC+/a67h9cz+4yIa3iYxa/lb2yPhFB1y4ugF2PyZ5v31DDfTL2Va1L1cs+XwiwNQUqKA9l3CiKGwacvNqqQUDEsM67AQiY7lzYBerSi98eORIwX4+dj6ESwlVx8ZiwAPQVFShSfKTfGenPA528IB2Y7EPb0FdOc7GlRlEBgYbRF0BM0IMcajeS08Xw+rI25mVkmeUbqgC6dzTqoFeYnP/74U+XkrtOPv/6m62+6WdVqmGliTJBQvqrY/PLUux4J+fQEzGJB78Dnkz3s+yTlh6k1tsDqb0AkwDfEzPzBG853UBdc+0fQFxQ/pyDrD+D3WZlT8Gmgp8SeD+iH27Oe+ugntTn5PIU369RtrNaHHaU7+w7We8lr9M7SNP2SmR+0PHF0WDU3z8z77Dzl5xa8WZSCj/rKiz21z557bwR91aoFG2OyGYlLbO9X9/H5RHgQEMI3RFsADgYf6+vP9n2prbGsVmetCe5f65atTIObJWJlI/ABe9lyKluxksps2PO/AOym7VECG87DxAf0pK/GAuevTFHs+HhHifFjIRLJNS7c+MRSIx+BMd4c8Ln+hx9+CHkZXIe2Z30DOTMlFfobM/IgHkohxRLzg0EA+KTgopGcNlauYNRD/v2oUSN0YNf9A+gvOO98a9An4hXs8xcn6j9PPKkmzZoa4K3BpM7Wbapj/3GnBk5bIt4t9/+1tQN4vfqZ/z7YeJv0Wbbd6jdvlfrNSdXIxZkaZ8eZ3mMHXD8f0LqPv7EEbe9lw3kIAPvuoA8a359tf0OwjFiao0fe/VrNjz0juCUJ9Rpp1yOO0f0Dhuqj5as1aelKzcpdLzs1rCzE2M6z3zlZueHtNrzaikFjyu2pR59Um11aq/yGnXMaNm4U3vbL+mv89uiAcw2MgMbjk4ANlhZRYGcaNmbgvn8mbRh+ZebmaPhQs/Q67KnK1rZKpt1pY3DpylhB2FP4bsewcohpBM2/QfthUcJvWIlOhYHgr0aMj9eTz8LqzBQkiVkINrQ8FhBTrmS9MtYO/Nhr+Y02J4WbtS+MO64BU78E26MxtuLQH0Dv0gZG5KV8+PTMDZJc4aCPbdjavHVak7ZaI0YMM02/n2rXrqnzzjlXkyd/LON5rbC/vdynl9rt2l7lKplJV6OWgb6Jjrr2Fg2eulhDksmaKwCig47iQoBNNYasNOAnZ+v5XxfqX+98pdtHv6d/v/axnvjge40yYHIPCkDFXSi4VwHI/wjq/2pytyTCOUHoIAQKLAGsD+7HTrcPTfxETY88pQD0dRtpzyOP0yMDh+oL8+U/Tlyx0Zen++kV+iMv87+gB7izZszUg/c9oEZ1GwZfFt+2VZvWOvfCC8LiJfqTQXdiMGEGLADGhIANabhhE44NoGcalXH6M4n2slFI3tp8vT52nA7d/0BVN0um+oaXdRZoeQM6i4zss0wFO75B2xcIhII3vVLQYICevfPCva1PYrXmX5EYp2g9o9iA+A1wSW4jAAfoyaxjOhxN72PN+Mdqe74T32CZMmBHOBL4ZHUibkNJYzob03CduBHRYm5MJTHvyaYikOcV4nNjQ9etD8z51jusIjtB9evX1XHHHKvxY19Ttvm6qWvSNe6NCep68EHmz9vAVzFNX7OB9jr9Ao2clqghi7LUbym75xQA0vekx+R/ZYWZ9QbCQeZ7vzA1UVcNHq8GJ52vqgccp1bHnqMDL75BNw+aoHsmfqaXfpmvMeTbm4093Gxttr5+YXF6eEEm93opOVc9Dcjcf7BZDWTfhS2wNwC974ocDTCTf3Bavoam5mvEsly9mpihh1//SDU6dVVCjXoG+oba08z7l0eP11eLUzQ7Z33YMwAjK8s0/IY9M7TOTPu1ZuYw2IB+6pTfddmFl6pGpWqqVaVG0PZ77bO3xk+cQA+G/mQc3Jzn06U/RO49OxGzpzr56ww+mp7NNqFYRnGKft8WxN1zDPCr09foo/c+0IXdzlIlE0iVEsqoBslYZcsY4M0PrWhAJ7jHb/usWr1awe8NhfbAaygZFpJAsQDYUYl2AFxeR+WBWKwaZsQmTpz4h2m3qPCAXBAQ6Sd4h3DkOly9kgIe+sM8PcRvAkcPPfRQeBASmLlUVlT5uQzGxgGxj+zsTL37/js6tdtJG0H/+vgJwdQF9K+9MdFA36Vg0CubT1+ttvY4/kwN+GaGhi/M0sBEMvEKAmiAkug8O+b2XJmvFxPNX0zO0GPfTtOpj7+khD1MeDRoq7ItOqrWngep05mX69Br79Blz/TTI+98rt6/z9fABSs0cOkaDVqeEwRGn+RM9UxMV5+lvHHHzHYD/bDlZhmwUy975qdkqb9p7gHL0jRkeYaGL+Mlm6s1dv5KdX/zYzXufIQSqtRSuTr1ddAJJ2vYG29r2vK0MC9PnBlfPiTjUEy7A3oGBcBTvv36G51tgKhSrpKqVagSfN4uB3XVR598bBcU9OfmQM88LYEb8vQZD0BCUI9gEJqCc7kH47O9gWJPDHX4/suvde3Fl6t6QvkAejIPC4BuoK5YoM1Zb4Cvz7LisD8BiTzwhB0D8CgYLExv9/Zuy7YieID9Ahkzxg5rDY2NyxZNsIli0XmC6TpyYHz7LRQwVrf3UUnoD+a9E0zGvDDmJKYIkUd25YS5nKIDkpeXow8+fF/dzjhFDQz0xx99jIH+Da2zeqVlZOr1N9/QQYeYtoQJzK9JqFRVrQ45Vs+8w2uqDIiL12lQ0gbQo+UjoOfNtv0MlE/+MFMX9xyiukeepoQmuxfsZVfBOqJq47BhZbsjTla3m+/VP/sM0xPvfqpXfpimQbOXqM/Mxeo5Y6FemblIAxcu09jlmXrDtPmbq/I0YUW2xi/P0hhAnrJKI1JWaGTSSo1IXK5Rc5M0ZtpC3dtnpJrte6jVuYaq1KuvY0/tpiFjx+uXeQu1cNUarcjKUZgtpzusrDcNvzbfTHvzdnPycpWemaE33nhLR5uFUNEAUdHMWkBPMOa333/lyo0DXBjo+RvmPYEblmb67rKYwiRNMVaFgST6fVuSP2X21Om664ZbVM/AXsHaV7kyG44UgL5yFdqdoCpWsATKWylXwcz78gkqC/jtN7EjpvfYdLWw9uzIRDt426xP21FQqAMHDgzjF1WmTnyHB1jvQjwA64B+YnMS3067pP1TKOgxR1gCyNQAUolXWbF4AInlFH1g/ro8ffjpJJ1x1mmqV7e2jj78CI0b87oxv7Q6M0cT3nrzv6Bn4Y1pvCb7dNUDI3n1c8ZG0JMW+1/QkzO/TsPMWR5sTnOfeSv11Be/6eLufXTgJderzl4GxBpNjanM1y5bXWVrN1Ozvbuqy1kX6/Rb79XlTzyvf7wySLcPH6vbR7yme8e+pSc/+FR9f5iiUTPma+ycxXp11kIN/m22+v0yQz1/+FkvfvudnvniSz314Sd6/I1JenLMWzrpyptUr/UeBvoqqlSjhvbev7NuufNO9RkyTK+/+4F+mTpDWQb00B0hz35tAL3pXWXkZmrFylXWd7219x57GRjKBYavYcC48srLtXgJ77ot6MtNgR5CkzJXy+4yYfGS3QOtCPBZdBEdl+1NBfsASksXLNJ/7r1PjWrWCm1kjr4SYK9UVhVt3GvasbpWmlepptqm3auzBZkdL2tCASsAXxdthu/7v0jMiJHhSlujoGcGJlbIOaAZdyL/AJ1ruJZFW99//304r6RU6JQdmoUpGFI93Y/Ar4gmA2ysIDptfb4++nyyzjy7m+rUrqnDDjpYI4e/Gnz61Vm5mvDOW2beH7AB9CbZy1VQwz321d0Dxpimz9DAJfmFaPqChTL9WW9vFtBQM8cHL0ozYM7Q/eM+0Bl3P65djzlT1XfZTWWYQy9nPmQF83fr7aJqrTuqvgmAZl2O1p6nnquOp52n/c+5VMdcfYPOu/sBXf3YM/pH9xesvKSL7n9M59z7sE67824dd8vNOuL669T1iqvU+dxL1PnU81TDrAh2yy1n1gmmdb0GdbVbh111gJnnx554koaPflXLV6Qa8PLCZhkYvLg7YSorO10LlyzVvff+Sy2a7BK0PBqvdbNd9MgjD2lNRoE/R19uDvR8ohGYq/fUaA8IYYGx2g7y+zjFjuu2IMaeNq8wofTso4+paf36wZKpXLWCGjSsrYM676O2BuZWJuj3rlVXhzRvrf1NcNWvUkmV0PTGE87QZBzedtttod7bo+7bkxz0tJUpV8x7Emww76NjBnn7mZJDq7OBBmOOlccuwmj/0vTP/wM9pgYPI3CH/0AlmSp65plnNkaaIf/EjKV8+tUnOue8M1W3Ti0d0qWrhg4eodVpmVqTnafX335zI+jLV0TTV1CjPffTPQNfNZ8+XQMM9Kyuc9CHQJ4BHtAHAZCSbz53fvDDR7D4ZnpyeInFTb1GqOs5l6vNQUepcvP24i23CdWtVDEhUIl986z472rmCtRvquqtdlODTvuqMa/QssJS38ot26t8i5ZKaG6WQxM738z4hKp1TEDVMnfE7lGmaoi4449WqVxejZvUtz5pG/zyl17pqUWJi4OgZKkxPQKYc9bnBdD/Nm26Lrn0ctWuWjOAvmqZ8jrioEP06qujNgDmv2AtDPTezwR8CAbxhhO0PEzAFBCbKZBBuXE8In5h9Pu2Isae/9NXpar3yy+oZbPGoZ9q1K6ijnvuqle6P6XzDj9cRzVtqYv3OkCPnH+Zbjq5mzq3aqk6Zg1UQBHY+Qgw/HrWfJQ06eSvSD4urIhjxgU8IbBRpARnwVRh48QxeIrt6Tyxh+AtK/SiW26VhP4f6PkOszFFxI6eDAhSiUU0SCWv4EYms0EH9l9+94UuvPi84NMf2uUQDRk0XKtS05Wek6/X3nrDANJZZcyUqxh2lq2g5nsfoAeHva5hi1aHt8YCaqbRNkbvrbzCHLspQza6YMEM8/VD2Ct/cYYGzVul/r8v1n1mgl/1bA8dd9OdZvZfo33OuFjtjj5Njfc+TLXa76eyDVsroaaBuZKBuHJtEwwNVa4Be/Y1Vfl6jVWlbjMrTVSpUSNV3aWZarZprbrtdlWDNnuoccsOpn1aqUrFWmGqDQ3WtlUznXTiMbr8sot011136IMPJ2lF6spgYgN6LJ/0nDXKWJejtNwMTf78cx19zHEG+PIG+IqqX62mLr/wYv344/fhXMj7vDDQe39j6jGrwvbKHgWGeRACmID8PUrcMzqu24pog3mfyjNXZtSwwdpt1zZBuDduVl8nnnC0Hvrnzbr6+BN1ccfOGnjtLXrp0mv0z2NPUoca1dWyNjMZBaDHVSEnnQVI/0ughxhD3DBeTAJ4Eda4zmydhYL1cYqOF9cgEFibwQ48XMfsDbj04J/zRnEpgD56sT+YVUC8FJEBQUKxIQL+h58bmIrPAPt1+u6Hb3XppRerccNGOvygwwLoU1ca8+fkhuh9ly4HqGw5zL4qpj0rqeV+XfXomDfDCzD6hnfdFYA+bHAB2K2EHW5MCJBjP9jMfObUX0kseLU022ANXpKhd4w/CNg9+tG3uvf1SfrnkNfDq6tOufUhHX75zWp37JlqcfDxZu4frHp7HqBGex2opvt2UdP97NM0/r5dDw8v6zj42ON09Bln6LRLL9V511yny677p6687jbT6Huby9I4pI7WMUY9/ZQT9UrPF/XpJx+axF2gVavTAtsj/hz0uabls9bmaE1OVpiW22+/zkFo1KxcXc0aNNLtt9wari0K6KNEkgfmPHO27gfDEGytHI0CQyVliOISL/MIaUnm27/x2lh12quDyprZ3qZdS11+8QW6rFs3nbzH3rrzmFPV+4obNPL2+3Vkg+ZqXd76s1zZAHriRpiuBI5ZSOL98b9CtIVArCfYAHoyKtk114V1wNMG7EGMH3PxbJ7CHoRcx74EJPR4DCdW0BeVNq6yi4IZ6UNesL9NBV+LnGg2BfBzwqcVGJ5PtNAjDz2sti3aqFWzlnrqiaetUgVz1byvbf999wuDW6Eq+8hX0e5HHq3n3p0cXnfFq6UHGqB5MWWfxQZm8+8HG+AJ7GHyFyTUFIA+JOwgCOw7u+YiMHjV9JBlueFd+FgB/WevUI9fF+vFH+bo+qFv6roB4/U3cwWufHGQrnmxf9jr/l/Dxqr7mNc16o239OprE/Xae+/r3S+/0gc//KKPfp6mST/8rrc/+04XX32DmrRoZ51ewfqhYZjKZPOH6ADxPdqPRO0zs7OUlJKso445OgSoypUpG7a8PrDzARo2ZGhgBL+Oa6KAjwVsFAAwCpF/mICC1ifAx6YMUHQctznxiFyrG7GM/PWaPuU3XX/93zdMxSXoBGv73i3bqNs+XfX0FTeqz0336bojT1HnBruoofn4RPJbNC0ITFLYWIOcBO+X7dKGbUSx9WfBFLMtvuUVayfQ9Iw55OdGx544DmMLbrgGa5sVsJj98ElJ6Q/z9DyY31SEwAOr5ZhKQTKx2QHbHvM3zoERAXx4SaN9JiYuVf++A3TaiafqyMOPCkttWShAiu74seMC6MuSjVXJNL1pqF3M7394/AQNWJgasu54Ky0JOv2WrC8AvZXw3cDObjcsvAmLb0xADEizYoqNUrCRpQkIux7zH+HRd0mOei1IV4+5qeH11IPYgGPh6rCP3uA5SRq9aKXeWr5GX6zKDK+WXpOfFxbLMOe+zLpjcfZ6zVyZoR/nLdWVN9+l5u33CDMOjZq10BNPPKWFCwt2dnGiP3yQvQ8xzVgdx7qF6DQb7xtHCEav4XtRQU/klrUN+PXck4xJIrqMF8T9thvxKHgvlPWaM2NmcD9q1jZ3yJi0y/6dtVfLdjpuz8667oSz9M/TLtRZ+x2mXWs1UmUDeQVP4rHvmPbdu3cPCgcqrB92FPJx9cJcO5tpELOgXxg3slwR4A56Jx8/tDhp1iRgYdUxZccMGoIg9pri0v/bRIPCg0nQYXcO5hYZFCKPbOvLUkG/hup5QatPnTJNo0aMDuCnQWg6Iv4s1iHBh7TLsBW2gb5ep710x+BhemVWUnhRJVlyrKBjW2ov7F4b/U0evm+SAdgp7GqLFYDmD3vchcJmm+y7tza8QYd35LHjDkk4Q5PXaOSydL22Olcfr8lSolU+1UAF4Fk0s9T6c056vn5LWa2vZy3U1bffp13YI698ZbVqt5v5nD02RssdjDCoDzB9w3EGjJcPEnzxwBtaGRONgJwPrl+zKdD73/183kfgU3cwD0zEjro8i2uj5NdsM+L2VBVtb5/JiUsCcEkxDn69uXrtm7ZQxyYtdVCL3XRoi921T4MWalaxRtDyVSpUDKvs6B/2xiMBKdzW6l1axv4zifpHC0E8dgRirNyqYQEOAjwq0DnXiWlzBDkLc3xmwxe9OT+UtI/+ME/vlYR4KP4DgSI0PSbGcccdF7KIWPXlZI8PY89/5J2nrlilZctWKCMrMxxng0yCD2FnXZZR2kAD+lp7dtQ/BwxW71nJwUTnfXZo8QBku30oG8AcCkE+Az3r69nrrmfSWiv8NmGAVZBkf2evPfau3xAbQPuzQq83u+LyUo3kbDsnw9yG1Rq2IlMTlq/WjOxcJZlUtVOFgTwnc62mpmXr5+RV+mLGfJ177U2q37KtMXEF7d6xk/r2GxCkLYQ0ZtDofB88/83mCayjZudX+g6AIjhZvciUixP9vTnQQ9FxQWswdccedM5A5FGQV1HSnVRKRVRrQ8nKyAzZYoceflgAPe1uWLuu6leurhbV6qh11boB8PXKVwkzGb4Sj0AxCgXLCKIPYgXYjkQ+Xj5m4IjsSdfytJlEK3cT/bzoJ/hDWLg/j/KICkWKW0XFpf8XyIO4IcyLn8576xgUHoymuvbaa4MW9wgr1QT4G74UFCN+AgNWYL06dkzYD5/llQlVzLyvXEkN99tf9418NbxempVy4Z125q+zFVZ4l50Jgb6mocmNR2OzYy6F99phEfQ1tRw20gDcBnw21ySHv9/SgiW4CAgsgLBNliEagdLfrh3ArrkrTciszNN4A/5sqyh6226jhVb331dn69fULH2/dKU+mT5XB59ylsrWrmc+aoWw7dfwEaM2gMt895z/Rpl9wGBWBgMpzuIRfDgGGsGJqY9v55YCxHVbAn2UCOIw1YMAZkwoCBZWRTponCm2B218in1hvQF7sV92xeWqwlJqAz7tr1i2nGpXqKL6FaqqtllMNStUDhreNR/pxbwByANUtN/Ljkje/15IwmFVHYFX2otlw9oW5wNvp58P9rCQ6UvWJHANypdUXv7u5IqmuBRAH3uxV4IHU2GkFFKbh5Ow89hjj4W54cCgPux8mHBG21MvfP307CytXJ2mwcOHaf8DOhfsfY+pW62qWh52mJ548x2NXpxufjeANnCixdlJZ9X6AHhefNE/OSv45EOWFpRBpq3ZFLP3cgoANvPdQD0Qq8A0PJo+FO5nSPYZgLDnvZXwyiy7bvCKPI1blqkpZiEtsPripc/MWaefVmWF8kPKKn00fY5a7NvFLBPeWltRJ5xyqia++UYIpBC1zs3N3qjtXTMxKIAeweizH5hnLJRhc0PMcPrVB5hCfxcV9JzPjrL49a41YCaythA0fm1JGaI4xJDzFFbahfavM7dwcWLYuXefzvurcs0Ni24M/Ex3Eqn3NOTA/NWrhVwQtDzxHyja9s31w1+ZomPLTse4Y75ghnYzS8EsTOxuxn4NPIU1OXLkyBAPIq6GAmFV5Zb4oyj0B03vD4/+JmeYt49iXsBkRPORWmyJzRwiJgoR1/wNfp3LAJghIy9HcxYtCEtr23fY3fxiExxo+iqVtasJkpcmfazRC9doaGJeyMoLG2UYKNHKfcwMf3G2mf5zlmngnBQNm7dCwxamatiS1Rq6LEuDU3M0aLWZ9yYc+hILsGsoYbPMDQWg4yY46In6FyyrXRum/MYty9ZvxqvzrK6sTJ+et14/r8nRL+m5+i4lVR9MmaGarXezeldS1br1dfnfrtYnn326QcOjif5oggI0LCCm1gi6MC3DIKPl2ckWKwmfPHaQ6e/NgT52fLDASFcF7M5IRIPJ3vJzSzqdUxyiNvTAxl6wA2j7X376WU8/071gW/T2bVS9bu3wOq+qlQte2omma9CoofYzwUCmJ5tEeLbn9hBW25p8XCnseovw99x5Cvvdffnll8Gy8TGNXoPSYIxZh0AWKAt1eHcdrh3jW5AT8kceKQ6FKTt/sHe4/4aQVGyFxR5dYerJTDK0PuuBCUbwUj5epfvjNz8ocf5irVi20szfdK1KX6Pk1BX6ZdrvevK5Z9SsZQuT+sagaPuKFbTH8SfolY8/14h5qzRoofnaYYltbkECTup69WKF24+zdUXvEbqh/xjdPepNPfrOp3ru61/Ua9pcDVxswmB5uvn1meqxrEDr9+W9eOYWUII5b8VjBGEzjWSzIEywsPsO6+XHpphWN2zwDv251tbfcvL13apM/ZiWoc8XJen1b35UlWYtrb5V1ahla916x+3GoN8ZMAEUnV7Q8QwABbMfCc0mJEzt4WszyAwciRlEcKN+t/c9124K9Pzdx8WPMz2H9uC+zky+w6oTjBMdx21B3N3YVjlm9VDvsIGCHWQfgTnz5mriu2/r/sce0Wnnna2Dzc8//MgjgpnK5pcP/+cRvT5xQpi/drMe8jZG+2BHIx9XCoqRjDrGyLGDK+Z7+0cxR5v5RACibNkqm+vIkyEj1gU5fy+NcPxDIK8w4kFEonmDLfP2gJ1IogeniO6zlQ9TdXffdpcGDxwS9nj/5IvP9dEXn+nFnj106hmnq37DBiGAV6ZaddVu00Zn3nCjRv48ReMMtEyrsYMO8+2shR9qIL5p3CS1u+QGJex1mMrv0UV1Ox+pXY4+Jbyk8q4RY9Xzu1/09Le/mJmeG7a+6md++sA01sbn6KXENL28aLV6Ls0Oefto+N4pJkiW5IbpvEHJuRqxcq0m2nW/GK+6lv80MVnfp67REvv96bxE3fX8ywb6XUIGYRszyV546UUDHH9lcOj0gkg9vhmvd2J9NOY7L3nAT2WKjn5CWBKd9pcXxg40vykAh89Yhuc8iOMU3As2YICJXNOTpEMiRwDfBoq9z9YmagUbRjV9kIMF1Q3W3qzFCzRt/hz9NmOafvt9SohIM9e8NDkpZDL+rxBj5OMHYbpjjjM1R1IOY4VlRgAWiwzh7yD2cUXo+/jjHhL85jqsa6whhCPnQM47JaEtgp6G8CAagMZHW2GuUHly8jHVatWoqV0aN9d+nfbVicefpPPOu0DnX3yRzrnoAh1xzNFq2bpVeOsJb7nBTN6j60G667kX9OovU/X68iwNWwHoc9RnSbr6GFif/22RLnh5mOode7YSGu6qhJrNlVC3pcq12E2NDzxcB1xwmc69/2Fd8mwPPfnNb3r6t3nqu8DM/5RMDUlKV/9FqRq4NEOjVq0PAB+YlKP+BvYBiVkalJihoUsyw3vvXktao+/XZGu+Mek867/vVqTq57TMIAQ+mDZLtz/ZXeUMsMw6tGrXVo8++qh++vF7zTQG5vXc3333TZDIzGiQWILlw5tIeGsLgtDNbwQjC0n8LaPOGEUBvQMe8u9o8c8//zxoegJlgB5LgilWmC16zbYkngLg/wD6AlkYiK+wdYFg2JDTYW0L7bbf26eW25aiY+Xf+cSCYTxQkvjljBF+/dVXXx0sQQS3m/c+Xoy9/2Zal23qAD0BdCL5Ub4pDW0R9P4AGJI0XCpM9JjsIF6ix2aIDes3UI3K1VWlfGVVq1JdtWrVUY06tVW1dk3Vb9woJGsgrZo0ba7OBx2q2x94SB/8+Ku+XZFm2jZTw1Mx67PVPzlT/RPXqOf0JfrH8De0/1W3KaGNmUa1zTWoUNeKdR6lfnNV320vNexypM7899O6/IVBuufV9/Tk+1/r8Q++1qPvfaXnPp+iflMSNWBakgbOTNHg2Ss1dPYKDZ+zXMNmJ2v4rKUaPX2+3ps5T98nLdOPKSs0afosvf3rVE36fYZ6jXtd5133D1WoUye4JfigF114vp54/FH9+/77dO3V1+iqK64MyROsUQDYtBGtTjSdpBkGmu8kNiEwo1Od9CvMQSku6DmPoB1xAp6JYOE5+H3RPIptTdQGwAdW5AclBvQuFP7bigIC9L4s93+FHJTEbTDHyU1BKWIRowAw15lr970NEd5c4+MaHTeEuq+uQ1hgIfnfSxuv2SLooVjGI9uMhjGFcNcddwbmP+nYE9V1/y7af9/OOvDArurctYv2O/CAkKiBVXD0kUfprDPO1uNPdNc3v0zR/NR0/Z6epXftc9SKdNPSqzckzmRrvGn+AQb8f0/8WIdee5c6dbtUdTuaqdPEtD4r51hKy+60leqoVseD1eKIbupywd91wnV368Tr79Hx/7hHZ9/zpK7u3l/3Dn9L941+Vw+On6xHX/9Yj038SP8Z/74eGvuWHh75mh7pN0jPDx+lZ4eO0J3PPq/rH3g4lDP/do1226+zqgF6os9lE9SmxS7ab69OatG0iapUqhyyyRzgPjXnPjYSmk80PltAIfkZrGhfMoiUooA+dgywGoh8o+09wBp9kykUvc+2IJ4Cm/8B9DxyQ1X9b5RQJ/Yb2PBuP2jDxw5N3tduduPqkXGJO0cGHjyAUCYQzgs8each5Ocz5oWNF9jydGtAT96H/51rSkNFAn2UqKAXHj596jR9/eVXevO1NzRs4FAN7D9IQ4cO17ARwzVo2FC90ruXXh01WhPGjdf40ePMPP5NGbnrlG7tTLQ2/GLlw/QcTUhZo1GLV4YI/fjlOZq4Yq1GLkjVU5O/172j3jFzvrs6n3eV6ux9sCq16WTmvml/3z2nciOVa2iuRqtOoVRptZdq79FFzbser44nna+9ul2s/c66Ugee9zd1Pe9KdTn7Mu1/xgXa/9Qzw553+xx+lDoecriaddpb9dq0V7M9Oqlh67Z270qqVLnghZNMM9WpXkVNTJPXrl4tvKShbes2IXmCKRikOrnV/hYaH2xMfgKdvl21953TlkDvFL0GYk6e2QBAz7MQMjAae6x7YIx7bUuiRgHQ/iNS+OBvmPV89+OhGPBpz/+CpnccQMzcsHMtO91g+fk0N9mTxMOwkKPbljM+UX6IjjHmPOnVKBMUC+tePDfG+SN6fnGoSKDnIYU9IDCVHSZam5uRo/TUNUpLXR2i96lpq8JbazFl2C03K22N8uwc9pbiThgoSfY9xT5nWPk+a50mLc/U6Llmfs9boVFLMjQiMV2D56eq37REPfPFr7r/tfd1ZfdeOub6O7TbCeeocecjzec3cNZoYsBnDb1J1gq1rNQscANYR896eP5WraGVBgUvomStfBU7j+242bGVQnow2zJXra6q9RuqYk27PmzZzE43ldWxXRuddNQRuviss3XVJZfo7tvv0PPPPhfmUglyMoXJ0kdyyD1ow2CRloppFgVgdNCKCvpYYvqGPQ8w8ZkSpJ5E8Mmh8CSdotyntMRYBs7wL+FHwcdGgQDxhepQIuf8L5CDnrgXs1lodSwvxoQgHsIY7c/0dmFUGLZIg2fLOpJziAmwGaYvqoI2hcmi0BZBH2UcZ9I/PNDNtciAcgmgn79wQYgBpCxZqrzVGYELctfkas7shZoyfYF+nDFPc5anaWpKmqZnrNWUbNP67EK7ME3DlmRqcHJWyJwr8PXT1G9ekvpNXaBnPvle/x77nu7qP0pn3navDr3wUrU94hg12PcA1dxjL1Vut7vKt9xV5Vq0N6HQUgkNzCqo38ysg8ZKqNdYZeo1UsUGjVW5YSO1bLebmrVqq/am3Q88/EgdfvyJOuTIY9Rm1w5hC2e0/D577KG7br5R44YP1Wfvf6BvTOpOn/K7liYuCVMvRO6ZQmNqxjUv0ywE9ZDY+G5QLAiLCvrY3xDaHCYjwuvr60niYDUkaZ8EirYHMfSBEzZ+KfgA8BtBHw7Yf7y+mxIObvzYoclxwHZmEyZMCIlsLH1GyzN7gyIAsMRaGF/GzfkB4nqOb8TTBuIcZoIQ6tyHDD5fVFVaKrJ57wzqxO9QUerKh43whlks8/kzNG3GdH340eSwPnri6xM0c8pUJS9aqt9//F3jx0xU3wFD9dqb72vMxHf19kef66f5SVpghsCv6dKklCy9sSJH41Lz1HeRaXrz9YevztXw1GxNMF5mc8sxS1dr+KxEDZ8y23z1t3Xp48/ouJvv0CFX/V2dL75Ce517kTqeeb46nX6B9jz1bHU48TR1OO4kdTz2RO1//MnqevKpOurUbrrmhht05VVX6+bbbtcT3Z/RMy+8rDvuuVdHHX1s6Oy6NWvp7NNO08SxY5WduqpAouXnFbzBxiwckigIzhBpJesODY+PT4YcU2iFRdPpRz9WFNBzrDDifASLvwoZ4JPqG91Ca1vTH1tWQBxz0BOwCwdo0gb+CIes/f9L5j2bZLCTr7/enQL/sFLVsw0h5tjdn4f4DsB9zBlr5w38eHgKAdKtW7cwTcv5nBO9R3Gp2D59LMUyNMRiAfxYopUwJHOVLz7/QkjRfOetd3W8adO69Rpojz331p4d99HxJ3XTQ088q6+mzJTBKuTCf52aqfFzEjVu8bKwO+2QxBUatGSlhixL17CVZgGkWlmeoVEp2RqdlKURi9dowOxkvfLbXD3/7e96+ouf1f3T7/X0h1/qyXc/1hOvv6unxr2hFye8rcHvf6TxX3ynSd/9rLmLlgQpjVUye+4czZg5O6TaokExmytVqKh77ro77F2/YtlyZawxqWRNRmJzHdsXsXLOc6SR8mRcYfZjom2J6L8AABvIaPHjWyK0CwKG+AHPpx7k5bP/GuT3jhLHYgXL1iZq/ofa+4H/94cdm+hLFlDh3sEzHtMhoEv0HWHArI0L+uiY+jHI/4YAgQj6ks/Atlrcj9iRJ19FrykJlRr0Tl4BJBBgIP/apR5RTOaxWUDAwgrfhgsJxhtMmzZpoVNPO1M9+gzQlHmLwhJXwh3kLH2zOluTVqzWhKRUjVxifqyBf8DSleqbtEoDkswCSMnVqGX5BcW+M/8+cukajTZLgLfKvpaYqomLUvT2giRNWpCsr01w/L4yQwsz12u5CcvMvALmB8QIK2Yl0NCsMUB7MgXHarnodBu71DBlBrDQ8ACdc4my4r/xjgBiGUWZWvHBLinoqS/7ovuiKArfSZ2OruaLUlHuG6eik/M07hX9jwAmsEu0nhR118qxY1oY6F1Acw2xGV+dR6wIi9L/DkXvVRzaaqB3zQGjY/KShkpF6QRMXuazmYZg6goBgET0qHiFhPJq3nQXnXnWeXqpVz99/ds0JWblKdXuxybRs+zWv1m/fZ21XpNX5Whi8iqNMfCOSVyl18zvf920PeW1pZkax0sq7DhvlX17ySpNSkrTJymr9M3y1fptVabmpOdqSc56pdo98Xpz1/13XTKgB8wkHwF2ND3WCqmUHjkFzGTesfoQjcoA+6Cg4QnY4Oe7xN4SRQc7Wvz4lohzyPQjks/sAf3NFB65ASy3pU1+f7+ff25rbb8zEKY5c/K+NTm8wDjggzM9Fx1D+jva59HvnOfjBPE3lCdLsQkKojh79+79/xbplIS2uqan0pi1aEeyxAAOCQqXXnppMFcAD+vrkWDMc1diiSWMaqVFi1Y65dQzdO8Dj2jImNf1/jc/anZqhuZm5WueYWiGKc6fV+cF0/9b8/F/zJE+WZGtj1fm6bPU/PD56coc+56tr1bn6If0vLCA5vf0HM0yIZJo56PdV1u/Zlh/Z9tnbl7BIhkK+QcjRowI0VcGkOg7wouACvPifJKURO44bXOAEbRjfTTCwCOs9MP20PQQ00AE7xBERPC97kwXsrDDg3rcF3Jm899xKjnhoxNDIReFIC57JpAvgf8dHT/63McV8jF38vGOCgJmaBAoAJ57YzmgUEtLpQZ9tJJOgIeOIJrtoCfg5FNJfLKc8pijjtYuTRqrasWCKHnF8gXTXLvu1kEHH3G0up13oV4eOFTDJryjN7/8Vu//8Jsm/TJVX89epFkGeuA110A82/puvlVjDsV+zzEBMd+OLbL+XWyfSVaW29/WWMmygkXPtm6UvA2ghzDxyXlGYxOLwJ9id1YkLNlumO4cZwol+PuVKgUBwSDzymkPnjGY9Av32xL5YHNNtPjxohLMh/vELAJ5+NSPgCJp08wgUB+/X2FjFqeSE4IVQLIqDreWF076NtX0tY9pdAz45JhT9LgTOPJpWSxKrDly8Es7ftsE9Gg48tF91x1Az1ryqLmDqd+79ys6+qgj1KolWz8V+KNkv4UMuEoVVdNcgOat22mfrgfrpLPP1UVXX6ub7rlfLw0Yos9/+l2JpsHNlQ8bYBAA9IJbwCfr2dgGC0ijczG4w9P5j2rzuaGP3RzH/WCji7POOisEyNDgrDDEZCMGQcGUZykrbgD7tJMnjVSGuA+lqFNm9IczQLT48aKQjwFuCnVhFReaBxeKjEAYx3f7cSrqveO0ZXKXln0OUGi4VFBhfRwd19jv0U8IZUSg1resO/fcc0OSTlRYlIRKDfrCKoufQ5DLd3dBI6I9YUhnUHyT2bNnqmevHrr86su0657tVa12VZWrXF684yzsqMobT61UMJ+mhvnY9QxsrdrvrmNPOlUP/OdxjXvrXU2ZO18zFi/RwmWrlLQmQ8szs5Wak6c00+Cr89eGl0visYd0Ans0S+DXZudrXUauctOztSw5JQwUAom1zwRL8McIzLA0lqgp8+BMnWDGA3S0JxYA5zL/SrCGdjEYtJ1SVKLfKFHAU/x4USgaP6BfaQdJQWy8QConG6FEEzug4tw/TpsmxsrJv3uMqDCK9jk8478LGwssReI1HsFn2g5LtKjxok3RVg/kUXkkHcEv/HYqi6YnDRGpBSC8c2jm4uREDRszTOdfdr467NNBjXZpYhrezOfqlVUWAbBh5xVec13wSqyyqlm3jg467HD97e/X6T9PPKnnX+6hYaNG670PJ+u7n37WzLnzlGhgXpa6SukZWcowQZCZnqXMtAytWZGmFUuXKXl+ohbPXRjeKMtUCK8LolOZZiFyz8YFmFQEUQA9x9i4Ar+dhCPiFgDM20L7aRvS2QezsIGMJT+P+0RLca538rrwSR3ZvZhxIHkIU9H/VpT7xqloFB0rB7tjAXDyPdrnseNV2HH/jgXBi0yw2hz0LMT500EfrSxEhWB8zHu2eybQRRCC5ab4llHKX7dWiSlLdNs9d+jUM0/TxVdcotPPOUPnXXy+zr3oPLXr0F71mzRQ7QZ1VLkGW2cXCIAy5RJUpVpV1Tbw42OT+84bQ8gHOOucs3XPffdqyLChmvzxR8Hk+vLzL/T+ux/o9TGvaZi5Bi8984IevPff+ucNt+jM088IQMeE8mWqfDL9hqYnGIa5TICP+hM0YzB8MGkvhe8O9pIQ10XvCQNROF7Se0L4+tyX4r95BlokViNt6jleB79PtEQZkN9O/j3aL9F7+LP8eCxt6vjWptjnRNtQnOfDFyThRN2o6L1KSky7Yl3Cl1htgJ560e/FsSijtNU0vRODTGUAPWBCW6LpAb2vMPLOoOKTJn+gk045Ua3atFSXgw7UMccdrTvvvkPDRgzViy+/oOtvuE5XXX2lgflMHX7kYeqw5+5q3JTlujVMC1cJ786rWaOaqlSuGArJKZhDmOdsO/z3a67VFZddrvPOOV+nnnCKjjr0SB2wT2d1aLe7WjdvFWYQMN2Za0eAMO+O7wTQ8dd5lxjSFhcAbQlQqL+D00uUuUtCXBe9byzoS3pfiPtSPA+BuAUCDCYl9uD33tQzOO738LpEC+T1hjjGuUWh6D2itKnj25OK+nwsPoJ5LJ8moMtU29Yi3EesZHDExiyY9/Q1pSizQ4XRVgO9dxCDjRbBpwf0zFuiOYnee+TRz0U4jBszVgfut3/BKrYaNdVht9310AMPas6s2UpemhQ2qWC5KJ1Jpz7++KPhLSrnnHOWSb7jdewxR6lrlwO0a/u2atignqpVraxKFctvjK4z3UG0vUaNWqpauVpIBuIVVRXLVwrfmS3ASkBAAHIy6Yg9OCgI0AGMKBPz3Zk8FvAlZVS/NnpfFzClua/Xm/uRu80iDmYbiASzsQdRZp4Zpdhn8dvrEUuFXevPjFJh1xZ27M8grzPFx7I4xEKae+65J2hk+hRgRpO5SkPw3yWXXBICyCgyfHzG0utbEtrqoIdgVoJcJLYAeqQUqapozGhF2Sf9ow8m6ZjDjih4p5mVutVr6p833ax5BvrM1eaHclsrbLiYZj76vHlz9P3331rjJ+ntt9/Uu++8pbFjRqt3r5565OEHdcM/rtPZZ50RNDZz1kTd+ezc+UAz/w/TUUcdYyb7KSY9z9XFF18a3sTDggiiogDAfXIGn3YgwOhk2ufMEQUm351R/JySUmH353dp7s21EGYny27JFGMKiMg+U3sIAtoZJZ4fJa9XYc/3+zvF1tOv9T5y4nj0OX6dlx2FcJdIyMKVJdDLPD3Kg/TbrdEOrLMrrrgiJLiRcEU+Rux4FZe2CegZTDqC6L2DniBEYaB//823dfxhR4ZXOG8E/Q03afb0GVq9MjWAfeNKPitc72As8GmMofJzlb4mTSnJSzV9+lSTtB8Fjd2jR4+Q3MDOtFgJ1Ontd97T5I8+0ZdffaMffvw5SFI6NsqAPAPTyefvaRt/jwKdczjOp38v7SD7PbifP4/P6POK+wyupb8wE4no+xoBYi1kkZF0FGsmck2UvE7RZ/sxJ75Hf0N+jf/Nf0fJjxVW+Nu2psKe6f1dFMKUZzktFiV9yifJWyg9xq+0RMo3rjGaHtBj8Zb2vtsE9HwnH5l5bkBPhfFLSB7xzuQcQN+7R0/tu2enAPiq5SuqVdPm+s+DDyl12XKtX7tO2ZlZG4NOFBg0l1Vu6woin+xMu37De+G9sB89mo0IO4PiJjrX5681ANtpLkeiRN3C/a1wLoNPB/Pb6xDLEHynHtH2l4a4D/ek+PP9mSV9DsKL9GGmItHygJ40Y8YHYUC7ohRtHxT7XL5TL/rE68gzEJ70M5s+ogELI2+b0+baU5K2bk0qyvNpJ/EfZnvgc/qW708//fTG3I3SELEkhAiKEyVKph99Xhra6oE8J1JWqSygpzBPz9SRdyQDD3M89eTj2q1tm+DT44u3ad3STO4njIEK3iJDA1mCSclZmx/emJORkx0+sw38aWmp4dysLECdo3Vr82KEwB+Jp1MMQkFwRIFM8e9OMDTnUDhO/f1ciN9ethb5MxxQscAvDnEdzMcsBtYWi0LQSAQ7sYDQJNx/cxTbPuoB4AE48/9YC7wumxkOXCXyAhD6xEQIcmGR+fV8enucOMZv72e+R5+3rYnnwYuuHIpDXIsf76vrAD7WFFukbY3lzYybb5vl0Xsn58Hi0lYHvQ8WZggbOiChqDBZbSSNONFZBDtefukFdeq4h0jDLV8Ok7OJmUsPKXlZkjKzMwLYASh3hU1yDaiAn8J3g4cdBYRo5GxlZaYr2wQAJn/B8f+a6hReIw3YA+DtHlHmcoaEob1A1BVmdABGmZZrtjaDcj/qTYk+j9/FfRZtpp8ZD+IcTJ8SvMQHxfJyYRZL0efEtpH6cF+AwiwNOf+82AOBwv1ZR05eA2vJeRMSFhfnO3nbnKgDMyNMe1F8lmR7EG1JTEwMATJcQra0YpqMthWlrzmHHA8sKF9lB+gxyZkpKS0RVPb978EQLjLEc6l7SWirgN4B4ERlSEtk0KksU3b4I3SodyRmEaY36a4EP5CQRNxZFkoaLFKX+3iBSVzjUwAsBWC6Oc551IVPfjtDb674eX6938NB9mcT/UXxOnnx40UhtLm/k9BNUNYSYPLTf7TZiX6AeIb3hZM/j0+0OG+n4a2qvsUz4+f3Zz052g8XgrXmBEoxVVl0xXhBWAFoQ1Ky2X+BoCrnsiyYLchQEkzzIrQKayvj48ejbSjuuLFZBSY66yjY3uryyy8PlmosRdvvhGXA2gxyRWg7Qo/2EzymTbg8Xjeui14brXNhxLXskc/iLpQnqezMDMTep7i0VUHvFeGTwQX0mJJ0Ah2Kn8P0BoONWYgWQIr5ggI6jOwjzEPOoVO8OEi9+PEo6B0QzrCxxworhQE++pw/m3yAY+vtx7dEaFimHxGu+PGMBVOZAIz0Ye4FRe+FwEUgYFoyZRpNAqGPGEMYHSZEqzHGbtayyMetOwrPJP8B14IFKY8//niIQKOxmNa95pprQgIUey/gCxMIoyCg2O2XhSyAh2f6ePDpwim2D6L94m3bHHEv+oH+IBmLKDmuz/33379J/zn2mf4WG4Qebac/iOSzqCxqtUTrBm3p3oCeLFYSxbgnljP5AFxXGt7cKqD3CkQrjKYncISWd0YD4EQ6iaRjFrIQBIYA7DQKBmElG6uUYFYa52DkGdHix2O1vP+d70Upfp/Y62MH6M8ir0dsvYtaP7Q8CUZoHtfCpBUDWv7m5PfiGKCE6ZnPZ/bDzVT6CFOYTUIwNXETuB9mLUxP3IapWTIjyXBE2xPP4RzGF6HAeHMeS63ZPw6GdrPYz6P4b+5DUgoAQgBRh1iiP5yK0idR8rFGs8N7/ly2HWP7KywR7+8o8duPIbxos7/rAOCT8EXuB26CWzYQz3PyZ0cp+ncEBhaP77nH2noEOPwefX5xaZsE8qgMzAFjoblhDgYSSYgZxGATlMD0o3P4G41CumNm0TA6mg5wQPI9Wvx4LOC9M/w8jhe1RK//q5DXJ7auRa0n2gIh6wClrxkDGBXTNPYe5OyjjRESmLqMFdrGz8MUJkjF37gfaxN4oSnBLIJ47JWApYaZjgDgejSna3/GGbOflYooBI5TOM69qCdMHhUEKAy2osIlIcHLifGCvD+wUOA7BBe//e9FIcDNDkS+8Qt8ySpRfOrNBfd4DkKQVZdu2tPHvt5kc6DnWu9XJ9rixAwUc/5uQbHTMRu0+Dmx1xaVtgroow/nO5XCPCdazyYUmCVIeDoEyU/n0Ah8QQaUQWfAMeeIKHvUk3ttCfSxgHfiOyX2uk0VPz96j78CeZ1oY7QUta70D+YxjEP/I3hJ0CHa7v3mhADF5ULDo4EBIuOFm0bQD5+cCD0LqRg37kfyE78BPT4+1hvv8uvVq1dYjcgnFp8vTUb7+7VeWMlIkBFFQFYbmh3BxHkAiDrwHe2LQCLxxYnAHy9ZZWdgwMerx3g+x4pC3rcQc+vUAxPf2wY/Ru8V7S+Ia7GGcF/dYqUgvIijIHTdvIec15xix9Drwnm4wFhE9BmCEGHK/Yoy7pujUoOeCkQ7wn/DbAAfJiITjKwi9ykpMCHaAokO4H3eGDMrKlkd2NwzWmKPF9YRRekczvHyVySvG8wQLdF6b6kQlYZp6HfAgykO6Ok3J86jPxkvUkoJrvpYkaaMBcauQYwjJrdrZ1wF/FcsAwrnki6K+Y/Jy/vc0FAIGsBEARTcl2uxBgjcYY2QPAWv8B1fHvOYeA+CivPhE2YdqAcBLuJG77//frAoiRcgFNg/gBTjkmTEEWim7t5ugIub47n03C/aZxBjgXAjHgE46ROuRQiwEzTxEM6BfDyiFPvbz0VQ4CIjhLgf48EKT/97aWirgD5a8dhGQCSAMPBIdBqA6YPZx7QGA09hcJFq+G2YQ964LYE+9vn/a+Ttoz+ixY9vqdBXmNy4ToANpiQTD63h+eGc44R5DHORYwHjAlIEM0BnGg6LzUHIJ/dDgMP07tOimQEon6y/YAETgToHBAWtCEPjZiDoeSZ7FBDsZWNS9vfDnOd58Idfh3LAnYB37rzzzhAERKBQVwKA1BXeIspdHGI2CauEqUeeg1DDDcFNIdDn/ekU/Q7f0l6vI+WEE04IC5t8rKDYezhFj/lYICyYOnQLGUEdbRPnFXavotA28ekhGgtRMSQl0VEYgwbAdJiQaAEEARqfY0RyfUrH/aCigH5TVNJO+SsRbaBEAe+MVJRCX7GuPhrIA8gExvwtuk58p085jvZE0zI2+LeAAJADKr4jQLAecAMALy4c0XxAw1hyjQOAKSeP3aANKYw7m6UyLUfMAEsCwcQcPwyOBYCpj7AB6O4ScA8Ahu8N0BE01Is20T6ASj3Y4NTzLDZH3n5MaQJ3bhFxL56Be4pv7X3uRL9CPAPB433r9cPawNKNEtfH9nf0E/LvCCEUoMdOEJ64WBDnME7UqSS0zUDvROUAPWYSgw3DMLjXXXdd8L0I8jCgDBrTSphrDmY61pkccyda/DjnRTvtf41cyHl7Kfz2NkePF1YIbuHv3nTTTcEMh4GIpRB44l1pBIZi/UT6F41P0AxTGjBcdNFFwf2C+QjOYsajYQErlgSZYoydJ+sQn2G80fb+PHI10MaAlPl9AEXd0JSAjXOpHzwCT/DJMSxDStRSgF8QEHwCMoQIFgDCB7Oa+EMsX/DbwQrxm4LPjlvBAiTu6c9A4HCce/n59E2UmBkhyBitM8AnjhGd6twSMVZ+fz4RJsQYaBttJMMRHBUWfC0ubXPQ0xikKJFRD3QAeoJDNArmYUDpMExKMse4BioO6EvbEX9Vol2bAj0lerywgrZhzh2TGQELEBkDtBg+N3PMRKjJmnNAcF+izjAZLgDAZH4YMxwQEBgkYEesANcNRuRaruE+LIUG+FgBjCvmOT4+0Ww0F8eIjJOwQ/INGh0ecJDDJ9QP64BzPe4D8zsgEQBcw7me/ceLR9gFicShKOC8D/l0om/QphyjjWwoSn1dUHFfhBsvpERw+jUUJ77jtnr8w6+lboCeKbeiEPfxuvl3MIN1TLtpJzkD3A+F6BRtT3Fom4OezkaSItWpvIOeve/HjRsXNADSlb9hTpIO6czHp3f0zgx6SrQvKM7E0WOFFTQGhcAWJifay4FDv7OIA7eK+WCW2UZNYu9Tf5YT5wBwIueQj5fXB0HDVJMHtwAuWhjQA1AsDiwEBAQCByuC8adOgA1XBOuC87EY8NHJ8YBXiOrDP2hlXAmy59h5mVwC+GJLRB29UG/qwFQjwMVVgD8RPrgk7AFBMM3v6+2E+I7QIOkIYFJ32sC1CCmUXKx5vykqrM+ZtqZt3BvrKLpYzcnPLS5tc9BD+ERMpXjnMOgkGuBrEnHF/GOwHfTeGBrpzBsFPMWP+wCWtAN2BKJt0b7wUtix2EJfcT3MTVQcE9sB5oUoNeDHlMdMR8twnT87Wpz47udAaHs0JlqW5B78asbUNR9AZX6fPHUCcJjFZNnxPM513gB4+PNYFuxvACBxA3EhsC4I8BELQqsDdoJlHpCEvI580v7od/8b3xFatBNNjtviz6cAMoQMwU4AyXXuckL0OzEnzH4EFEDnOoQbn8Q02AoboVAUKswNINbBTAVjRZwiOk1JPbwuJaHtAno6GIby6C4MgI+Jn4I/hMbBz0OyMxUT7dwo80aLH/cOKE0n7AjkfQHzUbz9WypO9BnaA+F76KGHBlMWrcZ48EmwDB+dqDgmK2Y/03poUAQGgtuzJP1+mJv8HfeBnAyAzDiz0wv3BwyY5NyfqTTcOfLs8fsRQAgHnsH5PN99diLWAJ3pQ8AV5Qcfa757n0Aco37UK0rRPiB2gavCc12AMEXnCTnUF8Bj1jP3TiISxD0Av9+L53IvMkeJJVBvBz4Fq4Z8huizN0dRTe+E8qMeWEqA3rea87Z7n5SEtgvo6SA6EY3u5j3mHQMO6DGH0AikZ8ZBXzh5Xzjoiwp+zvG+QaOQTw/oMOkBIhrOwQbjMv2GCY2/T5IMQoIttkhSwQWAmXHLACW+PWnVmLJE4gnywaDO/NyP+zO+TMWhvQEKmp1z+WSaDH+avHeuQUhQH0x6tDwmsmvbzRH9Q1uj/cR3CIGFwKPeuB0oF9pO8BCFA08CLiweAIsrCsj8ep7N9+hvAp0Ep2kvCssFKNYNU5S+MGZLxDmxgopjWCC4NtwbgUgkf2vRdgE9Zg7mDgxF5+A/YeoRGAL0MAbHYQICed5ZfDrzxkFfMtBDfLqWJr5CYAorC6A64yN0o2AFeBwDsIwb5+GjI7AJCFLQyORXwPiMIfdx0KI9GWf8blw5THmeS8DNp24xXakDpvpVV131h3gDz+T+CBT+jpBBYAAmrAq0MP42hVkGlAW8g4aEr7A6mPtHmyO4mC1CiHFPLE7XzA5W2kBAkdexMd1HX22Kp7BcqQdTle7CcB8Kriv5BbS3KOSCJEo8F7cFJUh/oixj95eESsrz2wX0MBzLZZFYdDbMQKCGKR46zv0pfLmopufTmTcO+pKBnn4h4EY+OsLXzVT8YLLYADVaDqA6ABwM/psxi37nfJjd58c5DuMDdDQobgIMizVBNJ0AIc+HD3Dr4AOu43r83759+4YMPObnAV8UlNSPdFh8bGZ3EA5YiQgDotvECK6++uqgvQmqkRJMsJBAH9cxl4+QiY1j8HznOz6xbphxQMN7Rij967wVBSeChtkQ+sDvR/u5D9qZWEB0MdPmKMq30e+4TQhL+ohZDARd1MWAChMYRaHtAno6kf3ZMJ9gHvw9ZwgYhEbROFY5RTW9dz6/aSyDAOCjDE/DvXBetOP+14i20U7vC++PqBD04sfdJ/b+8XNhKkxZQEUAykENcPH5Mb8BC5l0gAfNjlZ3JgdE7hZgmjMF56vy8Jnxx9F2PN/rzHfGHaD7fZjOA7RMSVGImPNM6uXChu+AygUTmo97UOAprAIEBXVCIMFLLjQofOd6/03hHlgWKCCmE9HwzCRgCVFXJ/oMYeV+N3/D7cDf9nvyyTOwgrAoiBvg0tLuohD39LHkGgpBRqZEaRt4IVZCPfz80vD5dtP0gB4JTyfBWORwY3559B7JS+oi2t8b5NFPfkc7xhmeY95JFM4rTWf81Ym20U7vC+8PB3K0+HGY1c+lADyOE3lGO3rEmYKmwvIi956MPMYMXxzzGD+X2RVPiXXAAzqSqtDWmKBE70lbJciHhUEEnoJJTN2Zv0aYOCgBK0DBXOc8ovRoXDQ2pjiaH9ADZOoKr+BGEHCjLhyPWil8urDgN3zF9ZwLyIm2I9BoC64G5j/PpO4Anj5ycl5ywQVRR9YKEMDjGW7pwNtE29HyBDah6L02R867/gnRfwhP+oe24g4TUIW8LiWlbQ56GgHjwUBUng5iAIjYAno6CmmGtGQ6Ce3vDfepDH47o8OwzsAcowO8cJ5f+79I3j7aGu0PioPdix+HYf2Y9xkFBgfQgIoxoTAOWFtktJF0A2jJ2IOJAbMvIeVcGJ4CkHATWJIb7X+ejRlMsI+pNQJT3M/n711owBOY7KT+Qow51+G/Ay7cBdfmWBRE23EDSPJBKGCBYMJT+M45mPdYMdQVPx5Xg2ewMAaXgDrhRgJ0AnK4OiimwsDkfQ0BRGIF1MHB7kIFs56pRLQ8fV5UivZZ9DvPZJrO4yS4vvj5W4O2C+hhAI/e01EEhUg8QKszP8ygIp2JGJPx5Z3sncc9OBYH/R9BT3Fw++/CjjtxnRNMzlwwWg9AMS6YxzAvmh3zP5YIcGEKO+jRsmgixhLQ8jyIZwJctD+CnHti1gN8ND2WnoMGnuBvztA+5gCMjD14AsFCsgxpwwgQCuYuMwpujVCYZWDRDjMCnIPwIq8fjclUIRF8hBn+NvwD8RntF+9f5yNvE4RgI5YA/1J3t1Z8sRj3d5eU64rLi5wfHS8EiAc9EXQIqigV9/5O2w30DIhrenwx/D+YjogpTAATIZmZEvKB94HxzuA39+KTwjEGyAvnlbQjdhTyNnqb6Q8KfREtftz7BeK7E/1HNB0tjYZkXCiMBX61x1a8QCyGInvOzwW4mNwIbgDNcyEsO6aYADOaCq2Oxib4xTEY2f1gAEMwzoWM34O6ExOAJ7AMuYYXiDLliOWBe4LfiyvB/gt855M2Mc2H0ACA3MfrD/l3Pp2/Nkd+Pvcjmcwj6rTfA4HEBVjnj/nt50f7vajENbTfxwnBCdh5Bu4EAsyJexf3/k7bxaenc4neuylJAxhAUgvxK90/wjRjLtgDFt54GkdncB8GkU+Kd5CX0nTEjkTeTtrs4KYvosWPR/uL4n3px/HdCdy51iIQhmlM8oqT9y2gwg/2qDXXoKmJA2COO3EuoCRA5wE/xhhznTls116AB0CzAQd5/tTHr6fg56Ph4Q0Axmo2FAXxgShxbpQHolTYsSj53zd3Di4HvIp7QEyA+tAmzHrawiIfgpDEoLgf53v/FoU29WziB+CDvkJhMm3pxBhurs6bo+0CeirI22bQIjQATQ/oMbnoMMw3GIhpE0wzpGqUaBz3oBOjTMwxH+yiDN7/Cnk7KQ5s+iJa/LgX9+3pJ/rOf2NCE9TCTIeZGR+AyNJbF74Qz0KDEuTDHfPINaBGG5FoBTmj+/ZTuACch8Yn4Ie5z/05BujR9EzfEu12om48D5cB0PMs6sYsAnP2JNtAtGVzxD2c/DufXjZF/nfvK9a140ZgddAO6k59aBurBQkGIuS4xqfVtlS3KMXWxX9jvbCen+cgYEiq8vs6/5eEthvo8b+YeqDDAD8aA4a7+OKLw1QHoGdulUGFuaIdwXfuQUNhYD690XSCF86L7cD/VfK2Oqjpi2iJPU5/+XXRv2OSMu+NJnZzlcLiHMzoKPOiyZhP51w3cWFIptgwfaPEtfjUbhXgBgAQkrHc4mPMEfgIB4AcHTuexfw+yS5YEzyHwB3WAud5vbwfCiM/Hvv3wq6PPceJehATID3Z+8eFI/XHXSEgiID0fvZ7beqesRR7ntcN1wWBgqBBKLPhCM+AGDsf0+LSdvHpaQTmH3ugIbUxVYhG4teTdOFMgFRHOMQGkbiHd6g3lsIx/lbUzv1fJPqWfvD+8T7y4sc2VQAnWppZFMDF+KCJSYMl0h21uhDGmLn8zaf6YHyEOTEbJ+qCuU52HOYvgAUo3JcMPcbfgcNU15VXXhniBZCPJZ8E3QjkeeCMfA4W6+C3OzBKQ7F8E3tPzHT6Br7FoqHNuD/0EUBESRFco560OUrci/4tLnkdqBuCkDUK3n6sL1/ZWBqe3y6aHuZDWtJ5VB5/CKkNA2DeYbo4sxEFJUU06rfRQGfqWNDTSaXpgB2daL+XwoDvvzdViGQTlfbNKx2MgJUAHRF7zvE+xoxFW7s7QEEbM10VZXzGj4g8U2sAhvO4J7kYWApusgMexpwpQcifwyeCgHiDJwUhlBz0RR1z54/Y4kQfRInzIaYqcT9xR7BGeD4CjnrzHVeUuXMUVFQwRp/h9yoORa9ByBLY9vaT688UY2lpu4Ae04dcZSKf3mnOXF7oUCQp/j6mJQzjHUAHbg70lOhAOhV27H+NogxGiQK/KAVCo8BcZNX59B3jA8gwa9F2gADC3yYY5xtccC7Ra9ZWMM7e55xH9B2BgFB34YB1x8YpaH/GHM1JXAe/GfLr+eR6phQ9FuSgjy6l3RJF+SNaCiMXWtyffBFcT88n8E8KQot0YrIO4Ucn73+//6aeszmKXkOcA5PeQU/b6ZOS3DdK2wX0mEnkDjOfi9T3zoMRvDPdbIJByMbC33eikZsCPcUHNUr8Lm3n7Ejk7XXG8+J9tanCtBbnobEIGmF9ub/uQGValcgx59D/zJcDRB9LtDnz5p56Sj0QAOSxcz2+MAAngYbMPqL9CAyOAX4Cib6MNTpmaH/X9JyLoCGC7lukl5S8r/xZ1NkLwTNfCej707lwg0c5xvp7ovVYHE7cy3nRKdqWLZGfG72G/iR4R/sZC9qOoGHcSkPbxaenM2AA5oQxC+lANAoBIBpEZ1I8WMN5NM7J70FjY0Hvn85sTnynRAe0sPK/RN7maLu9rzZX6D+0PczOjkZktBGAA2gwG2Bj6oggK/Pk/sJGxtHHkmNRfxOXgLl+LDdAg0AnH4AkLTLa3M/nb1gO0fXiTrgduBK4fdQFhYBJ7VZHUSjaJ16cb3wGg2MQ7gQJRdTPpxUp7opg5pPZx7ShCx6u9b72+zjF/i4K+TV8Yt4TDGW2BOVIEDO6nqGktF1AD9GhLDnERKMDSdYg8omf7z4TAgE/ks0WosEa7uEDVRTQ80nhGH/bXPFzN1V2RIrW3/tqU8WJviA1l4xIzEiA78lUAA7gYcaj0Vn9xXf/G8D1rDwfM8aPnHbuAcMCHDQ9goMgrrt5DnpfLx7tc6L35Ax44A/FgFCCl4o6NtTHSyz5MXgKEJM3j2URBTzCiU+EHKv4iE3RT1Bh9ywuxbbDfzMeRO/Zr4C4B/3E5ib49DsM6GkAqZKAHkZBgpOwQ3CCgaVjieQS1GFjRRrmxD3oBJg0FvT+m07wZ/FJ4RjnlKbs6OR9tanizEN/McdM1B2tS4488+8AwF0wwEdGHgtk8Ms55kE6THbiAowzBOgxTbEYcBcYc6ZmSY9lsRXXUvgbVkQ0r9zHkXqQsIWG51wEBQk/WIHFZfro+d5WAnC4FbzkAi3K4i9mImiP1w3XhHojqDiPKc7Ye3l9If4W/b0lim2HXwv/k5yDK4XgoR+ZIcGaYtxKQ9vFp6dhdDARXk9uYM6W7DvSF2EuGAtNj/aP7gcG0REAkMZuCvR89wGg8EyKg3dTxe+1qbKjU2Ftihb6CP+baDu/6TvmptnlBqGMQGZKFROfsSOwh/Yh7oLmdWsAXxcBDojoV4JhBKEYV9eWnMNiF4Jg/KYgDAjw4jY4USfqwTFcgmgcCIHhzygKcR4xJdqHC0O90Ja4DggaeJB7EsvweXja5YIKd5OkIvIQACH8Rt34hACnH4N4HvWH/HNzFD2He/h9EEpYNMQPEEL0Aa8Nox1+jZ9bXNrmoHeN7au68E9oBKAnMEE2FsEeOpr5SKZIeL2RkzeMTzrX78dvBpBAFEwLw0J0Ouc4I9N5/jeIv3MMxo5dr+/3L2wQ+c0n9+LvfEb/5sT36O8dgbzO3j4HCVqFvfIYIyLsaHjGhqAswCWKDTDQwAgG5vpZOYm2RyOygw2g98AgbhwLYpidYay5FqAxF088ged5XSgIf+IFaDl4BhMbpYDZz/0BL1OI5Brg5/ObAjiZOwc0CA7WBeBqAHDyQOBDlu/ikqDFua8nEVEnTGniTfj2pCMTtOMZ9IvXbVuR3xs+ZEEaQo+2oxARtuTjw39QSeuxzUEPMCCkLJrDA0B0Kll5TOFgQtIwGADNgjYAmDTcCwzJMYIb3miPPPN3BoTgEYPOYBPwYJUSggEG9muiRKdx3yjgXSC4ZuA7AsTrw3neJigW9DsiUX8vtIc20masM0AF+Nhggk+EN30KGLDQ3DcH2CSrEJ3HReBcsslcywN+XABmAXAd4AP+xnXEBwjwoX15PkT/4y54EIt7IGTI0wcMJP5wfxQHMQjyDNhrj09+A2qEFVqauBGCBd5i8wt4DzMeVxPXgfvTDrdcaAfBZPbUg5/gq+iYb8vx9nvTfgQVfQM2sLSIpyDcXImVtB7bzacHoERG0eoMINl3ZGIhuYnwcgwpS4cjjTk/CnyIewFCZwxAie/IwCD9iRYT7WRpKDniMAhTf2SRYRIi/dFCMLMLAQbT7+dEpzrwo8R5ruG9XXxy3EtJB+LPpmi9+U4b6Xc/7owG8R1/m/UTAMZBQ0yG/HSyyNj1hWkvxhSmBUwE7Bgn/ob/zPlciwBgrzzGyYUv2hqLAMHA9fAHlgL5AATcUBYEBrmW6UMK3ylYEQQeKQDZBZPzmNfJj/EM6kJyEtOTgIu4EsIrdjy39fhyfwqWDOtQUIjUF+GHlRQb4C4JbRefnsoBYAI7HgAC6IAeyczgMQgUBhaLANB74/wTEGJmwRBoc7QJGodYAQAnukrgB43A/SkEfsgtR7vQaZxPhJqgDJFYosbMP2NauiDYFNEOGN4F0abO94Hzev/VyetLiRK/oxrOieOMA6Y+WtMTegAXfY5mJTjHuDqwYF4Ai/WFL03AFoC6wMCMRXMzT45mJR7gy0qxBnAf8G/Rvgh2hAsmuV8PMPxZFHgpCu7obwpAR8sDJsDOcmL4A1OeRCF4LdovlCjxu7C+KS35c8hRgGcRltSbeAibmKCM/JzYOhWVtlsgD4CQXouZRacjmYlMEpxgkwX3+2AapibQ4nQqZibmJOY6fh/nE2lFCxBJ5lqCMARcYCICHlEmgDFgSoQJ5/F8pgWR6Jh+mHHkNONSYBXQ2ZiwCB2AjTvB96im8wGnTQgz/hYdAL7T5h0J9Jurrx+PthFQ+GId+tWDbYwt/ieF74wFGhctj4tAwgnaCrMcgcE1ABfmJkkHgUzQjPMZT65n/LAM8MnRwAhr33yF5+KDcx73ojD28BPH+c3f4ANAjgvpYAdIuJisoGPunfYAKgfz9hy/aN9CxCKoG/WlH+krhGxU0MReU1TabpoegBBQIfeagcAEI9EByc1uLB45ZYAxzfFdABtzv2xECHMRWAHcCAz8Mc5lQOkULz7w0cJxGMElPdfAEDAM98EyYINOdlvFYiDQwzpzzEhyzzFJqQ8CIGryQrQrCgoXBgiC7ck0pSGvN/WNts2/8+klVsDxhhoi+rhrjA0AJ8oPsOhfgEWkH//czWUEOsAmxTY6PtwDK8EX/yAMUAJcjzXHajb6lik7XEWm0ciBR1Mzhm7i46/jRlIfPrH+WCTE+WzTBpjIPmTmCJcPsEfH1T+9P/j07162NsXek4U8KCbcE/oI5Yb76lSaOmwX0EMwC1Ia7UojYA5ATyTY0zo5joYgAEOUEjMP7Y5GZyBdcju4XZtT3FyD4Xx6CUHiwgHzEG3CMZjJr/OCIODZMBmMRMCHwA/JIGglrA92fkETsY4AtwBTFVcDzUUg0ZmDtu5ooI8ythPfY5nLz4UQFLhZ9Ad+MH1ERBzBzl57CAOi/GgoxpM+gbgeIYqGBZSMK5qZcWG8GD/GhHEj/51krWgmGnUgjoMQ4B6Al+W5Hshj6hDrjVWC7tKxfgBeQ2AAciyOaH2iFG1jYbSlv5eEvJ+5L/1Km/0NN/QFgo9pVKeoxi8ubVfQE/wBwIAWiQzY8afR7ACNwQesaFt8RjQroEfDO2MAzqh2xxfEvCSTypkN3w+NwXV8999Ie/xENAA+JiYe94oKDy9+f/5Gx3MudWQpMNqCCDFMjn/J4gz8QOq7tZlhexFM54wXS96maNvQuE60m/HCDQNUCHcsACwk/HeOQzBq9DkEVxkTsv8QuIDeAY+VgEmLkMXl4hoHKd/9+RzDJOcZCAIK7hnBWoQEgdtofChKXg8HULRN/jeIa6PX8zd+R88pKcXeg7qgQHBlsF4c9PA1/cr5FO+LklCpQU8FqCi+d2zH+mAwCHQ+fgrBO4AEiDCxAD07jBLpZeAxB5HYTN9wLYLC87XZqoj5fYCH5MMtQMJjhtMhpFLCgJiPBOb45Lk+bwxDEqjhfKaW8OdZWYZGZ9YA85J6eYAIIePgjwoBjruPSJ2JF2DBEGiB0WG22EGJHVx+F8aIOxsBaLL0MPXpSyw+xoNUX+b5i0r0JXxIv/NJ2VH7F6uGKUcsHZQdvIiyhH+dStO2raLpXfpASClMPtYiowHxjfGRMcEAM+BFmjNny98A5FdffRUGGZOfQafBMAPSmkAZZjTBGyLuBIMw0/C1MbG5Pupr++B7ffjt9eM79+O+CBQixZimxBUwA1k0glBCqsKEpArjLyKIGACkLsB3a8AtBAYGv5HpRw9WQTAgz/Q6eV3i9F+ij/CrSephqhaBjHZn+g7BXVTyPv5fAD28j4uLq4PbijVKchQKxak0fFRq0DtTUwk0O34WUy/4wqRXMkUHaDCnWWTjZjjZRYCWa9g6mDlJAI/GZQ6WoI8PIGYXwgRrAnDzm8LfHMzR4h2yqY7huBeI5xA/wM8kcAhwsT5IJME3xP0A0EwJYmmg2RFcaHwK4CcwieWBO4KP73X3z03VZWcn+oX+gQ8AOYWZAcabvisqMe7R/qZwbEci5xGUHKsJcXXR8vAXsxm4Q06l4adSg947GA0KeAmekEqLz45mpNJoQ6QV0y4AiCAF4IKoPJoabYuQQGNuat91zo0ObnRQ/W9e+F1YiSVnjug13h58QVwGLBcsCywXfHgEAbMJBCKxBvBLifzTdkww7sH9ovePkv899nic/ts3xSWucb7gs7B+/6sTbYeioHdrEvfXVyKWlraKpofQwszDA1wPxlDIbSZQgxbEj8avj810Q2sjMJiWIVKOeYfZDtERzgjeKVHGiGrSaCmMNve3LRHXUU9cAywCpC5uBpodF4GYAsE84ggQ9ducpuLv1DtOBRQ7vsUdJ+/PHRn0Tpj3gB4cuTvJ9B3Y2Rq01UCP2e3plVQSCYUZzAomAnEEZTD9GUy/BgDxnYIgAPj490SCHRD+9yhA+L05QEFFOQcqjLk4xrW0ycnr7Z/OYO5yRIm/0zaCh8QNKJj8mLBR4rydnaL9X5r+iI4Jn5QdtX8d9Gh6DyCjNLE2twZtNdCjBVmRReSVShKEIMmCiDbmMYPg4HAwYkJHid+AiHtB3LswUMYS52xqoPlbYffgmJ+7qXOgotQh9rm4K8QFSCAhiMk6aOb4sYRwa4gfxNZzZ6Vo39In3i980q9FJT//fwH0mPe4j8xmoDzBE1POWJNbg0oNeic6G01PZhv+O5F45sdh/ih5RDY6uBCDFAsu/hY9Fvs99u9bIs71EkvRY9x3U/eOvYczpgsqPpkZIG+a/AHcG1ZKkR/AtAs7xzB4sS7Ozkr0o/MAFPu7qMQ1OzronaeYriapiUQyzyMh+M2MxtagUoPeAYB2Y6GM73TKnDrZWYDcO9/PdeI7gwNQHDz+d7cGdjSi3mSfsUaAfALm8j2+QcIJ/YIFgMm/ozFlnLYtOc+T0EQCGPxCIJxPYl3u07uCiWKpOLTVND1zrf72ExictFmCeszX46NHTXmY3Rk+FtxRAbGjgIJ6Ul+vM/P0DBxrBghismyTPmE+n2xA8hCYkoxTnCAHr/M76bbMBsEv8A2zYFiOPk9fWlxsNdDD5CQUYNa7T8+cPBKK99ixgADfPhrMiq08jcfv907YUSgW9BCWC9YP03uY9j71wnw+y04JWu5o7YzTtqEoDvjOOgHMeUx7eAbfnqxFUoyh0vLNVgnkkUiBdCIhB9BTUWdwph3wbfFnmX9n8QVz2cyBR8nN+x2NHOxO0QGEmLFAaruZT2YfA0o6cBz0cYKifACW2HfCl6CjLLAUmf2KYiaW74pDW0XTY6ITfMAEwZwlS82BT8X5xFTB3yfNlew7NsBAqwMSAM89YhsRC6AdjWgT202xsMj7hHgHmYksqIid6otTnAjwEvNhFswxxApRgr9bCw9bRdMDWqahWCNNDj3mLGm3nqYKo3sDCEowlcdGGEzn4e9zrd+LsiNpQG9/rKXCcUBPUI8NP9D0BGUQgiwnZbERUj1OcXKC70nuwh3GOnbMsAgMd9DPKS1tFdA7EZxi9xkkFYtXSFPFlGXRSnSxCsxPoI88dpanssiCmAAA8cUqOyL5oJGZR5IRu7GwkIe0ZISdDyLBTmY2PHsvTjsvRUHs/MO0roMev56Udn/XnytFShR7xaGtFsiLTiMQrMNvJ3JP6i2bHmLS4t97QMs/mcfG7GdBC9NcTEtwfWxU/69K1BWTjLl5XBz8MbaKZrqO3U4QeB7nQOgBfhYWof2Ls4osTv+bFLUQwQ5WL5qeDTTgGaxkrGZfVss5paWtBvpNEZKL9EGW1rJogFV0mLe+goiGkYTASjzcAjQgO50g2TxwgUSLlWpbajx/d0G0OeI87o2Qwcf2+AKdjz/OJym0WDEsAsIiIdee7Dq2KMZKIT+BaThW4flGkb4kkvb54LErD8LgiSeeCIsnSNWNU5yc4EV4niXkJ510UuAblCPKgzUeHgMrLW1z0AMiGsIcI2vi0eZsaUSjWFFHo3w1Hn7vbrvtFub32Tl1UxFujsUed/BS/Hth1gLH6TzSfXElOJfvbPRBrgESFSFFJ5NWzJQbG3UA6quvvjpE4tkTANcECwX3halJkm7Q6FGg0y7ahE+G5GbHVdwZ9gr0OEacdm6K5WV4kyxW+MzdYXaHIo0byxBFFntNcWmbg94rB/gBHFqT3GKW0rIQB+3O3nXeQEDDHD8gYdFBlGIbym/uuTkiWIZGBdTkCfiLGwD1hAkTglXB5g3s8cbeamzVRSwCrU3AEWAjiPzlCMxCIKiorxcHuRfaANC5jqW37KpD4hKBTlwAz1UozcDF6X+DXElFifUZbN7pOzhhIcKX7MfoVBTe3xRtc9A7xZramP0E7tg9B20JQDDxaSimMNINvxeNGL2WxroAicYR+O7gpnMQLEQ8ES68fAE/iSlFtsjChUCSAmx2yGG9ADEHsuUIsrl5DoABNSAHyMxEAHoKWpzisxOu0bkHJjyCAwuB+VViG9SHusUj9nGKpVjQs3Sb2S3m5+E9CsFgcj62Bm030Dt54MIlFX4zZj+N5I0pvASBxASW5GJeY3pzjW9qgYlDZhJaG7+Y2QKy/VxrE/nEhMaFIFno+OOPDxoby4FYAh0JWOlIQO3ARaJGTXPADpj5RBCRaASgiaoyh8rLFvgkaEe9sUrYDoyNNHhRA2vtiQEQ4PPApA+utz12sOO0c5NrbtZlsLMUPOc8icUJn8cqz5LQNgd9UUwQNDRaH21Iw3jxBP48vwE8wAfkZP0RPGOzDaYEifijtXlJAuDGzyaQhsWAy+AaGfDSebGmOL9dk7sQoCAE6HCsD/bLY6sitvBCMLHlMu4A05LsooPQIQaAScY6aAJ+br7HKU7FIccKSo1ZL6L2rnTgQ6aB/RwURkmVxnbR9K7ZYgUAv/1vTu6De+QeDQ+Y/L3maFj8a3auxRRHczMTEOtrR8HNcYDv++BjhjNthq/k3xEUTB9i5rPTLj4VFgORepY0EuBjUwzcDeoGsCnUL2q9+EDw6cc3RX5unHZeivKAfydhDVeU6V6UFVqemBOB5q1B20XTxzJ3LPghAOLHo9/RnOyUSu4+O/GghQGyT/fFFv7OXDiCgIJ/TlQdIYEV4FtosykBWxCRQ4C1gCZn4wKi9f5yhSjRBuoU2x6+b+43FG2v3yNOcYol5xtcXhQOKe24pKSuo+VRMJwTy4PFpe3u0xeX8G8w9wErmhkgA2wkINob8FMwgaK+N/kAWAWsS8bnBsxMexDYw3VAezPnToyAoCLWBW6Ez9WXtmPjFKfikIMZggdxbVltB+8TkI4NAHN+SfnzLw965tIx74nys0yX3XgIoOFvA2wCawgEfHqSfwisISVZ1ENwj2Aa1gJZc0hKAmqubfkO0DlOR/vf4hSnP4OiICZgx9JsZnzcTXS+LS395UEPAUg0Mj40mXrsR0+SD9lwmP5MixEt529Eyznfo/7eYU4uUSmxf4tTnLY3RTU2n/AkgHdwRwVBFPB8j/6tOPSXB320oZCb31gABNQ21fDCAM25mzrf/8bzoiVOcdqWVBhPwrvOv3w6X0bPKw1v7hCavjAA+u/YzoD4HZ0XL4z4mxe/f2ElTnH6M2lb8OBfHvRR4MZKQHxxp+jfohQFd2G0pb/HKU7biwA4POy8yG9Mff8dy6clFQg7lHkfC0xAH9twOo2O4jP6N757p8XeJ05x+rOoMEW1KYKHY/m9JLRDaHqKN5bv+PWx5KCOkv8urLP8b7HXQJzLYOAixClOfybBn4XxbmF8W1TaIXz6OMUpTluP4qCPU5x2MoqDPk5x2skoDvo4xWknozjo4xSnnYzioI9TnHYyioM+TnHaySgO+jjFaSejOOjjFKedjOKgj1OcdjKKgz5OcdrJKA76OMVpJ6M46OMUp52M4qCPU5x2MoqDPk5x2skoDvo4xWknozjo4xSnnYzioI9TnHYyioM+TnHaySgO+jjFaSejOOjjFKedjOKgj1OcdjKKgz5OcdrJKA76OMVpJ6M46OMUp52M4qCPU5x2MoqDPk5x2skoDvo4xWknozjo4xSnnYzioI9TnHYyioM+TnHaySgO+jjFaSejOOjjFKedjOKgj1OcdjKKgz5OcdrJKA76OMVpJ6M46OMUp52KpP8DE4/OHp8QbOkAAAAASUVORK5CYII="
    icon10 = "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"
    icon11 = "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"
    icon12 = "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"
    icon13 = "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"
    icon14 = "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"
    icon15 = "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"
    icon16 = "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"
    icon17 = "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"
    icon18 = "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"
    icon19 = "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"
    icon20 = "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"
    gicon = "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"

    g.iconphoto(False, tk.PhotoImage(data=b64decode(icon)))
    # g.wm_iconphoto(False, tk.PhotoImage(data=b64decode(icon)))

    fr = tk.Frame(g,bg='white')
    fr.grid(row=0, column=0, padx=10, pady=10)
    fr_tool = tk.Frame(fr,bg='white',width=30, padx=5, pady=5)
    fr_tool.pack(fill='x')
    l_path = tk.Text(fr, wrap='word', font=("Arial", 12, "bold"), bg="white", fg="black", state='disabled',height=3,width=30, padx=5, pady=5)
    l_path.pack(fill='x')
    # info = tk.Label(g,text='                                   \n\n\n\n\n\n\n\n\n\n\n\n\n', font=("Arial", 14, "bold"), bg="white", fg="black",padx = 30,pady=30)
    xscroll = tk.Scrollbar(fr, orient='horizontal')
    xscroll.pack(side='bottom', fill='x')
    yscroll = tk.Scrollbar(fr, orient='vertical')
    yscroll.pack(side='right', fill='y')
    info = tk.Text(fr, wrap='none', font=("Arial", 14, "bold"), bg="white", fg="black", state='disabled',
                height=10, width=30, padx=10, pady=10, xscrollcommand=xscroll.set, yscrollcommand=yscroll.set)
    info.pack()
    xscroll.config(command=info.xview)
    yscroll.config(command=info.yview)
    fr_mod = tk.Frame(fr,bg='white')
    fr_mod.pack()
    b_name = tk.Button(fr_mod, text='Modify Name', font=('Arial', 10, 'bold'),command=cname)
    b_name.grid(row=0,column=0)
    b_excitation = tk.Button(fr_mod, text='Modify Excitation Energy', font=('Arial', 10, 'bold'),command=cexcitation)
    b_excitation.grid(row=0,column=1)
    b_desc = tk.Button(fr_mod, text='Modify Description', font=('Arial', 10, 'bold'),command=desc)
    b_desc.grid(row=0,column=2)
    # try:
    #     info.config(height=len(st.split('\n'))+1, width=max(lst), state='normal')
    #     info.insert(tk.END, '\n'+st+'\n')
    #     info.see(tk.END)
    #     info.config(state='disabled')
    # except:
    #     pass

    img1 = Image.open(io.BytesIO(b64decode(icon1))).resize([250, 250])
    tk_img1 = ImageTk.PhotoImage(img1)
    img2 = Image.open(io.BytesIO(b64decode(icon2))).resize([250, 250])
    tk_img2 = ImageTk.PhotoImage(img2)
    img3 = Image.open(io.BytesIO(b64decode(icon3))).resize([250, 250])
    tk_img3 = ImageTk.PhotoImage(img3)
    img4 = Image.open(io.BytesIO(b64decode(icon4))).resize([250, 250])
    tk_img4 = ImageTk.PhotoImage(img4)
    img5 = Image.open(io.BytesIO(b64decode(icon5))).resize([250, 250])
    tk_img5 = ImageTk.PhotoImage(img5)
    img6 = Image.open(io.BytesIO(b64decode(icon6))).resize([250, 250])
    tk_img6 = ImageTk.PhotoImage(img6)
    img7 = Image.open(io.BytesIO(b64decode(icon7))).resize([250, 250])
    tk_img7 = ImageTk.PhotoImage(img7)
    img8 = Image.open(io.BytesIO(b64decode(icon8))).resize([250, 250])
    tk_img8 = ImageTk.PhotoImage(img8)
    img9 = Image.open(io.BytesIO(b64decode(icon9))).resize([250, 250])
    tk_img9 = ImageTk.PhotoImage(img9)
    img10 = Image.open(io.BytesIO(b64decode(icon10))).resize([250, 250])
    tk_img10 = ImageTk.PhotoImage(img10)
    img11 = Image.open(io.BytesIO(b64decode(icon11))).resize([250, 250])
    tk_img11 = ImageTk.PhotoImage(img11)
    img12 = Image.open(io.BytesIO(b64decode(icon12))).resize([250, 250])
    tk_img12 = ImageTk.PhotoImage(img12)
    img13 = Image.open(io.BytesIO(b64decode(icon13))).resize([250, 250])
    tk_img13 = ImageTk.PhotoImage(img13)
    img14 = Image.open(io.BytesIO(b64decode(icon14))).resize([250, 250])
    tk_img14 = ImageTk.PhotoImage(img14)
    img15 = Image.open(io.BytesIO(b64decode(icon15))).resize([250, 250])
    tk_img15 = ImageTk.PhotoImage(img15)
    img16 = Image.open(io.BytesIO(b64decode(icon16))).resize([250, 250])
    tk_img16 = ImageTk.PhotoImage(img16)
    img17 = Image.open(io.BytesIO(b64decode(icon17))).resize([250, 250])
    tk_img17 = ImageTk.PhotoImage(img17)
    img18 = Image.open(io.BytesIO(b64decode(icon18))).resize([250, 250])
    tk_img18 = ImageTk.PhotoImage(img18)
    img19 = Image.open(io.BytesIO(b64decode(icon19))).resize([250, 250])
    tk_img19 = ImageTk.PhotoImage(img19)
    img20 = Image.open(io.BytesIO(b64decode(icon20))).resize([250, 250])
    tk_img20 = ImageTk.PhotoImage(img20)

    img = [tk_img1, tk_img2, tk_img3, tk_img4, tk_img5, tk_img6, tk_img7,
        tk_img8, tk_img9, tk_img10, tk_img11, tk_img12, tk_img13, tk_img14,
        tk_img15, tk_img16, tk_img17, tk_img18, tk_img19, tk_img20]

    mid = tk.Frame(g, bg='white')
    mid.grid(row=0, column=1)

    st = queue.Queue(maxsize=0)
    state = tk.Label(mid, text=f"Version: {__version__}", font=(
        "Arial", 14, "bold"), bg="white", fg="black")
    state.grid(row=0, column=0)

    limg = tk.Label(mid, image=img[np.random.randint(
        len(img))], width='250', height='250', bg='white')
    limg.grid(row=1, column=0)

    calf = tk.Frame(mid, bg='white')
    calf.grid(row=2, column=0)
    caldeg = tk.Label(mid, text='Deg = 0', font=(
        "Arial", 12, "bold"), bg="white", fg="black")
    caldeg.grid(row=3, column=0)

    calkl = tk.Label(calf, text='delta k (to 0)', font=(
        "Arial", 12, "bold"), bg="white", fg="black")
    calkl.grid(row=1, column=0)
    calel = tk.Label(calf, text='Kinetic Energy', font=(
        "Arial", 12, "bold"), bg="white", fg="black")
    calel.grid(row=2, column=0)


    calk = tk.StringVar()
    calk.set('0')
    calk.trace_add('write', cal)
    cale = tk.StringVar()
    cale.set('0')
    cale.trace_add('write', cal)
    calken = tk.Entry(calf, font=("Arial", 12, "bold"),
                    width=15, textvariable=calk, bd=9)
    calken.grid(row=1, column=1)
    caleen = tk.Entry(calf, font=("Arial", 12, "bold"),
                    width=15, textvariable=cale, bd=9)
    caleen.grid(row=2, column=1)


    step = tk.Frame(g, bg='white')
    step.grid(row=1, column=0, padx=10, pady=10)

    l1 = tk.Label(step, text='Step 1', font=(
        "Arial", 12, "bold"), bg="white", fg='red')
    l1.grid(row=0, column=0)
    l2 = tk.Label(step, text='Step 2', font=(
        "Arial", 12, "bold"), bg="white", fg='blue')
    l2.grid(row=1, column=0)
    l3 = tk.Label(step, text='k offset (deg)', font=(
        "Arial", 12, "bold"), bg="white", fg="black")
    l3.grid(row=2, column=0)
    l4 = tk.Label(step, text='Step 3', font=(
        "Arial", 12, "bold"), bg="white", fg='blue')
    l4.grid(row=3, column=0)
    l5 = tk.Label(step, text='Step 4', font=("Arial", 12, "bold"),
                bg="white", fg="blue", height=1)
    l5.grid(row=5, column=0)

    fremfit = tk.Frame(master=step)
    fremfit.grid(row=0, column=1)
    lf = tk.Button(fremfit, text='Load Raw Data', font=(
        "Arial", 12, "bold"), fg='red', width=15, height='1', command=load, bd=9)
    lf.grid(row=0, column=0)
    bmfit = tk.Button(fremfit, text='MDC Fit', font=(
        "Arial", 12, "bold"), fg='red', width=8, height='1', command=cmfit, bd=9)
    bmfit.grid(row=0, column=1)
    befit = tk.Button(fremfit, text='EDC Fit', font=(
        "Arial", 12, "bold"), fg='red', width=8, height='1', command=cefit, bd=9)
    befit.grid(row=0, column=2)


    cut = tk.Frame(step, bg='white')
    cut.grid(row=1, column=1)
    mdccut = tk.Button(cut, text='MDC cut', font=(
        "Arial", 12, "bold"), width=8, height='1', command=ecut, bd=9, fg='blue')
    mdccut.grid(row=0, column=0)
    edccut = tk.Button(cut, text='EDC cut', font=(
        "Arial", 12, "bold"), width=8, height='1', command=angcut, bd=9, fg='black')
    edccut.grid(row=0, column=1)
    l_lowlim = tk.Label(cut, text='Lower Limit', font=(
        "Arial", 10, "bold"), bg="white", fg="black", height=1)
    l_lowlim.grid(row=0, column=2)
    lowlim = tk.StringVar()
    lowlim.set('0')
    lowlim.trace_add('write', flowlim)
    in_lowlim = tk.Entry(cut, font=("Arial", 10, "bold"),
                        width=7, textvariable=lowlim, bd=5)
    in_lowlim.grid(row=0, column=3)


    k_offset = tk.StringVar()
    try:
        k_offset.set(ko)
    except:
        k_offset.set('0')
    k_offset.trace_add('write', reload)
    koffset = tk.Entry(step, font=("Arial", 12, "bold"),
                    width=15, textvariable=k_offset, bd=9)
    koffset.grid(row=2, column=1)
    lfit = tk.Frame(step, bg='white')
    lfit.grid(row=3, column=1)
    lmfit = tk.Button(lfit, text='Load MDC fitted File', font=(
        "Arial", 12, "bold"), width=15, height='1', command=loadmfit, bd=9, fg='blue')
    lmfit.grid(row=0, column=0)
    lefit = tk.Button(lfit, text='Load EDC fitted File', font=(
        "Arial", 12, "bold"), width=15, height='1', command=loadefit, bd=9, fg='black')
    lefit.grid(row=0, column=1)

    cfit = tk.Frame(step, bg='white')
    cfit.grid(row=4, column=1)
    b_cmfit = tk.Button(cfit, text='Clear MDC fitted File', font=(
        "Arial", 12, "bold"), width=15, height='1', command=clmfit, bd=5, fg='blue')
    b_cmfit.grid(row=0, column=0)
    b_cefit = tk.Button(cfit, text='Clear EDC fitted File', font=(
        "Arial", 12, "bold"), width=15, height='1', command=clefit, bd=5, fg='black')
    b_cefit.grid(row=0, column=1)


    lbb = tk.Button(step, text='Load Bare Band File', font=(
        "Arial", 12, "bold"), width=15, height='1', command=bareband, bd=9, fg='blue')
    lbb.grid(row=5, column=1)

    plots = tk.Frame(g, bg='white')
    plots.grid(row=1, column=1)


    cmf = tk.Frame(plots, bg='white')
    cmf.grid(row=0, column=1)

    bchcmp = tk.Button(cmf, text='Change Colormap', font=(
        "Arial", 12, "bold"), height='1', command=Chcmp, border=5)
    bchcmp.grid(row=0, column=0)

    cmlf = tk.Frame(cmf, bg='white')
    cmlf.grid(row=1, column=0)


    # Define your custom colors (as RGB tuples)
    # (value,(color))
    custom_colors1 = [(0, (1, 1, 1)),
                    (0.5, (0, 0, 1)),
                    (0.85, (0, 1, 1)),
                    (1, (1, 1, 0.26))]

    # Create a custom colormap
    custom_cmap1 = LinearSegmentedColormap.from_list(
        'custom_cmap1', custom_colors1, N=256)
    mpl.colormaps.register(custom_cmap1)

    # Define your custom colors (as RGB tuples)
    # (value,(color))
    custom_colors2 = [(0, (0, 0.08, 0.16)),
                    (0.2, (0.2, 0.7, 1)),
                    (0.4, (0.28, 0.2, 0.4)),
                    (0.62, (0.9, 0.1, 0.1)),
                    (0.72, (0.7, 0.34, 0.1)),
                    (0.8, (1, 0.5, 0.1)),
                    (1, (1, 1, 0))]

    # Create a custom colormap
    custom_cmap2 = LinearSegmentedColormap.from_list(
        'custom_cmap2', custom_colors2, N=256)
    mpl.colormaps.register(custom_cmap2)

    # Define your custom colors (as RGB tuples)
    # (value,(color))
    custom_colors3 = [(0, (0.88, 0.84, 0.96)),
                    (0.5, (0.32, 0, 0.64)),
                    (0.75, (0, 0, 1)),
                    (0.85, (0, 0.65, 1)),
                    (0.9, (0.2, 1, 0.2)),
                    (0.96, (0.72, 1, 0)),
                    (1, (1, 1, 0))]

    # Create a custom colormap
    custom_cmap3 = LinearSegmentedColormap.from_list(
        'custom_cmap3', custom_colors3, N=256)
    mpl.colormaps.register(custom_cmap3)

    # Define your custom colors (as RGB tuples)
    # (value,(color))
    custom_colors4 = [(0, (1, 1, 1)),
                    (0.4, (0.3, 0, 0.3)),
                    (0.5, (0.3, 0, 0.6)),
                    (0.6, (0, 1, 1)),
                    (0.7, (0, 1, 0)),
                    (0.8, (1, 1, 0)),
                    (1, (1, 0, 0))]

    # Create a custom colormap
    custom_cmap4 = LinearSegmentedColormap.from_list(
        'custom_cmap4', custom_colors4, N=256)
    mpl.colormaps.register(custom_cmap4)

    # Define your custom colors (as RGB tuples)
    # (value,(color))
    prevac_colors = [(0, (0.2*0.82, 0.2*0.82, 0.2*0.82)),
                    (0.2, (0.4*0.82, 0.6*0.82, 0.9*0.82)),
                    (0.4, (0, 0.4*0.82, 0)),
                    (0.6, (0.5*0.82, 1*0.82, 0)),
                    (0.8,(1*0.82, 1*0.82, 0)),
                    (1, (1*0.82, 0, 0))]
    # Create a custom colormap
    prevac_cmap = LinearSegmentedColormap.from_list(
        'prevac_cmap', prevac_colors, N=256)
    mpl.colormaps.register(prevac_cmap)

    optionList3 = ['prevac_cmap', 'terrain', 'custom_cmap1', 'custom_cmap2', 'custom_cmap3', 'custom_cmap4', 'viridis', 'turbo',
                'inferno', 'plasma', 'copper', 'grey', 'bwr']
    cmp = plt.colormaps()
    value3 = tk.StringVar()
    value3.set('prevac_cmap')
    value3.trace_add('write', chcmp)
    setcmap = tk.OptionMenu(cmlf, value3, *optionList3)
    setcmap.grid(row=0, column=1)
    cm = tk.OptionMenu(cmlf, value3, *cmp)
    cm.grid(row=1, column=1)

    c1 = tk.Label(cmlf, text='Commonly Used:', font=(
        "Arial", 12), bg="white", height='1')
    c1.grid(row=0, column=0)
    c2 = tk.Label(cmlf, text='All:', font=("Arial", 12), bg="white", height='1')
    c2.grid(row=1, column=0)

    frraw = tk.Frame(plots, bg='white')
    frraw.grid(row=1, column=1)

    optionList = ['Raw Data', 'E-K Diagram', 'MDC Normalized',
                'First Derivative', 'Second Derivative', 'MDC Curves', 'E-K with MDC Curves']   # 選項
    value = tk.StringVar()                                        # 取值
    value.set('---Plot1---')
    # 第二個參數是取值，第三個開始是選項，使用星號展開
    menu1 = tk.OptionMenu(frraw, value, *optionList)
    menu1.grid(row=0, column=0)
    value.trace_add('write', plot1)

    b_spec = tk.Button(frraw, text='Spectrogram', fg='red', font=("Arial", 12, "bold"),width=10, height='1', command=trans_plot, bd=5)
    b_spec.grid(row=0, column=1)

    b_emode = tk.Button(frraw, text='K.E.', fg='blue', font=("Arial", 12, "bold"), width=5, height='1', command=emode, bd=5)
    b_emode.grid(row=0, column=2)

    frfit = tk.Frame(plots, bg='white')
    frfit.grid(row=2, column=1)
    optionList1 = ['MDC fitted Data', 'EDC fitted Data',
                'Real Part', 'Imaginary Part']   # 選項
    value1 = tk.StringVar()                                        # 取值
    value1.set('---Plot2---')
    # 第二個參數是取值，第三個開始是選項，使用星號展開
    menu2 = tk.OptionMenu(frfit, value1, *optionList1)
    menu2.grid(row=0, column=0)
    value1.trace_add('write', plot2)
    
    ##### Base and FWHM not packing to frfit #####
    l_fit = tk.Label(frfit, text='Base counts:', font=(
        "Arial", 10, "bold"), bg="white", height='1', bd=5)
    # l_fit.grid(row=0, column=1)
    base = tk.StringVar()
    base.set('0')
    base.trace_add('write', fbase)
    in_fit = tk.Entry(frfit, font=("Arial", 10), width=5, textvariable=base, bd=5)
    # in_fit.grid(row=0, column=2)
    b_fit = tk.Button(frfit, text='Fit FWHM', font=(
        "Arial", 10, "bold"), bg="white", height='1', bd=5, command=fitgl)
    # b_fit.grid(row=0, column=3)
    ##### Base and FWHM not packing to frfit #####

    optionList2 = ['Real & Imaginary', 'KK Transform Real & Imaginary', 'KK Transform Real Part', 'KK Transform Imaginary Part', 'KK Transform Real Part 2nd Derivative', 'KK Transform Imaginary Part 1st Derivative', 'Data Plot with Pos', 'Data Plot with Pos and Bare Band']   # 選項
    value2 = tk.StringVar()                                        # 取值
    value2.set('---Plot3---')
    # 第二個參數是取值，第三個開始是選項，使用星號展開
    menu3 = tk.OptionMenu(plots, value2, *optionList2)
    menu3.grid(row=3, column=1)
    value2.trace('w', plot3)
        
    bb_offset = tk.StringVar()
    try:
        bb_offset.set(bbo)
    except:
        bb_offset.set('0')
    bb_offset.trace_add('write', fbb_offset)
    bboffset = tk.Entry(plots, font=("Arial", 12, "bold"),
                        width=15, textvariable=bb_offset, bd=9)
    bboffset.grid(row=4, column=1)
    bbk_offset = tk.StringVar()
    try:
        bbk_offset.set(bbk)
    except:
        bbk_offset.set('1')
    bbk_offset.trace_add('write', fbbk_offset)
    bbkoffset = tk.Entry(plots, font=("Arial", 12, "bold"),
                        width=15, textvariable=bbk_offset, bd=9)
    bbkoffset.grid(row=5, column=1)

    lcmp = tk.Frame(plots, bg='white')
    lcmp.grid(row=0, column=0)

    lcmpd = Figure(figsize=(0.75, 1), layout='constrained')
    cmpg = FigureCanvasTkAgg(lcmpd, master=lcmp)
    cmpg.get_tk_widget().grid(row=0, column=1)
    lsetcmap = tk.Label(lcmp, text='Colormap:', font=(
        "Arial", 12, "bold"), bg="white", height='1', bd=9)
    lsetcmap.grid(row=0, column=0)
    chcmp()

    m1 = tk.Label(plots, text='Raw', font=(
        "Arial", 12, "bold"), bg="white", fg='red')
    m1.grid(row=1, column=0)
    m2 = tk.Label(plots, text='Fit', font=(
        "Arial", 12, "bold"), bg="white", fg='blue')
    m2.grid(row=2, column=0)
    m3 = tk.Label(plots, text='Transform', font=(
        "Arial", 12, "bold"), bg="white", fg="blue")
    m3.grid(row=3, column=0)
    l6 = tk.Label(plots, text='Bare band E offset (meV)', font=(
        "Arial", 12, "bold"), bg="white", fg="black", height=1)
    l6.grid(row=4, column=0)
    l7 = tk.Label(plots, text='Bare band k ratio', font=(
        "Arial", 12, "bold"), bg="white", fg="black", height=1)
    l7.grid(row=5, column=0)


    figfr = tk.Frame(g, bg='white')
    figfr.grid(row=0, column=2, padx=10, pady=10)

    fig = Figure(figsize=(8, 6), layout='constrained')
    out = FigureCanvasTkAgg(fig, master=figfr)
    out.get_tk_widget().grid(row=0, column=0)
    out.mpl_connect('motion_notify_event', move)
    out.mpl_connect('button_press_event', press)
    out.mpl_connect('button_release_event', release)

    xydata = tk.Frame(figfr, bg='white')
    xydata.grid(row=1, column=0)

    xdata = tk.Label(xydata, text='xdata:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=9, bg='white')
    xdata.grid(row=0, column=0)
    ydata = tk.Label(xydata, text='ydata:', font=(
        "Arial", 12, "bold"), width='15', height='1', bd=9, bg='white')
    ydata.grid(row=0, column=1)
    b_copyimg = tk.Button(xydata, fg='red', text='Copy Image to Clipboard', font=('Arial', 12, 'bold'), command=f_copy_to_clipboard, bd=9)
    b_copyimg.grid(row=0, column=2)
    
    dl=0
    b_sw = tk.Button(xydata, text='dot', font=('Arial', 12, 'bold'), command=dl_sw, bd=9)

    exf = tk.Frame(g, bg='white')
    exf.grid(row=1, column=2)

    clim = tk.Frame(exf, bg='white')
    clim.grid(row=0, column=0)
    lcmax = tk.Label(clim, text='Maximum', font=(
        'Arial', 12), bg='white', fg='white')
    lcmax.grid(row=0, column=0)
    lcmin = tk.Label(clim, text='Minimum', font=(
        'Arial', 12), bg='white', fg='white')
    lcmin.grid(row=1, column=0)
    cmax = tk.Frame(clim, bg='white', width=15, bd=9)
    cmax.grid(row=0, column=1)
    cmin = tk.Frame(clim, bg='white', width=15, bd=9)
    cmin.grid(row=1, column=1)


    cM = tk.DoubleVar()
    cm = tk.DoubleVar()
    cM.set(10000)
    cm.set(-10000)
    vcmax = tk.DoubleVar()
    vcmax.set(10000)
    vcmax.trace_add('write', cmaxrange)
    Cmax = tk.Scale(cmax, from_=cm.get(), to=cM.get(), orient='horizontal',
                    variable=vcmax, state='disabled', bg='white', fg='white')
    Cmax.pack()
    vcmin = tk.DoubleVar()
    vcmin.set(-10000)
    vcmin.trace_add('write', cminrange)
    Cmin = tk.Scale(cmin, from_=cm.get(), to=cM.get(), orient='horizontal',
                    variable=vcmin, state='disabled', bg='white', fg='white')
    Cmin.pack()

    expf = tk.Frame(exf, bg='white')
    expf.grid(row=1,column=0)
    ex = tk.Button(expf, fg='red', text='Export Graph', font=(
        "Arial", 12, "bold"), height='1', command=exp, bd=9)
    ex.grid(row=0, column=0)
    exo = tk.Button(expf, fg='blue', text='Export to Origin', font=(
        "Arial", 12, "bold"), height='1', command=gui_exp_origin, bd=9)
    exo.grid(row=0, column=1)
    extm = tk.Button(exf, text='Export MDC Fitted Data (k offset)', font=(
        "Arial", 12, "bold"), height='1', command=exptm, bd=9)
    extm.grid(row=2, column=0)
    exte = tk.Button(exf, text='Export EDC Fitted Data (k offset)', font=(
        "Arial", 12, "bold"), height='1', command=expte, bd=9)
    exte.grid(row=3, column=0)
    # fig = plt.figure(layout='constrained')
    # axs = fig.subplots()
    tt = threading.Thread(target=tstate)
    tt.daemon = True
    tt.start()
    try:
        info.config(state='normal')
        pr_load(data)
        if len(lfs.name) > 1:
            if len(lfs.n)>0:lfs.sort='no'
            b_tools = tk.Button(fr_tool, text='Batch Master', command=tools, width=12, height=1, font=('Arial', 12, "bold"), bg='white')
            b_tools.grid(row=0, column=0)
            nlist = lfs.name
            namevar = tk.StringVar(value=nlist[0])
            l_name = tk.OptionMenu(fr_tool, namevar, *nlist, command=change_file)
            l_name.config(font=('Arial', 16, 'bold'))
            l_name.grid(row=0, column=1)
        if lfs.f_npz[0]:
            npzf = True
            koffset.config(state='normal')
            k_offset.set('0')
            koffset.config(state='disabled')
    except:
        pass
    print(f"Version: {__version__}")
    print(f"Release Date: {__release_date__}\n")
    ###### hotkey ######
    g.bind('<Return>', plot)
    g.bind('<Up>', cf_up)
    g.bind('<Down>', cf_down)
    g.bind('<MouseWheel>', scroll)
    g.bind('<MouseWheel>', scroll)
    g.update_idletasks()
    screen_width = g.winfo_reqwidth()
    screen_height = g.winfo_reqheight()
    g.geometry(f"{screen_width}x{screen_height}+0+0")
    # g.protocol("WM_DELETE_WINDOW", quit)
    g.update()
    if cec is not None: # CEC loaded old data to show the cutting rectangle
        cec.tlg.focus_set()
    g.mainloop()
